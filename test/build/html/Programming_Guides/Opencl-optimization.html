

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>OPENCL Optimization &mdash; ReadTheDocs-Breathe 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ReadTheDocs-Breathe
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../ROCm.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Current_Release_Notes/Current-Release-Notes.html">Current Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Installation_Guide/Installation-Guide.html">ROCm Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Programming-Guides.html">Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_GPU_Tunning_Guides/ROCm-GPU-Tunning-Guides.html">ROCm GPU Tuning Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GCN_ISA_Manuals/GCN-ISA-Manuals.html">GCN ISA Manuals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_API_References/ROCm-API-References.html">ROCm API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Tools/ROCm-Tools.html">ROCm Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Libraries/ROCm_Libraries.html">ROCm Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Compiler_SDK/ROCm-Compiler-SDK.html">ROCm Compiler SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_System_Managment/ROCm-System-Managment.html">ROCm System Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Virtualization_Containers/ROCm-Virtualization-&amp;-Containers.html">ROCm Virtualization &amp; Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Remote_Device_Programming/Remote-Device-Programming.html">Remote Device Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Deep_learning/Deep-learning.html">Deep Learning on ROCm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Other_Solutions/Other-Solutions.html">System Level Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorial/Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Glossary/ROCm-Glossary.html">ROCm Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ReadTheDocs-Breathe</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>OPENCL Optimization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Programming_Guides/Opencl-optimization.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="opencl-optimization">
<span id="optimization-opencl"></span><h1>OPENCL Optimization<a class="headerlink" href="#opencl-optimization" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Re-Write in Progress to move this to Vega and FIJI/Polaris optimization guide</p>
</div>
<div class="section" id="chapter-1-opencl-performance-and-optimization">
<h2>Chapter 1 OpenCL Performance and Optimization<a class="headerlink" href="#chapter-1-opencl-performance-and-optimization" title="Permalink to this headline">¶</a></h2>
<p>This chapter discusses performance and optimization when programming for AMD heterogeneous compute GPU compute devices, as well as CPUs and multiple devices. Details specific to the GCN family (Southern Islands, Sea Islands, and Volcanic Islands series) of GPUs are at the end of the chapter.</p>
<div class="section" id="amd-codexl">
<h3>1.1 AMD CodeXL<a class="headerlink" href="#amd-codexl" title="Permalink to this headline">¶</a></h3>
<p>AMD’s CodeXL is an OpenCL kernel debugging and memory and performance analysis tool that gathers data from the OpenCL run-time and OpenCL devices during the execution of an OpenCL application. This information is used to discover bottlenecks in the application and find ways to optimize the application’s performance for AMD platforms.</p>
<p>CodeXL 1.7, the latest version as of this writing, is available as an extension to Microsoft® Visual Studio®, a stand-alone version for Windows, and a stand-alone version for Linux.</p>
<p>For a high-level summary of CodeXL features, see Chapter 4 in the AMD OpenCL User Guide. For information about how to use CodeXL to gather performance data about your OpenCL application, such as application traces and timeline views, see the <a class="reference external" href="https://gpuopen.com/compute-product/codexl/?webSyncID=aa83689b-1c51-8139-08ba-c72c235854a7&amp;sessionGUID=ab8d35ae-1db8-2ec6-4d4a-290691c91072">CodeXL home page</a>.</p>
<p>The Timeline View can be useful for debugging your OpenCL application. Examples are given below.</p>
<ul class="simple">
<li>The Timeline View lets you easily confirm that the high-level structure of your application is correct by verifying that the number of queues and contexts created match your expectations for the application.</li>
<li>You can confirm that synchronization has been performed properly in the application. For example, if kernel A execution is dependent on a buffer operation and outputs from kernel B execution, then kernel A execution must appear after the completion of the buffer execution and kernel B execution in the time grid. It can be hard to find this type of synchronization error using traditional debugging techniques.</li>
<li>You can confirm that the application has been using the hardware efficiently.</li>
</ul>
<p>For example, the timeline should show that non-dependent kernel executions and data transfer operations occurred simultaneously.</p>
<p>CodeXL also provides information about GPU kernel performance counters. This information can be used to find possible bottlenecks in the kernel execution. You can find the list of performance counters supported by AMD Radeon™ GPUs in the CodeXL documentation. Once the trace data has been used to discover which kernel is most in need of optimization, you can collect the GPU performance counters to drill down into the kernel execution on a GPU device.</p>
<p>The Analyze Mode in CodeXL provides the Statistics View, which can be used to gather useful statistics regarding the GPU usage of kernels.</p>
</div>
<div class="section" id="estimating-performance">
<h3>1.2 Estimating Performance<a class="headerlink" href="#estimating-performance" title="Permalink to this headline">¶</a></h3>
<div class="section" id="measuring-execution-time">
<h4>1.2.1 Measuring Execution Time<a class="headerlink" href="#measuring-execution-time" title="Permalink to this headline">¶</a></h4>
<p>The OpenCL runtime provides a built-in mechanism for timing the execution of kernels by setting the CL_QUEUE_PROFILING_ENABLE flag when the queue is created. Once profiling is enabled, the OpenCL runtime automatically records timestamp information for every kernel and memory operation submitted to the queue.</p>
<p>OpenCL provides four timestamps:</p>
<ul class="simple">
<li><strong>CL_PROFILING_COMMAND_QUEUED</strong> - Indicates when the command is enqueued into a command-queue on the host. This is set by the OpenCL runtime when the user calls an clEnqueue* function.</li>
<li><strong>CL_PROFILING_COMMAND_SUBMIT</strong> - Indicates when the command is submitted to the device. For AMD GPU devices, this time is only approximately defined and is not detailed in this section.</li>
<li><strong>CL_PROFILING_COMMAND_START</strong> - Indicates when the command starts execution on the requested device.</li>
<li><strong>CL_PROFILING_COMMAND_END</strong> - Indicates when the command finishes execution on the requested device.</li>
</ul>
<p>The sample code below shows how to compute the kernel execution time (End- Start):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cl_event myEvent;
cl_ulong startTime, endTime;

clCreateCommandQueue (..., CL_QUEUE_PROFILING_ENABLE, NULL);
clEnqueueNDRangeKernel(..., &amp;myEvent);
``clFinish`` (myCommandQ); // wait for all events to finish

clGetEventProfilingInfo(myEvent, CL_PROFILING_COMMAND_START, sizeof(cl_ulong), &amp;startTime, NULL);
clGetEventProfilingInfo(myEvent,       CL_PROFILING_COMMAND_END, sizeof(cl_ulong), &amp;endTimeNs, NULL);
cl_ulong kernelExecTimeNs = endTime-startTime;
</pre></div>
</div>
<p>The CodeXL GPU Profiler also can record the execution time for a kernel automatically. The Kernel Time metric reported in the Profiler output uses the built-in OpenCL timing capability and reports the same result as the
<code class="docutils literal notranslate"><span class="pre">kernelExecTimeNs</span></code> calculation shown above.</p>
<p>Another interesting metric to track is the kernel launch time (Start - Queue). The kernel launch time includes both the time spent in the user application (after enqueuing the command, but before it is submitted to the device), as well as the time spent in the runtime to launch the kernel. For CPU devices, the kernel launch time is fast (tens of 1’s), but for discrete GPU devices it can be several hundred Î¼s. Enabling profiling on a command queue adds approximately 10 Î¼s to 40 Î¼s overhead to all clEnqueue calls. Much of the profiling overhead affects the start time; thus, it is visible in the launch time. Be careful when interpreting this metric. To reduce the launch overhead, the AMD OpenCL runtime combines several command submissions into a batch. Commands submitted as batch report similar start times and the same end time.</p>
<p>Measure performance of your test with CPU counters. Do not use OCL profiling. To determine if an application is executed asynchonically, build a dependent execution with OCL events. This is a “generic” solution; however, there is an exception when you can enable profiling and have overlap transfers. DRMDMA engines do not support timestamps (“GPU counters”). To get OCL profiling data, the runtime must synchronize the main command processor (CP) with the DMA engine; this disables overlap. Note, however, that Southern Islands has two independent main CPs and runtime pairs them with DMA engines. So, the application can still execute kernels on one CP, while another is synced with a DRM engine for profiling; this lets you profile it with APP or OCL profiling.</p>
</div>
<div class="section" id="using-the-opencl-timer-with-other-system-timers">
<h4>1.2.2 Using the OpenCL timer with Other System Timers<a class="headerlink" href="#using-the-opencl-timer-with-other-system-timers" title="Permalink to this headline">¶</a></h4>
<p>The resolution of the timer, given in ns, can be obtained from:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clGetDeviceInfo</span><span class="p">(</span><span class="o">...</span><span class="p">,</span><span class="n">CL_DEVICE_PROFILING_TIMER_RESOLUTION</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>AMD CPUs and GPUs report a timer resolution of 1 ns. AMD OpenCL devices are required to correctly track time across changes in frequency and power states. Also, the AMD APP SDK uses the same time-domain for all devices in the platform; thus, the profiling timestamps can be directly compared across the CPU and GPU devices.</p>
<p>The sample code below can be used to read the current value of the OpenCL timer clock. The clock is the same routine used by the AMD OpenCL runtime to generate the profiling timestamps. This function is useful for correlating other program events with the OpenCL profiling timestamps.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uint64_t</span> <span class="n">timeNanos</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">#ifdef linux</span>
 <span class="n">struct</span> <span class="n">timespec</span> <span class="n">tp</span><span class="p">;</span>
 <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="p">);</span>
 <span class="k">return</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span><span class="p">)</span> <span class="n">tp</span><span class="o">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000</span><span class="n">ULL</span> <span class="o">*</span> <span class="mi">1000</span><span class="n">ULL</span> <span class="o">*</span> <span class="mi">1000</span><span class="n">ULL</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span><span class="p">)</span> <span class="n">tp</span><span class="o">.</span><span class="n">tv_nsec</span><span class="p">;</span>

<span class="c1">#else</span>
  <span class="n">LARGE_INTEGER</span> <span class="n">current</span><span class="p">;</span> <span class="n">QueryPerformanceCounter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span><span class="p">)((</span><span class="n">double</span><span class="p">)</span><span class="n">current</span><span class="o">.</span><span class="n">QuadPart</span> <span class="o">/</span> <span class="n">m_ticksPerSec</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">);</span>
<span class="c1">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Normal CPU time-of-day routines can provide a rough measure of the elapsed time of a GPU kernel. GPU kernel execution is non-blocking, that is, calls to <code class="docutils literal notranslate"><span class="pre">enqueue*Kernel</span></code> return to the CPU before the work on the GPU is finished. For an accurate time value, ensure that the GPU is finished. In OpenCL, you can force the CPU to wait for the GPU to become idle by inserting calls to <code class="docutils literal notranslate"><span class="pre">clFinish()</span></code> before and after the sequence you want to time; this increases the timing accuracy of the CPU routines. The routine <code class="docutils literal notranslate"><span class="pre">clFinish()</span></code> blocks the CPU until all previously enqueued OpenCL commands have finished.</p>
<p>For more information, see section 5.9, “Profiling Operations on Memory Objects and Kernels,”of the OpenCL 1.0 Specification.</p>
</div>
<div class="section" id="estimating-memory-bandwidth">
<h4>1.2.3 Estimating Memory Bandwidth<a class="headerlink" href="#estimating-memory-bandwidth" title="Permalink to this headline">¶</a></h4>
<p>The memory bandwidth required by a kernel is perhaps the most important performance consideration. To calculate this:</p>
<blockquote>
<div>Effective Bandwidth = (Br + Bw)/T</div></blockquote>
<p>where:</p>
<blockquote>
<div>Br = total number of bytes read from global memory. Bw = total number of bytes written to global memory.
T = time required to run kernel, specified in nanoseconds.</div></blockquote>
<p>If Br and Bw are specified in bytes, and T in ns, the resulting effective bandwidth is measured in GB/s, which is appropriate for current CPUs and GPUs for which the peak bandwidth range is 20-260 GB/s. Computing Br and Bw requires a
thorough understanding of the kernel algorithm; it also can be a highly effective
way to optimize performance. For illustration purposes, consider a simple matrix addition: each element in the two source arrays is read once, added together, then stored to a third array. The effective bandwidth for a 1024x1024 matrix addition is calculated as:</p>
<p>Br = 2 x (1024 x 1024 x 4 bytes) = 8388608 bytes  ;; 2 arrays, 1024x1024, each element 4-byte float</p>
<p>Bw = 1 x (1024 x 1024 x 4 bytes) = 4194304 bytes ;; 1 array, 1024x1024, each element 4-byte float.</p>
<p>If the elapsed time for this copy as reported by the profiling timers is 1000000 ns
(1 million ns, or .001 sec), the effective bandwidth is: (Br+Bw)/T = (8388608+4194304)/1000000 = 12.6GB/s</p>
<p>The CodeXL GPU Profiler can report the number of dynamic instructions per thread that access global memory through the FetchInsts and WriteInsts counters. The Fetch and Write reports average the per-thread counts; these can be fractions if the threads diverge. The Profiler also reports the dimensions of the global NDRange for the kernel in the GlobalWorkSize field. The total number of threads can be determined by multiplying together the three components of the range. If all (or most) global accesses are the same size, the counts from the Profiler and the approximate size can be used to estimate Br and Bw:</p>
<p>Br = Fetch * GlobalWorkitems * Size</p>
<p>Bw = Write * GlobalWorkitems * Element Size where GlobalWorkitems is the dispatch size.
An example Profiler output and bandwidth calculation:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="28%" />
<col width="14%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">GlobalWorkSize</th>
<th class="head">Time</th>
<th class="head">Fetch</th>
<th class="head">Write</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>runKernel_Cypress</td>
<td>{192; 144; 1}</td>
<td>0.9522</td>
<td>70.8</td>
<td>0.5</td>
</tr>
</tbody>
</table>
<p>WaveFrontSize = 192*144*1 = 27648 global work items.</p>
<p>In this example, assume we know that all accesses in the kernel are four bytes;
then, the bandwidth can be calculated as: Br = 70.8 * 27648 * 4 = 7829914 bytes Bw = 0.5 * 27648 * 4 = 55296 bytes
The bandwidth then can be calculated as:</p>
<dl class="docutils">
<dt>(Br + Bw)/T = (7829914 bytes + 55296 bytes) / .9522 ms / 1000000</dt>
<dd>= 8.2 GB/s</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The performance model assumes zero cache utilization. If the kernel is reading the same data over and over again, it will be cached in the GPU L1/L2 memory and will not affect global memory bandwidth.</p>
</div>
</div>
</div>
<div class="section" id="opencl-memory-objects">
<h3>1.3 OpenCL Memory Objects<a class="headerlink" href="#opencl-memory-objects" title="Permalink to this headline">¶</a></h3>
<p>This section explains the AMD OpenCL runtime policy for memory objects. It also recommends best practices for best performance.</p>
<p>OpenCL uses memory objects to pass data to kernels. These can be either buffers or images. Space for these is managed by the runtime, which uses several types of memory, each with different performance characteristics. Each type of memory is suitable for a different usage pattern. The following subsections describe:</p>
<ul class="simple">
<li>the memory types used by the runtime;</li>
<li>how to control which memory kind is used for a memory object;</li>
<li>how the runtime maps memory objects for host access;</li>
<li>how the runtime performs memory object reading, writing and copying;</li>
<li>how best to use command queues; and</li>
<li>some recommended usage patterns.</li>
</ul>
<div class="section" id="types-of-memory-used-by-the-runtime">
<h4>1.3.1 Types of Memory Used by the Runtime<a class="headerlink" href="#types-of-memory-used-by-the-runtime" title="Permalink to this headline">¶</a></h4>
<p>Memory is used to store memory objects that are accessed by kernels executing on the device, as well as to hold memory object data when they are mapped for access by the host application. This section describes the different memory kinds used by the runtime. Table 1.1 lists the performance of each memory type given
a PCIe3-capable platform and a high-end AMD Radeon™ 7XXX discrete GPU. In Table 1.1, when host memory is accessed by the GPU shader, it is of type <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code>. When GPU memory is accessed by the CPU, it is of type <code class="docutils literal notranslate"><span class="pre">CL_MEM_PERSISTENT_MEM_AMD</span></code>.</p>
<p><strong>Table 1.1 Memory Bandwidth in GB/s (R = read, W = write) in GB/s</strong></p>
<p><strong>Table 2:</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="11%" />
<col width="11%" />
<col width="17%" />
<col width="17%" />
<col width="13%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">CPU R</th>
<th class="head">GPU W</th>
<th class="head">GPU Shader R</th>
<th class="head">GPU Shader W</th>
<th class="head">GPU DMA R</th>
<th class="head">GPU DMA W</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Host Memory</td>
<td>10 - 20</td>
<td>10 - 20</td>
<td>9 - 10</td>
<td>2.5</td>
<td>11 - 12</td>
<td>11 - 12</td>
</tr>
<tr class="row-odd"><td>GPU Memory</td>
<td>.01</td>
<td>9 - 10</td>
<td>230</td>
<td>120 -150</td>
<td>n/a</td>
<td>n/a</td>
</tr>
</tbody>
</table>
<p>Host memory and device memory in the above table consists of one of the subtypes given below.</p>
<div class="section" id="unpinned-host-memory">
<h5>1.3.1.1 Unpinned Host Memory<a class="headerlink" href="#unpinned-host-memory" title="Permalink to this headline">¶</a></h5>
<p>This regular CPU memory can be accessed by the CPU at full memory bandwidth; however, it is not directly accessible by the GPU. For the GPU to transfer host memory to device memory (for example, as a parameter to <code class="docutils literal notranslate"><span class="pre">clEnqueueReadBuffer</span></code> or <code class="docutils literal notranslate"><span class="pre">clEnqueueWriteBuffer</span></code>), it first must be pinned (see section 1.3.1.2). Pinning takes time, so avoid incurring pinning costs where CPU overhead must be avoided.</p>
<p>When unpinned host memory is copied to device memory, the OpenCL runtime uses the following transfer methods.</p>
<blockquote>
<div><ul class="simple">
<li>&lt;=32 kB: For transfers from the host to device, the data is copied by the CPU to a runtime pinned host memory buffer, and the DMA engine transfers the data to device memory. The opposite is done for transfers from the device to the host.</li>
<li>&gt;32 kB and &lt;=16 MB: The host memory physical pages containing the data are pinned, the GPU DMA engine is used, and the pages then are unpinned.</li>
<li>&gt;16 MB: Runtime pins host memory in stages of 16 MB blocks and transfers data to the device using the GPU DMA engine. Double buffering for pinning is used to overlap the pinning cost of each 16 MB block with the DMA transfer.</li>
</ul>
</div></blockquote>
<p>Due to the cost of copying to staging buffers, or pinning/unpinning host memory, host memory does not offer the best transfer performance.</p>
</div>
<div class="section" id="pinned-host-memory">
<h5>1.3.1.2 Pinned Host Memory<a class="headerlink" href="#pinned-host-memory" title="Permalink to this headline">¶</a></h5>
<p>This is host memory that the operating system has bound to a fixed physical address and that the operating system ensures is resident. The CPU can access pinned host memory at full memory bandwidth. The runtime limits the total amount of pinned host memory that can be used for memory objects. (See Section 1.3.2, “Placement” , for information about pinning memory.</p>
<p>If the runtime knows the data is in pinned host memory, it can be transferred to, and from, device memory without requiring staging buffers or having to perform pinning/unpinning on each transfer. This offers improved transfer performance.</p>
<p>Currently, the runtime recognizes only data that is in pinned host memory for operation arguments that are memory objects it has allocated in pinned host memory. For example, the buffer argument of <code class="docutils literal notranslate"><span class="pre">clEnqueueReadBuffer/clEnqueueWriteBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">image</span></code> argument of <code class="docutils literal notranslate"><span class="pre">clEnqueueReadImage/clEnqueueWriteImage.</span></code> It does not detect that the ptr arguments of these operations addresses pinned host memory, even if they are the result of <code class="docutils literal notranslate"><span class="pre">clEnqueueMapBuffer/clEnqueueMapImage</span></code> on a memory object that is in pinned host memory.</p>
<p>The runtime can make pinned host memory directly accessible from the GPU. Like regular host memory, the CPU uses caching when accessing pinned host memory. For discrete devices, the GPU access to this memory is through the PCIe bus, which also limits bandwidth. For APU devices that do not have the PCIe overhead, GPU access is significantly slower than accessing device-visible host memory (see section 1.3.1.3), which does not use the cache coherency protocol.</p>
</div>
<div class="section" id="device-visible-host-memory">
<h5>1.3.1.3 Device-Visible Host Memory<a class="headerlink" href="#device-visible-host-memory" title="Permalink to this headline">¶</a></h5>
<p>The runtime allocates a limited amount of pinned host memory that is accessible by the GPU without using the CPU cache coherency protocol. This allows the GPU to access the memory at a higher bandwidth than regular pinned host memory.</p>
<p>A portion of this memory is also configured to be accessible by the CPU as uncached memory. Thus, reads by the CPU are significantly slower than those from regular host memory. However, these pages are also configured to use the memory system write combining buffers. A user allocated buffer is internally partitioned by the chip-set to write combine regions. The size and alignment of these regions are chip-set dependent. Typically, the regions are 64 bytes in size, each aligned to start on a 64-byte memory address.</p>
<p>These allow writes to adjacent memory locations to be combined into a single memory access. This allows CPU streaming writes to perform reasonably well. Scattered writes that do not fill the write combining buffers before they have to be flushed do not perform as well.</p>
<p>APU devices have no device memory and use device-visible host memory for their global device memory.</p>
</div>
<div class="section" id="device-memory">
<h5>1.3.1.4 Device Memory<a class="headerlink" href="#device-memory" title="Permalink to this headline">¶</a></h5>
<p>Discrete GPU devices have their own dedicated memory, which provides the highest bandwidth for GPU access. The CPU cannot directly access device memory on a discrete GPU (except for the host-visible device memory portion described in section 1.3.1.5).</p>
<p>On an APU, the system memory is shared between the GPU and the CPU; it is visible by either the CPU or the GPU at any given time. A significant benefit of this is that buffers can be zero copied between the devices by using map/unmap operations to logically move the buffer between the CPU and the GPU address space. (Note that in the system BIOS at boot time, it is possible to allocate the size of the frame buffer. This section of memory is divided into two parts, one of which is invisible to the CPU. Thus, not all system memory supports zero copy. See Table 1.1, specifically the Default row.) See Section 1.3.4, “Mapping”, for more information on zero copy.</p>
</div>
<div class="section" id="host-visible-device-memory">
<h5>1.3.1.5 Host-Visible Device Memory<a class="headerlink" href="#host-visible-device-memory" title="Permalink to this headline">¶</a></h5>
<p>A limited portion of discrete GPU device memory is configured to be directly accessible by the CPU. It can be accessed by the GPU at full bandwidth, but CPU access is over the PCIe bus; thus, it is much slower than host memory bandwidth. The memory is mapped into the CPU address space as uncached, but using the memory system write combining buffers. This results in slow CPU reads and scattered writes, but streaming CPU writes perform much better because they reduce PCIe overhead.</p>
</div>
</div>
<div class="section" id="placement">
<h4>1.3.2 Placement<a class="headerlink" href="#placement" title="Permalink to this headline">¶</a></h4>
<p>Every OpenCL memory object has a location that is defined by the flags passed to clCreateBuffer/clCreateImage. A memory object can be located either on a device, or it can be located on the host and accessed directly by all the devices. The Location column of Table 1.1 gives the memory type used for each of the allocation flag values for different kinds of devices. When a device kernel is executed, it accesses the contents of memory objects from this location. The performance of these accesses is determined by the kind of memory used.</p>
<p>An OpenCL context can have multiple devices, and a memory object that is located on a device has a location on each device. To avoid over-allocating device memory for memory objects that are never used on that device, space is not allocated until first used on a device-by-device basis. For this reason, the first use of a memory object after it is created can be slower than subsequent uses.</p>
<p><strong>Table 1.1 OpenCL Memory Object Properties</strong></p>
<p><strong>Table 2:</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="4%" />
<col width="36%" />
<col width="4%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">clCreateBuffer/
clCreateImage FlagsArgument</th>
<th class="head" rowspan="2">Device Type</th>
<th class="head" rowspan="2">Location</th>
<th class="head" colspan="2">clEnqueueMapBuffer/
clEnqueueMapImage/
clEnqueueUnmapMemObject</th>
</tr>
<tr class="row-even"><th class="head">MapMode</th>
<th class="head">Map Location</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td rowspan="3">Default(none of the following flags)</td>
<td>DiscreteGPU</td>
<td>Device memory</td>
<td rowspan="2">Copy</td>
<td rowspan="3">Host memory(different memoryarea can be used oneach map)</td>
</tr>
<tr class="row-even"><td>APU</td>
<td>Device-visible hostmemory</td>
</tr>
<tr class="row-odd"><td>CPU</td>
<td>Use Map Locationdirectly</td>
<td>Zero copy</td>
</tr>
<tr class="row-even"><td rowspan="3">CL_MEM_ALLOC_HOST_PTR,
CL_MEM_USE_HOST_PTR
(clCreateBuffer when VM isenabled)</td>
<td>DiscreteGPU</td>
<td rowspan="3">Pinned hostmemory shared byall devices incontext (unlessonly device incontext is CPU;then, hostmemory)</td>
<td rowspan="3">Zero copy</td>
<td rowspan="3">Use Location directly(same memory areais used on eachmap).</td>
</tr>
<tr class="row-odd"><td>APU</td>
</tr>
<tr class="row-even"><td>CPU</td>
</tr>
<tr class="row-odd"><td rowspan="3">CL_MEM_ALLOC_HOST_PTR,
CL_MEM_USE_HOST_PTR
(for clCreateImage andclCreateBuffer without VM)</td>
<td>DiscreteGPU</td>
<td>Device memory</td>
<td rowspan="2">copy</td>
<td rowspan="3">Pinned host memory,unless only device incontext is CPU; then,host memory (samememory area is usedon each map)</td>
</tr>
<tr class="row-even"><td>APU</td>
<td>Device-visiblememory</td>
</tr>
<tr class="row-odd"><td>CPU</td>
<td>&#160;</td>
<td>Zerocopy</td>
</tr>
<tr class="row-even"><td rowspan="3">CL_MEM_USE_PERSISTENT_MEM_AMD
(when VM is enabled)</td>
<td>DiscreteGPU</td>
<td>Host-visible devicememory</td>
<td rowspan="3">Zerocopy</td>
<td rowspan="3">Use Location directly(different memoryarea can be used oneach map).</td>
</tr>
<tr class="row-odd"><td>APU</td>
<td>Host-visible devicememory</td>
</tr>
<tr class="row-even"><td>CPU</td>
<td>Host memory</td>
</tr>
<tr class="row-odd"><td>CL_MEM_USE_PERSISTENT_MEM_AMD
(when VM is not enabled)</td>
<td colspan="4">Same as default.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="memory-allocation">
<h4>1.3.3 Memory Allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h4>
<div class="section" id="using-the-cpu">
<h5>1.3.3.1 Using the CPU<a class="headerlink" href="#using-the-cpu" title="Permalink to this headline">¶</a></h5>
<p>Create memory objects with <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code>, and use <code class="docutils literal notranslate"><span class="pre">map/unmap;</span></code> do not use <code class="docutils literal notranslate"><span class="pre">read/write</span></code>. The reason for this is that if the object is created with <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR</span></code> the CPU is running the kernel on the buffer provided by the application (a hack that all vendors use). This results in zero copy between the CPU and the application buffer; the kernel updates the application buffer, and in this case a map/unmap is actually a no-op. Also, when allocating the buffer on the host, ensure that it is created with the correct alignment. For example, a buffer to be used as float4* must be 128-bit aligned.</p>
</div>
<div class="section" id="using-both-cpu-and-gpu-devices-or-using-apu-an-device">
<h5>1.3.3.2 Using Both CPU and GPU Devices, or using APU an Device<a class="headerlink" href="#using-both-cpu-and-gpu-devices-or-using-apu-an-device" title="Permalink to this headline">¶</a></h5>
<p>When creating memory objects, create them with <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_PERSISTENT_MEM_AMD</span></code>. This enables the zero copy feature, as explained in Section 1.3.3.1, “Using the CPU”.</p>
</div>
<div class="section" id="buffers-vs-images">
<h5>1.3.3.3 Buffers vs Images<a class="headerlink" href="#buffers-vs-images" title="Permalink to this headline">¶</a></h5>
<p>Unlike GPUs, CPUs do not contain dedicated hardware (samplers) for accessing images. Instead, image access is emulated in software. Thus, a developer may prefer using buffers instead of images if no sampling operation is needed.</p>
</div>
<div class="section" id="choosing-execution-dimensions">
<h5>1.3.3.4 Choosing Execution Dimensions<a class="headerlink" href="#choosing-execution-dimensions" title="Permalink to this headline">¶</a></h5>
<p>Note the following guidelines.</p>
<blockquote>
<div><ul class="simple">
<li>Make the number of work-groups a multiple of the number of logical CPU cores (device compute units) for maximum use.</li>
<li>When work-groups number exceed the number of CPU cores, the CPU cores execute the work-groups sequentially.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="mapping">
<h4>1.3.4 Mapping<a class="headerlink" href="#mapping" title="Permalink to this headline">¶</a></h4>
<p>The host application can use <code class="docutils literal notranslate"><span class="pre">clEnqueueMapBuffer/clEnqueueMapImage</span></code> to obtain a pointer that can be used to access the memory object data. When finished accessing, <code class="docutils literal notranslate"><span class="pre">clEnqueueUnmapMemObject</span></code> must be used to make the data available to device kernel access. When a memory object is located on a device, the data either can be transferred to, and from, the host, or be accessed directly from the host. Memory objects that are located on the host, or located on the device but accessed directly by the host, are termed zero copy memory objects. The data is never transferred, but is accessed directly by both the host and device. Memory objects that are located on the device and transferred to, and from, the device when mapped and unmapped are termed copy memory objects. The Map Mode column of Table 1.1 specifies the transfer mode used for each kind of memory object, and the Map Location column indicates the kind of memory referenced by the pointer returned by the map operations.</p>
<div class="section" id="zero-copy-memory-objects">
<h5>1.3.4.1 Zero Copy Memory Objects<a class="headerlink" href="#zero-copy-memory-objects" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_PERSISTENT_MEM_AMD</span></code>, <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR,</span></code> and <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> support zero copy memory objects. The first provides device-resident zero copy memory objects, the other two provide host-resident zero copy memory objects.</p>
<p>Zero copy memory objects can be used by an application to optimize data movement. When <code class="docutils literal notranslate"><span class="pre">clEnqueueMapBuffer</span> <span class="pre">/</span> <span class="pre">clEnqueueMapImage</span> <span class="pre">/</span> <span class="pre">clEnqueueUnmapMemObject</span></code> are used, no runtime transfers are performed, and the operations are very fast; however, the runtime can return a different pointer value each time a zero copy memory object is mapped. Note that only images created with <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_PERSISTENT_MEM_AMD</span></code> can be zero copy.</p>
<p>From Southern Island on, devices support zero copy memory objects under Linux; however, only images created with <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_PERSISTENT_MEM_AMD</span></code> can be zero copy.</p>
<p>Zero copy host resident memory objects can boost performance when host memory is accessed by the device in a sparse manner or when a large host memory buffer is shared between multiple devices and the copies are too expensive. When choosing this, the cost of the transfer must be greater than the extra cost of the slower accesses.</p>
<p>Streaming writes by the host to zero copy device resident memory objects are about as fast as the transfer rates, so this can be a good choice when the host does not read the memory object to avoid the host having to make a copy of the data to transfer. Memory objects requiring partial updates between kernel executions can also benefit. If the contents of the memory object must be read by the host, use <code class="docutils literal notranslate"><span class="pre">clEnqueueCopyBuffer</span></code> to transfer the data to a separate <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> buffer.</p>
</div>
<div class="section" id="copy-memory-objects">
<h5>1.3.4.2 Copy Memory Objects<a class="headerlink" href="#copy-memory-objects" title="Permalink to this headline">¶</a></h5>
<p>For memory objects with copy map mode, the memory object location is on the device, and it is transferred to, and from, the host when <code class="docutils literal notranslate"><span class="pre">clEnqueueMapBuffer</span> <span class="pre">/</span> <span class="pre">clEnqueueMapImage</span> <span class="pre">/</span> <span class="pre">clEnqueueUnmapMemObject</span></code> are called. Table 1.1 shows how the <code class="docutils literal notranslate"><span class="pre">map_flags</span></code> argument affects transfers. The runtime transfers only the portion of the memory object requested in the <code class="docutils literal notranslate"><span class="pre">offset</span></code> and <code class="docutils literal notranslate"><span class="pre">cb</span></code> arguments. When accessing only a portion of a memory object, only map that portion for improved performance.</p>
<p><strong>Table 1.1 Transfer policy on clEnqueueMapBuffer / clEnqueueMapImage / clEnqueueUnmapMemObject for Copy Memory Objects</strong></p>
<p><strong>Table 2:</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="35%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">clEnqueueMapBuffer /clEnqueueMapImage map_flags argument</th>
<th class="head">Transfer on clEnqueueMapBuffer /clEnqueueMapImage</th>
<th class="head">Transfer on clEnqueueUnmapMemObject</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CL_MAP_READ</td>
<td>Device to host, if map location is not current.</td>
<td>None.</td>
</tr>
<tr class="row-odd"><td>CL_MAP_WRITE</td>
<td>Device to host, if map location is not current.</td>
<td>Host to device.</td>
</tr>
<tr class="row-even"><td>CL_MAP_READ CL_MAP_WRITE</td>
<td>Device to host if map location is not current.</td>
<td>Host to device.</td>
</tr>
<tr class="row-odd"><td>CL_MAP_WRITE_INVALIDATE_REGION</td>
<td>None.</td>
<td>Host to device.</td>
</tr>
</tbody>
</table>
<p>For default memory objects, the pointer returned by <code class="docutils literal notranslate"><span class="pre">clEnqueueMapBuffer</span> <span class="pre">/</span> <span class="pre">clEnqueueMapImage</span></code> may not be to the same memory area each time because different runtime buffers may be used.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR</span></code> and <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> the same map location is used for all maps; thus, the pointer returned is always in the same memory area. For other copy memory objects, the pointer returned may not always be to the same memory region.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR</span></code> and the <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> cases that use copy map mode, the runtime tracks if the map location contains an up-to-date copy of the memory object contents and avoids doing a transfer from the device when mapping as <code class="docutils literal notranslate"><span class="pre">CL_MAP_READ</span></code>. This determination is based on whether an operation such as <code class="docutils literal notranslate"><span class="pre">clEnqueueWriteBuffer/clEnqueueCopyBuffer</span></code> or a kernel execution has modified the memory object. If a memory object is created with <code class="docutils literal notranslate"><span class="pre">CL_MEM_READ_ONLY</span></code>, then a kernel execution with the memory object as an argument is not considered as modifying the memory object. Default memory objects cannot be tracked because the map location changes between map calls; thus, they are always transferred on the map.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR,</span> <span class="pre">clCreateBuffer/clCreateImage</span></code> pins the host memory passed to the <code class="docutils literal notranslate"><span class="pre">host_ptr</span></code> argument. It is unpinned when the memory object is deleted. To minimize pinning costs, align the memory to 4KiB. This avoids the runtime having to pin/unpin on every map/unmap transfer, but does add to the total amount of pinned memory.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR</span></code>, the host memory passed as the ptr argument of <code class="docutils literal notranslate"><span class="pre">clCreateBuffer/clCreateImage</span></code> is used as the map location. As mentioned earlier, host memory transfers incur considerable cost in pinning/unpinning on every transfer. If used, ensure the memory aligned to the data type size used in the kernels. If host memory that is updated once is required, use <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> with the <code class="docutils literal notranslate"><span class="pre">CL_MEM_COPY_HOST_PTR</span></code> flag instead. If device memory is needed, use <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_PERSISTENT_MEM_AMD</span></code> and <code class="docutils literal notranslate"><span class="pre">clEnqueueWriteBuffer</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">CL_MEM_COPY_HOST_PTR</span></code> is specified with <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> when creating a memory object, the memory is allocated in pinned host memory and initialized with the passed data. For other kinds of memory objects, the deferred allocation means the memory is not yet allocated on a device, so the runtime has to copy the data into a temporary runtime buffer. The memory is allocated on the device when the device first accesses the resource. At that time, any data that must be transferred to the resource is copied. For example, this would apply when a buffer was allocated with the flag <code class="docutils literal notranslate"><span class="pre">CL_MEM_COPY_HOST_PTR</span></code>. Using <code class="docutils literal notranslate"><span class="pre">CL_MEM_COPY_HOST_PTR</span></code> for these buffers is not recommended because of the extra copy. Instead, create the buffer without <code class="docutils literal notranslate"><span class="pre">CL_MEM_COPY_HOST_PTR</span></code>, and initialize with <code class="docutils literal notranslate"><span class="pre">clEnqueueWriteBuffer/clEnqueueWriteImage</span></code>.</p>
<p>When images are transferred, additional costs are involved because the image must be converted to, and from, linear address mode for host access. The runtime does this by executing kernels on the device.</p>
</div>
</div>
<div class="section" id="reading-writing-and-copying">
<h4>1.3.5 Reading, Writing, and Copying<a class="headerlink" href="#reading-writing-and-copying" title="Permalink to this headline">¶</a></h4>
<p>There are numerous OpenCL commands to read, write, and copy buffers and images. The runtime performs transfers depending on the memory kind of the source and destination. When transferring between host memory and device memory the methods described in section Section 1.3.1.1, “Unpinned Host Memory”, are used. <code class="docutils literal notranslate"><span class="pre">Memcpy</span></code> is used to transferring between the various kinds of host memory, this may be slow if reading from device visible host memory, as described in section Section 1.3.1.3, “Device-Visible Host Memory”. Finally, device kernels are used to copy between device memory. For images, device kernels are used to convert to and from the linear address mode when necessary.</p>
</div>
<div class="section" id="command-queue">
<h4>1.3.6 Command Queue<a class="headerlink" href="#command-queue" title="Permalink to this headline">¶</a></h4>
<p>It is best to use non-blocking commands to allow multiple commands to be queued before the command queue is flushed to the GPU. This sends larger batches of commands, which amortizes the cost of preparing and submitting work to the GPU. Use event tracking to specify the dependence between operations. It is recommended to queue operations that do not depend of the results of previous copy and map operations. This can help keep the GPU busy with kernel execution and DMA transfers. Command execution begins as soon as there are commands in the queue for execution.</p>
<p>For Southern Islands and later, devices support at least two hardware compute queues. That allows an application to increase the throughput of small dispatches with two command queues for asynchronous submission and possibly concurrent execution.</p>
<p>An OpenCL queue is assigned to a hardware queue on creation time. The hardware compute queues are selected according to the creation order within an OpenCL context. If the hardware supports K concurrent hardware queues, the Nth created OpenCL queue within a specific OpenCL context will be assigned to the (N mod K) hardware queue. The number of compute queues can be limited by specifying the <code class="docutils literal notranslate"><span class="pre">GPU_NUM_COMPUTE_RINGS</span></code> environment variable.</p>
<p>Devices in the Sea Islands and Volcanic Islands families contain between four and eight ACEs, and are multi-threaded (thereby supporting more hardware queues), so they offer more performance. For example, the AMD Radeon™ R9290X devices, in the VI family contain 8 ACEs and 44 CUs.</p>
<div class="section" id="a-note-on-hardware-queues">
<h5>1.3.6.1 A note on hardware queues<a class="headerlink" href="#a-note-on-hardware-queues" title="Permalink to this headline">¶</a></h5>
<p>A hardware queue can be thought of as a GPU entry point. The GPU can process kernels from several compute queues concurrently. All hardware queues ultimately share the same compute cores. The use of multiple hardware queues is beneficial when launching small kernels that do not fully saturate the GPU. For example, the AMD Radeon™ HD 290X compute device can execute up to 112,640 threads concurrently. The GPU can execute two kernels each spawning 56320 threads (assuming fully occupancy) twice as fast if launched concurrently through two hardware queues than serially through a single hardware queue.</p>
</div>
</div>
</div>
<div class="section" id="opencl-data-transfer-optimization">
<h3>1.4 OpenCL Data Transfer Optimization<a class="headerlink" href="#opencl-data-transfer-optimization" title="Permalink to this headline">¶</a></h3>
<p>The AMD OpenCL implementation offers several optimized paths for data transfer to, and from, the device. The following chapters describe buffer and image paths, as well as how they map to common application scenarios. To find out where the application’s buffers are stored (and understand how the data transfer behaves), use the CodeXL GPU Profiler API Trace View, and look at the tool tips of the <code class="docutils literal notranslate"><span class="pre">clEnqueueMapBuffer</span></code> calls.</p>
<div class="section" id="definitions">
<h4>1.4.1 Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><em>Deferred allocation</em> - The CL runtime attempts to minimize resource consumption by delaying buffer allocation until first use. As a side effect, the first accesses to a buffer may be more expensive than subsequent accesses.</li>
<li><em>Peak interconnect bandwidth</em> - As used in the text below, this is the transfer bandwidth between host and device that is available under optimal conditions at the application level. It is dependent on the type of interconnect, the chipset, and the graphics chip. As an example, a high-performance PC with a PCIe 3.0 16x bus and a GCN architecture (AMD Radeon™ HD 7XXX series) graphics card has a nominal interconnect bandwidth of 16 GB/s.</li>
<li><em>Pinning</em> - When a range of host memory is prepared for transfer to the GPU, its pages are locked into system memory. This operation is called pinning; it can impose a high cost, proportional to the size of the memory range. One of the goals of optimizing data transfer is to use pre-pinned buffers whenever possible. However, if pre-pinned buffers are used excessively, it can reduce the available system memory and result in excessive swapping. Host side zero copy buffers provide easy access to pre- pinned memory.</li>
<li><em>WC</em> - Write Combine is a feature of the CPU write path to a select region of the address space. Multiple adjacent writes are combined into cache lines (for example, 64 bytes) before being sent to the external bus. This path typically provides fast streamed writes, but slower scattered writes. Depending on the chip set, scattered writes across a graphics interconnect can be very slow. Also, some platforms require multi-core CPU writes to saturate the WC path over an interconnect.</li>
<li><em>Uncached accesses</em> - Host memory and I/O regions can be configured as uncached. CPU read accesses are typically very slow; for example: uncached CPU reads of graphics memory over an interconnect.</li>
<li><em>USWC</em> - Host memory from the Uncached Speculative Write Combine heap can be accessed by the GPU without causing CPU cache coherency traffic. Due to the uncached WC access path, CPU streamed writes are fast, while CPU reads are very slow. On APU devices, this memory provides the fastest possible route for CPU writes followed by GPU reads.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="buffers">
<h4>1.4.2 Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h4>
<p>OpenCL buffers currently offer the widest variety of specialized buffer types and optimized paths, as well as slightly higher transfer performance.</p>
<div class="section" id="regular-device-buffers">
<h5>1.4.2.1 Regular Device Buffers<a class="headerlink" href="#regular-device-buffers" title="Permalink to this headline">¶</a></h5>
<p>Buffers allocated using the flags <code class="docutils literal notranslate"><span class="pre">CL_MEM_READ_ONLY,</span> <span class="pre">CL_MEM_WRITE_ONLY</span></code>, or <code class="docutils literal notranslate"><span class="pre">CL_MEM_READ_WRITE</span></code> are placed on the GPU device. These buffers can be accessed by a GPU kernel at very high bandwidths. For example, on a high-end graphics card, the OpenCL kernel read/write performance is significantly higher than 100 GB/s. When device buffers are accessed by the host through any of the OpenCL read/write/copy and map/unmap API calls, the result is an explicit transfer across the hardware interconnect.</p>
</div>
<div class="section" id="zero-copy-buffers">
<h5>1.4.2.2 Zero Copy Buffers<a class="headerlink" href="#zero-copy-buffers" title="Permalink to this headline">¶</a></h5>
<p>If a buffer is of the zero copy type, the runtime tries to leave its content in place, unless the application explicitly triggers a transfer (for example, through <code class="docutils literal notranslate"><span class="pre">clEnqueueCopyBuffer()</span></code>). Depending on its type, a zero copy buffer resides on the host or the device. Independent of its location, it can be accessed directly by the host CPU or a GPU device kernel, at a bandwidth determined by the capabilities of the hardware interconnect.</p>
<p>Calling clEnqueueMapBuffer() and clEnqueueUnmapMemObject() on a zero copy buffer is typically a low-cost operation.</p>
<p>Since not all possible read and write paths perform equally, check the application scenarios below for recommended usage. To assess performance on a given platform, use the BufferBandwidth sample.</p>
<p>If a given platform supports the zero copy feature, the following buffer types are available:</p>
<blockquote>
<div><ul>
<li><p class="first">The CL_MEM_ALLOC_HOST_PTR and CL_MEM_USE_HOST_PTR buffers are:</p>
<blockquote>
<div><ul class="simple">
<li>zero copy buffers that resides on the host.</li>
<li>directly accessible by the host at host memory bandwidth.</li>
<li>directly accessible by the device across the interconnect.</li>
<li>a pre-pinned sources or destinations for CL read, write, and copy commands into device memory at peak interconnect bandwidth.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>Note that buffers created with the flag CL_MEM_ALLOC_HOST_PTR together with CL_MEM_READ_ONLY may reside in uncached write-combined memory. As a result, CPU can have high streamed write bandwidth, but low read and potentially low write scatter bandwidth, due to the uncached WC path.</p>
<blockquote>
<div><ul>
<li><p class="first">The CL_MEM_USE_PERSISTENT_MEM_AMD buffer is</p>
<blockquote>
<div><ul class="simple">
<li>a zero copy buffer that resides on the GPU device.</li>
<li>directly accessible by the GPU device at GPU memory bandwidth.</li>
<li>directly accessible by the host across the interconnect (typically with high streamed write bandwidth, but low read and potentially low write scatter bandwidth, due to the uncached WC path).</li>
<li>copyable to, and from, the device at peak interconnect bandwidth using CL read, write, and copy commands.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>There is a limit on the maximum size per buffer, as well as on the total size of all buffers. This is platform-dependent, limited in size for each buffer, and also for the total size of all buffers of that type (a good working assumption is 64 MB for the per-buffer limit, and 128 MB for the total).</p>
<p><strong>Note:</strong> The <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_PERSISTENT_MEM_AMD</span></code> buffer is very small. It must be used only for cases that can directly benefit by having the application directly update the contents of a resource on the device.</p>
<p>Zero copy buffers work well on APU devices. SDK 2.5 introduced an optimization that is of particular benefit on APUs. The runtime uses USWC memory for buffers allocated as <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span> <span class="pre">|</span> <span class="pre">CL_MEM_READ_ONLY</span></code>. On APU systems, this type of zero copy buffer can be written to by the CPU at very high data rates, then handed over to the GPU at minimal cost for equally high GPU read-data rates over the Radeon memory bus. This path provides the highest data transfer rate for the CPU-to-GPU path. The use of multiple CPU cores may be necessary to achieve peak write performance.</p>
<blockquote>
<div><ol class="arabic simple">
<li>buffer = clCreateBuffer(CL_MEM_ALLOC_HOST_PTR | CL_MEM_READ_ONLY)</li>
<li>address = clMapBuffer( buffer ).</li>
<li>memset (address) or memcpy (address) (if possible, using multiple CPU cores)</li>
<li>clEnqueueUnmapMemObject (buffer)</li>
<li>clEnqueueNDRangeKernel (buffer)</li>
</ol>
</div></blockquote>
<p>As this memory is not cacheable, CPU read operations are very slow. This type of buffer also exists on discrete platforms, but transfer performance typically is limited by PCIe bandwidth.</p>
<p>Zero copy buffers can provide low latency for small transfers, depending on the transfer path. For small buffers, the combined latency of map/CPU memory access/unmap can be smaller than the corresponding DMA latency.</p>
</div>
<div class="section" id="pre-pinned-buffers">
<h5>1.4.2.3 Pre-pinned Buffers<a class="headerlink" href="#pre-pinned-buffers" title="Permalink to this headline">¶</a></h5>
<p>Buffers of type <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span> <span class="pre">or</span> <span class="pre">CL_MEM_USE_HOST_PTR</span></code> are pinned at creation time. These buffers can be used directly as a source or destination for <code class="docutils literal notranslate"><span class="pre">clEnqueueCopyBuffer</span></code> to achieve peak interconnect bandwidth. Mapped buffers also can be used as a source or destination for <code class="docutils literal notranslate"><span class="pre">clEnqueueRead/WriteBuffer</span></code> calls, again achieving peak interconnect bandwidth. Note that using <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR</span></code> permits turning an existing user memory region into pre- pinned memory. However, in order to stay on the fast path, that memory must be aligned to 256 bytes. Buffers of type <code class="docutils literal notranslate"><span class="pre">CL_MEM_USE_HOST_PTR</span></code> remain pre-pinned as long as they are used only for data transfer, but not as kernel arguments. If the buffer is used in a kernel, the runtime creates a cached copy on the device, and subsequent copies are not on the fast path. The same restriction applies to <code class="docutils literal notranslate"><span class="pre">CL_MEM_ALLOC_HOST_PTR</span></code> allocations under Linux.</p>
<dl class="docutils">
<dt>See usage examples described for various options below. The pre-pinned path is supported for the following calls.</dt>
<dd><ul class="first last simple">
<li>clEnqueueRead/WriteBuffer</li>
<li>clEnqueueRead/WriteImage</li>
<li>clEnqueueRead/WriteBufferRect</li>
</ul>
</dd>
</dl>
<p>Offsets into mapped buffer addresses are supported, too.</p>
<p>Note that the CL image calls must use pre-pinned mapped buffers on the host side, and not pre-pinned images.</p>
</div>
<div class="section" id="application-scenarios-and-recommended-opencl-paths">
<h5>1.4.2.4 Application Scenarios and Recommended OpenCL Paths<a class="headerlink" href="#application-scenarios-and-recommended-opencl-paths" title="Permalink to this headline">¶</a></h5>
<p>The following section describes various application scenarios, and the corresponding paths in the OpenCL API that are known to work well on AMD platforms. The various cases are listed, ordered from generic to more specialized.</p>
<p>From an application point of view, two fundamental use cases exist, and they can be linked to the various options, described below.</p>
<blockquote>
<div><ul class="simple">
<li>An application wants to transfer a buffer that was already allocated through <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>. In this case, options 2), 3) and 4) below always consist of a <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> plus a device transfer. Option 1) does not require a <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code>.</li>
<li>If an application is able to let OpenCL allocate the buffer, options 2) and 4) below can be used to avoid the extra <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code>. In the case of option 5), <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> and transfer are identical.</li>
</ul>
</div></blockquote>
<p>Note that the OpenCL runtime uses deferred allocation to maximize memory resources. This means that a complete roundtrip chain, including data transfer and kernel compute, might take one or two iterations to reach peak performance.</p>
<p>A code sample named BufferBandwidth can be used to investigate and benchmark the various transfer options in combination with different buffer types.</p>
<dl class="docutils">
<dt><strong>Option 1</strong> - clEnqueueWriteBuffer() and clEnqueueReadBuffer().</dt>
<dd><p class="first">This option is the easiest to use on the application side.  <em>CL_MEM_USE_HOST_PTR</em>  is an ideal choice if the application wants to transfer a buffer that has already been allocated through <code class="docutils literal notranslate"><span class="pre">malloc(</span> <span class="pre">)</span></code> or <code class="docutils literal notranslate"><span class="pre">mmap(</span> <span class="pre">)</span></code>.
There are two ways to use this option. The first uses clEnqueueRead/WriteBuffer on a pre-pinned, mapped host-side buffer:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>pinnedBuffer = clCreateBuffer ( CL_MEM_ALLOC_HOST_PTR or CL_MEM_USE_HOST_PTR )</li>
<li>deviceBuffer = clCreateBuffer( )</li>
<li>void <a href="#id1"><span class="problematic" id="id2">*</span></a>pinnedMemory = clEnqueueMapBuffer (pinnedBuffer)</li>
<li>clEnqueueRead/WriteBuffer (deviceBuffer, pinnedMemory)</li>
<li>clEnqueueUnmapMemObject (pinnedBuffer, pinnedMemory)</li>
</ol>
</div></blockquote>
<p>The pinning cost is incurred at step c. Step d does not incur any pinning cost. Typically, an application performs steps a, b, c, and e once. It then repeatedly reads or modifies the data in pinnedMemory, followed by step d.</p>
<p class="last">For the second way to use this option, clEnqueueRead/WriteBuffer is used directly on a user memory buffer. The standard clEnqueueRead/Write calls require to pin (lock in memory) memory pages before they can be copied (by the DMA engine). This creates a performance penalty that is proportional to the buffer size. The performance of this path is currently about two-thirds of peak interconnect bandwidth.</p>
</dd>
</dl>
<p><strong>Option 2</strong> - clEnqueueCopyBuffer() on a pre-pinned host buffer (requires pre-pinned buffer support)</p>
<blockquote>
<div><p>This is analogous to Option 1. Performing a CL copy of a pre-pinned buffer to a device buffer (or vice versa) runs at peak interconnect bandwidth.</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>pinnedBuffer = clCreateBuffer( CL_MEM_ALLOC_HOST_PTR or CL_MEM_USE_HOST_PTR )</li>
<li>deviceBuffer = clCreateBuffer() <em>This is followed either by :</em></li>
<li>void <a href="#id3"><span class="problematic" id="id4">*</span></a>memory = clEnqueueMapBuffer ( pinnedBuffer )</li>
<li>Application writes or modifies memory.</li>
<li>clEnqueueUnmapMemObject ( pinnedBuffer, memory )</li>
<li>clEnqueueCopyBuffer ( pinnedBuffer, deviceBuffer ) <em>or by:</em></li>
<li>clEnqueueCopyBuffer ( deviceBuffer, pinnedBuffer )</li>
<li>void <a href="#id5"><span class="problematic" id="id6">*</span></a>memory = clEnqueueMapBuffer ( pinnedBuffer )</li>
<li>Application reads memory.</li>
<li>clEnqueueUnmapMemObject ( pinnedBuffer, memory )</li>
</ol>
</div></blockquote>
<p>Since the pinnedBuffer resides in host memory, the   clMap()   and <code class="docutils literal notranslate"><span class="pre">clUnmap()</span></code> calls do not result in data transfers, and they are of very low latency. Sparse or dense memory operations by the application take place at host memory bandwidth.</p>
</div></blockquote>
<p><strong>Option 3</strong> - clEnqueueMapBuffer() and clEnqueueUnmapMemObject() of a Device Buffer</p>
<blockquote>
<div><p>This is a good choice if the application fills in the data on the fly, or requires a pointer for calls to other library functions (such as <code class="docutils literal notranslate"><span class="pre">fread()</span></code> or <code class="docutils literal notranslate"><span class="pre">fwrite()</span></code> ). An optimized path exists for regular device buffers; this path provides peak interconnect bandwidth at map/unmap time.</p>
<p>For buffers already allocated through <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>, the total transfer cost includes a <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> into the mapped device buffer, in addition to the interconnect transfer. Typically, this is slower than option 1), above.</p>
<p>The transfer sequence is as follows:</p>
<blockquote>
<div><ol class="loweralpha">
<li><p class="first">Data transfer from host to device buffer.</p>
<blockquote>
<div><ol class="arabic simple">
<li>ptr = clEnqueueMapBuffer( .., buf, .., CL_MAP_WRITE, ..) Since the buffer is mapped write-only, no data is transferred from device buffer to host. The map operation is very low cost. A pointer to a pinned host buffer is returned.</li>
<li>The application fills in the host buffer through memset( ptr ), memcpy ( ptr, srcptr ), fread( ptr ), or direct CPU writes. This happens at host memory bandwidth.</li>
<li>clEnqueueUnmapMemObject( .., buf, ptr, .. ) The pre-pinned buffer is transferred to the GPU device, at peak interconnect bandwidth.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Data transfer from device buffer to host.</p>
<blockquote>
<div><p>1. ptr = clEnqueueMapBuffer(.., buf, .., CL_MAP_READ, .. )
This command triggers a transfer from the device to host memory, into a pre-pinned temporary buffer, at peak interconnect bandwidth. A pointer to the pinned memory is returned.
2. The application reads and processes the data, or executes a memcpy( dstptr, ptr ), fwrite (ptr),
or similar function. Since the buffer resides in host memory, this happens at host memory bandwidth.
3. clEnqueueUnmapMemObject( .., buf, ptr, .. )</p>
</div></blockquote>
</li>
</ol>
<blockquote>
<div>Since the buffer was mapped as read-only, no transfer takes place, and the unmap operation is very low cost.</div></blockquote>
</div></blockquote>
</div></blockquote>
<p><strong>Option 4</strong> - Direct host access to a zero copy device buffer (requires zero copy support)</p>
<blockquote>
<div><p>This option allows overlapping of data transfers and GPU compute. It is also useful for sparse write updates under certain constraints.</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><dl class="first docutils">
<dt>A zero copy buffer on the device is created using the following command: buf = clCreateBuffer ( .., CL_MEM_USE_PERSISTENT_MEM_AMD, ..)</dt>
<dd>This buffer can be directly accessed by the host CPU, using the uncached WC path. This can take place at the same time the GPU executes a compute kernel. A common double buffering scheme has the kernel process data from one buffer while the CPU fills a second buffer. See the TransferOverlap code sample.
A zero copy device buffer can also be used to for sparse updates, such as assembling sub-rows of a larger matrix into a smaller, contiguous block for GPU processing. Due to the WC path, it is a good design choice to try to align writes to the cache line size, and to pick the write block size as large as possible.</dd>
</dl>
</li>
<li>Transfer from the host to the device.</li>
</ol>
<blockquote>
<div><p>1.ptr = clEnqueueMapBuffer( .., buf, .., CL_MAP_WRITE, .. )</p>
<blockquote>
<div>This operation is low cost because the zero copy device buffer is directly mapped into the host address space.</div></blockquote>
<dl class="docutils">
<dt>2.The application transfers data via memset( ptr ), memcpy( ptr, srcptr ), or direct CPU writes.</dt>
<dd>The CPU writes directly across the interconnect into the zero copy device buffer. Depending on the chipset, the bandwidth can be of the same order of magnitude as the interconnect bandwidth, although it typically is lower than peak.</dd>
</dl>
<p>3.clEnqueueUnmapMemObject ( .., buf, ptr, .. )</p>
<blockquote>
<div>As with the preceding map, this operation is low cost because the buffer continues to reside on the device.</div></blockquote>
</div></blockquote>
<ol class="loweralpha" start="3">
<li><p class="first">If the buffer content must be read back later, use clEnqueueReadBuffer( .., buf, ..) or clEnqueueCopyBuffer( .., buf, zero copy host buffer, .. )</p>
<p>This bypasses slow host reads through the uncached path.</p>
</li>
</ol>
</div></blockquote>
</div></blockquote>
<p><strong>Option 5</strong> - Direct GPU access to a zero copy host buffer (requires zero copy support)</p>
<blockquote>
<div><p>This option allows direct reads or writes of host memory by the GPU. A GPU kernel can import data from the host without explicit transfer, and write data directly back to host memory. An ideal use is to perform small I/Os straight from the kernel, or to integrate the transfer latency directly into the kernel execution time.</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>The application creates a zero copy host buffer.
buf = clCreateBuffer( .., CL_MEM_ALLOC_HOST_PTR, .. )</li>
<li>Next the application modifies or reads the zero copy host buffer.</li>
</ol>
<blockquote>
<div><ol class="arabic">
<li><p class="first">ptr = clEnqueueMapBuffer( .., buf, .., CL_MAP_READ | CL_MAP_WRITE, .. )
This operation is very low cost because it is a map of a buffer already residing in host memory.</p>
</li>
<li><p class="first">The application modifies the data through <code class="docutils literal notranslate"><span class="pre">memset(</span> <span class="pre">ptr</span> <span class="pre">)</span></code>, <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> (in either direction), sparse or dense CPU reads or writes. Since the application is modifying a host buffer, these operations take place at host memory bandwidth.</p>
</li>
<li><p class="first">clEnqueueUnmapMemObject( .., buf, ptr, .. )</p>
<p>As with the preceding map, this operation is very low cost because the buffer continues to reside in host memory.</p>
</li>
</ol>
</div></blockquote>
<ol class="loweralpha simple" start="3">
<li>The application runs clEnqueueNDRangeKernel(), using buffers of this type as input or output. GPU kernel reads and writes go across the interconnect to host memory, and the data transfer becomes part of the kernel execution.
The achievable bandwidth depends on the platform and chipset, but can be of the same order of magnitude as the peak interconnect bandwidth. For discrete graphics cards, it is important to note that resulting GPU kernel bandwidth is an order of magnitude lower compared to a kernel accessing a regular device buffer located on the device.</li>
<li>Following kernel execution, the application can access data in the host buffer in the same manner as described above.</li>
</ol>
</div></blockquote>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="using-multiple-opencl-devices">
<h3>1.5 Using Multiple OpenCL Devices<a class="headerlink" href="#using-multiple-opencl-devices" title="Permalink to this headline">¶</a></h3>
<p>The AMD OpenCL runtime supports both CPU and GPU devices. This section introduces techniques for appropriately partitioning the workload and balancing it across the devices in the system.</p>
<div class="section" id="cpu-and-gpu-devices">
<h4>1.5.1 CPU and GPU Devices<a class="headerlink" href="#cpu-and-gpu-devices" title="Permalink to this headline">¶</a></h4>
<p>Table 1.1 lists some key performance characteristics of two exemplary CPU and GPU devices: a quad-core AMD Phenom II X4 processor running at 2.8 GHz, and a mid-range AMD Radeon™ HD 7770 GPU running at 1 GHz. The “best” device in each characteristic is highlighted, and the ratio of the best/other device is shown in the final column.</p>
<p>The GPU excels at high-throughput: the peak execution rate (measured in FLOPS) is 7X higher than the CPU, and the memory bandwidth is 2.5X higher than the CPU. The GPU also consumes approximately 65% the power of the CPU; thus, for this comparison, the power efficiency in flops/watt is 10X higher. While power efficiency can vary significantly with different devices, GPUs generally provide greater power efficiency (flops/watt) than CPUs because they optimize for throughput and eliminate hardware designed to hide latency.</p>
<blockquote>
<div><strong>Table 1.1 CPU and GPU Performance Characteristics</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="21%" />
<col width="23%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">CPU</th>
<th class="head">GPU</th>
<th class="head">Winner Ratio</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Example Device</td>
<td>AMD Phenom™ II X4</td>
<td>AMD Radeon™ HD 7770</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Core Frequency</td>
<td>2800 MHz</td>
<td>1 GHz</td>
<td>3 X</td>
</tr>
<tr class="row-even"><td>Compute Units</td>
<td>4</td>
<td>10</td>
<td>2.5 X</td>
</tr>
<tr class="row-odd"><td>Approx. Power1</td>
<td>95 W</td>
<td>80 W</td>
<td>1.2 X</td>
</tr>
<tr class="row-even"><td>Approx. Power/Compute Unit</td>
<td>19 W</td>
<td>8 W</td>
<td>2.4 X</td>
</tr>
<tr class="row-odd"><td>Peak Single-Precision</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Billion Floating-Point Ops/Sec</td>
<td>90</td>
<td>1280</td>
<td>14 X</td>
</tr>
<tr class="row-odd"><td>Approx GFLOPS/Watt</td>
<td>0.9</td>
<td>16</td>
<td>18 X</td>
</tr>
<tr class="row-even"><td>Max In-flight HW Threads</td>
<td>4</td>
<td>25600</td>
<td>6400 X</td>
</tr>
<tr class="row-odd"><td>Simultaneous Executing Threads</td>
<td>4</td>
<td>640</td>
<td>160 X</td>
</tr>
<tr class="row-even"><td>Memory Bandwidth</td>
<td>26 GB/s</td>
<td>72 GB/s</td>
<td>2.8 X</td>
</tr>
<tr class="row-odd"><td>Int Add latency</td>
<td>0.4 ns</td>
<td>4 ns</td>
<td>10 X</td>
</tr>
<tr class="row-even"><td>FP Add Latency</td>
<td>1.4 ns</td>
<td>4 ns</td>
<td>2.9 X</td>
</tr>
<tr class="row-odd"><td>Approx DRAM Latency</td>
<td>50 ns</td>
<td>270 ns</td>
<td>5.4 X</td>
</tr>
<tr class="row-even"><td>L2+L3 (GPU only L2) cache capacity</td>
<td>8192 KB</td>
<td>128 kB</td>
<td>64 X</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Approx Kernel Launch Latency</td>
<td>25 μs</td>
<td>50 μs</td>
<td>2 X</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>For the power specifications of the AMD Phenom™ II x4, see <a class="reference external" href="http://www.amd.com/us/products/desktop/processors/phenom-ii/Pages/phenom-ii-model-number-comparison.aspx">http://www.amd.com/us/products/desktop/processors/phenom-ii/Pages/phenom-ii-model-number-comparison.aspx</a> .</td></tr>
</tbody>
</table>
<p>Table 4.5 provides a comparison of the CPU and GPU performance charac- teristics in an AMD A8-4555M “Trinity” APU (19 W, 21 GB/s memory bandwidth).</p>
<blockquote>
<div><strong>Table 1.2 CPU and GPU Performance Characteristics on APU</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="14%" />
<col width="15%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">CPU</th>
<th class="head">GPU</th>
<th class="head">Winner Ratio</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Core Frequency</td>
<td>2400 MHz</td>
<td>424 MHz</td>
<td>5.7 x</td>
</tr>
<tr class="row-odd"><td>Compute Units</td>
<td>4</td>
<td>6</td>
<td>1.5 x</td>
</tr>
<tr class="row-even"><td>Peak Single Precision Floating-Point Ops/s</td>
<td>77 GFLOPs</td>
<td>326 GFLOPs</td>
<td>4.2 x</td>
</tr>
<tr class="row-odd"><td>Approx. GFLOPs/W</td>
<td>4.0</td>
<td>17.1</td>
<td>4.2 x</td>
</tr>
<tr class="row-even"><td>Max Inflight HW Threads</td>
<td>4</td>
<td>15872</td>
<td>3968 x</td>
</tr>
<tr class="row-odd"><td>Simultaneous Executing Threads</td>
<td>4</td>
<td>96</td>
<td>24 x</td>
</tr>
<tr class="row-even"><td>Int Add Latency</td>
<td>0.4 ns</td>
<td>18.9 ns</td>
<td>45.3 x</td>
</tr>
<tr class="row-odd"><td>FP Add Latency</td>
<td>1.7 ns</td>
<td>9.4 ns</td>
<td>5.7 x</td>
</tr>
<tr class="row-even"><td>Approx. DRAM Latency</td>
<td>50 ns</td>
<td>270 ns</td>
<td>5.4 x</td>
</tr>
<tr class="row-odd"><td>L2 + L3 Cache Capacity</td>
<td>4192 kB</td>
<td>256 kB</td>
<td>16.4 x</td>
</tr>
</tbody>
</table>
<p>Conversely, CPUs excel at latency-sensitive tasks. For example, an integer add is 10X faster on the CPU than on the GPU. This is a product of both the CPUs higher clock rate (2800 MHz vs 1000 MHz for this comparison), as well as the operation latency; the CPU is optimized to perform an integer add in just one cycle, while the GPU requires four cycles. The CPU also has a latency-optimized path to DRAM, while the GPU optimizes for bandwidth and relies on many in- flight threads to hide the latency. The AMD Radeon™ HD 7770 GPU, for example, supports more than 25,000 in-flight work-items and can switch to a new wavefront (containing up to 64 work-items) in a single cycle. The CPU supports only four hardware threads, and thread-switching requires saving and restoring the CPU registers from memory. The GPU requires many active threads to both keep the execution resources busy, as well as provide enough threads to hide the long latency of cache misses.</p>
<p>Each GPU wavefront has its own register state, which enables the fast single- cycle switching between threads. Also, GPUs can be very efficient at gather/scatter operations: each work-item can load from any arbitrary address, and the registers are completely decoupled from the other threads. This is substantially more flexible and higher-performing than a classic Vector ALU-style architecture (such as SSE on the CPU), which typically requires that data be accessed from contiguous and aligned memory locations. SSE supports instructions that write parts of a register (for example, MOVLPS and MOVHPS, which write the upper and lower halves, respectively, of an SSE register), but these instructions generate additional microarchitecture dependencies and frequently require additional pack instructions to format the data correctly.</p>
<p>In contrast, each GPU thread shares the same program counter with 63 other threads in a wavefront. Divergent control-flow on a GPU can be quite expensive and can lead to significant under-utilization of the GPU device. When control flow substantially narrows the number of valid work-items in a wave-front, it can be faster to use the CPU device.</p>
<p>CPUs also tend to provide significantly more on-chip cache than GPUs. In this example, the CPU device contains 512 kB L2 cache/core plus a 6 MB L3 cache that is shared among all cores, for a total of 8 MB of cache. In contrast, the GPU device contains only 128 kB cache shared by the five compute units. The larger CPU cache serves both to reduce the average memory latency and to reduce memory bandwidth in cases where data can be re-used from the caches.</p>
<p>Finally, note the approximate 2X difference in kernel launch latency. The GPU launch time includes both the latency through the software stack, as well as the time to transfer the compiled kernel and associated arguments across the PCI- express bus to the discrete GPU. Notably, the launch time does not include the time to compile the kernel. The CPU can be the device-of-choice for small, quick- running problems when the overhead to launch the work on the GPU outweighs the potential speedup. Often, the work size is data-dependent, and the choice of device can be data-dependent as well. For example, an image-processing algorithm may run faster on the GPU if the images are large, but faster on the CPU when the images are small.</p>
<p>The differences in performance characteristics present interesting optimization opportunities. Workloads that are large and data parallel can run orders of magnitude faster on the GPU, and at higher power efficiency. Serial or small parallel workloads (too small to efficiently use the GPU resources) often run significantly faster on the CPU devices. In some cases, the same algorithm can exhibit both types of workload. A simple example is a reduction operation such as a sum of all the elements in a large array. The beginning phases of the operation can be performed in parallel and run much faster on the GPU. The end of the operation requires summing together the partial sums that were computed in parallel; eventually, the width becomes small enough so that the overhead to parallelize outweighs the computation cost, and it makes sense to perform a serial add. For these serial operations, the CPU can be significantly faster than the GPU.</p>
</div>
<div class="section" id="when-to-use-multiple-devices">
<h4>1.5.2 When to Use Multiple Devices<a class="headerlink" href="#when-to-use-multiple-devices" title="Permalink to this headline">¶</a></h4>
<p>One of the features of GPU computing is that some algorithms can run substantially faster and at better energy efficiency compared to a CPU device. Also, once an algorithm has been coded in the data-parallel task style for OpenCL, the same code typically can scale to run on GPUs with increasing compute capability (that is more compute units) or even multiple GPUs (with a little more work).</p>
<p>For some algorithms, the advantages of the GPU (high computation throughput, latency hiding) are offset by the advantages of the CPU (low latency, caches, fast launch time), so that the performance on either devices is similar. This case is more common for mid-range GPUs and when running more mainstream algorithms. If the CPU and the GPU deliver similar performance, the user can get the benefit of either improved power efficiency (by running on the GPU) or higher peak performance (use both devices).</p>
<p>Usually, when the data size is small, it is faster to use the CPU because the start- up time is quicker than on the GPU due to a smaller driver overhead and avoiding the need to copy buffers from the host to the device.</p>
</div>
<div class="section" id="partitioning-work-for-multiple-devices">
<h4>1.5.3 Partitioning Work for Multiple Devices<a class="headerlink" href="#partitioning-work-for-multiple-devices" title="Permalink to this headline">¶</a></h4>
<p>By design, each OpenCL command queue can only schedule work on a single OpenCL device. Thus, using multiple devices requires the developer to create a separate queue for each device, then partition the work between the available command queues.</p>
<p>A simple scheme for partitioning work between devices would be to statically determine the relative performance of each device, partition the work so that faster devices received more work, launch all the kernels, and then wait for them to complete. In practice, however, this rarely yields optimal performance. The relative performance of devices can be difficult to determine, in particular for kernels whose performance depends on the data input. Further, the device performance can be affected by dynamic frequency scaling, OS thread scheduling decisions, or contention for shared resources, such as shared caches and DRAM bandwidth. Simple static partitioning algorithms which “guess wrong” at the beginning can result in significantly lower performance, since some devices finish and become idle while the whole system waits for the single, unexpectedly slow device.</p>
<p>For these reasons, a dynamic scheduling algorithm is recommended. In this approach, the workload is partitioned into smaller parts that are periodically scheduled onto the hardware. As each device completes a part of the workload, it requests a new part to execute from the pool of remaining work. Faster devices, or devices which work on easier parts of the workload, request new input faster, resulting in a natural workload balancing across the system. The approach creates some additional scheduling and kernel submission overhead, but dynamic scheduling generally helps avoid the performance cliff from a single bad initial scheduling decision, as well as higher performance in real-world system environments (since it can adapt to system conditions as the algorithm runs).</p>
<p>Multi-core runtimes, such as Cilk, have already introduced dynamic scheduling algorithms for multi-core CPUs, and it is natural to consider extending these scheduling algorithms to GPUs as well as CPUs. A GPU introduces several new aspects to the scheduling process:</p>
<ul class="simple">
<li><strong>Heterogeneous Compute Devices</strong>
Most existing multi-core schedulers target only homogenous computing devices. When scheduling across both CPU and GPU devices, the scheduler must be aware that the devices can have very different performance characteristics (10X or more) for some algorithms. To some extent, dynamic scheduling is already designed to deal with heterogeneous workloads (based on data input the same algorithm can have very different performance, even when run on the same device), but a system with heterogeneous devices makes these cases more common and more extreme. Here are some suggestions for these situations.</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>The scheduler should support sending different workload sizes to different devices. GPUs typically prefer larger grain sizes, and higher- performing GPUs prefer still larger grain sizes.</li>
<li>The scheduler should be conservative about allocating work until after it has examined how the work is being executed. In particular, it is important to avoid the performance cliff that occurs when a slow device is assigned an important long-running task. One technique is to use small grain allocations at the beginning of the algorithm, then switch to larger grain allocations when the device characteristics are well-known.</li>
<li>As a special case of the above rule, when the devices are substantially different in performance (perhaps 10X), load-balancing has only a small potential performance upside, and the overhead of scheduling the load probably eliminates the advantage. In the case where one device is far faster than everything else in the system, use only the fast device.</li>
<li>The scheduler must balance small-grain-size (which increase the adaptiveness of the schedule and can efficiently use heterogeneous devices) with larger grain sizes (which reduce scheduling overhead). Note that the grain size must be large enough to efficiently use the GPU.</li>
</ul>
</div></blockquote>
<ul>
<li><p class="first"><strong>Asynchronous Launch</strong></p>
<p>OpenCL devices are designed to be scheduled asynchronously from a command-queue. The host application can enqueue multiple kernels, flush the kernels so they begin executing on the device, then use the host core for other work. The AMD OpenCL implementation uses a separate thread for each command-queue, so work can be transparently scheduled to the GPU in the background.</p>
<p>Avoid starving the high-performance GPU devices. This can occur if the physical CPU core, which must re-fill the device queue, is itself being used as a device. A simple approach to this problem is to dedicate a physical CPU core for scheduling chores. The device fission extension (see the Extensions appendix in the AMD OpenCL User Guide) can be used to reserve a core for scheduling. For example, on a quad-core device, device fission can be used to create an OpenCL device with only three cores.</p>
<p>Another approach is to schedule enough work to the device so that it can tolerate latency in additional scheduling. Here, the scheduler maintains a watermark of uncompleted work that has been sent to the device, and refills the queue when it drops below the watermark. This effectively increase the grain size, but can be very effective at reducing or eliminating device starvation. Developers cannot directly query the list of commands in the OpenCL command queues; however, it is possible to pass an event to each clEnqueue call that can be queried, in order to determine the execution status (in particular the command completion time); developers also can maintain their own queue of outstanding requests.</p>
<p>For many algorithms, this technique can be effective enough at hiding latency so that a core does not need to be reserved for scheduling. In particular, algorithms where the work-load is largely known up-front often work well with a deep queue and watermark. Algorithms in which work is dynamically created may require a dedicated thread to provide low-latency scheduling.</p>
</li>
<li><p class="first"><strong>Data Location</strong></p>
<p>Discrete GPUs use dedicated high-bandwidth memory that exists in a separate address space. Moving data between the device address space and the host requires time-consuming transfers over a relatively slow PCI- Express bus. Schedulers should be aware of this cost and, for example, attempt to schedule work that consumes the result on the same device producing it.</p>
<p>CPU and GPU devices share the same memory bandwidth, which results in additional interactions of kernel executions.</p>
</li>
</ul>
</div>
<div class="section" id="synchronization-caveats">
<h4>1.5.4   Synchronization Caveats<a class="headerlink" href="#synchronization-caveats" title="Permalink to this headline">¶</a></h4>
<p>Enqueuing several commands before flushing can enable the host CPU to batch together the command submission, which can reduce launch overhead.</p>
<p>Command-queues that are configured to execute in-order are guaranteed to complete execution of each command before the next command begins. This synchronization guarantee can often be leveraged to avoid explicit clWaitForEvents() calls between command submissions. Using clWaitForEvents() requires intervention by the host CPU and additional</p>
<p>synchronization cost between the host and the GPU; by leveraging the in-order queue property, back-to-back kernel executions can be efficiently handled directly on the GPU hardware.</p>
<p>AMD Southern Islands GPUs can execute multiple kernels simultaneously when there are no dependencies.</p>
<p>The AMD OpenCL implementation spawns a new thread to manage each command queue. Thus, the OpenCL host code is free to manage multiple devices from a single host thread. Note that clFinish is a blocking operation; the thread that calls clFinish blocks until all commands in the specified command-queue have been processed and completed. If the host thread is managing multiple devices, it is important to call clFlush for each command- queue before calling clFinish, so that the commands are flushed and execute in parallel on the devices. Otherwise, the first call to clFinish blocks, the commands on the other devices are not flushed, and the devices appear to execute serially rather than in parallel.</p>
<p>For low-latency CPU response, it can be more efficient to use a dedicated spin loop and not call clFinish() Calling clFinish() indicates that the application wants to wait for the GPU, putting the thread to sleep. For low latency, the application should use <code class="docutils literal notranslate"><span class="pre">clFlush()</span></code>, followed by a loop to wait for the event to complete. This is also true for blocking maps. The application should use non- blocking maps followed by a loop waiting on the event. The following provides sample code for this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if (sleep)

{
// this puts host thread to sleep, useful if power is a consideration or overhead is not a concern

``clFinish`` (cmd_queue_);

}

else

{

// this keeps the host thread awake, useful if latency is a concern

clFlush(cmd_queue_);

error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS,
sizeof(cl_int), &amp;eventStatus, NULL);

while (eventStatus &gt; 0)

{

error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS,
sizeof(cl_int), &amp;eventStatus, NULL);

to find

Sleep(0);      // be nice to other threads, allow scheduler

other work if possible

// Choose your favorite way to yield, SwitchToThread()
for example,
in place of Sleep(0)

}

}
</pre></div>
</div>
</div>
<div class="section" id="gpu-and-cpu-kernels">
<h4>1.5.5   GPU and CPU Kernels<a class="headerlink" href="#gpu-and-cpu-kernels" title="Permalink to this headline">¶</a></h4>
<p>While OpenCL provides functional portability so that the same kernel can run on any device, peak performance for each device is typically obtained by tuning the OpenCL kernel for the target device.</p>
<p>Code optimized for the Tahiti device (the AMD Radeon™ HD 7970 GPU) typically runs well across other members of the Southern Islands family.</p>
<p>CPUs and GPUs have very different performance characteristics, and some of these impact how one writes an optimal kernel. Notable differences include:</p>
<blockquote>
<div><ul class="simple">
<li>The Vector ALU floating point resources in a CPU (SSE/AVX) require the use of vectorized types (such as float4) to enable packed SSE code generation and extract good performance from the Vector ALU hardware. The GPU Vector ALU hardware is more flexible and can efficiently use the floating- point hardware; however, code that can use float4 often generates hi-quality code for both the CPU and the AMD GPUs.</li>
<li>The AMD OpenCL CPU implementation runs work-items from the same work-group back-to-back on the same physical CPU core. For optimally coalesced memory patterns, a common access pattern for GPU-optimized algorithms is for work-items in the same wavefront to access memory locations from the same cache line. On a GPU, these work-items execute in parallel and generate a coalesced access pattern. On a CPU, the first work- item runs to completion (or until hitting a barrier) before switching to the next. Generally, if the working set for the data used by a work-group fits in the CPU caches, this access pattern can work efficiently: the first work-item brings a line into the cache hierarchy, which the other work-items later hit. For large working-sets that exceed the capacity of the cache hierarchy, this access pattern does not work as efficiently; each work-item refetches cache lines that were already brought in by earlier work-items but were evicted from the cache hierarchy before being used. Note that AMD CPUs typically provide 512 kB to 2 MB of L2+L3 cache for each compute unit.</li>
<li>CPUs do not contain any hardware resources specifically designed to accelerate local memory accesses. On a CPU, local memory is mapped to the same cacheable DRAM used for global memory, and there is no performance benefit from using the <code class="docutils literal notranslate"><span class="pre">__local</span></code> qualifier. The additional memory operations to write to LDS, and the associated barrier operations can reduce performance. One notable exception is when local memory is used to pack values to avoid non-coalesced memory patterns.</li>
<li>CPU devices only support a small number of hardware threads, typically two to eight. Small numbers of active work-group sizes reduce the CPU switching overhead, although for larger kernels this is a second-order effect.</li>
</ul>
</div></blockquote>
<p>For a balanced solution that runs reasonably well on both devices, developers are encouraged to write the algorithm using float4 vectorization. The GPU is more sensitive to algorithm tuning; it also has higher peak performance potential. Thus, one strategy is to target optimizations to the GPU and aim for reasonable performance on the CPU. For peak performance on all devices, developers can choose to use conditional compilation for key code loops in the kernel, or in some cases even provide two separate kernels. Even with device-specific kernel optimizations, the surrounding host code for allocating memory, launching kernels, and interfacing with the rest of the program generally only needs to be written once.</p>
<p>Another approach is to leverage a CPU-targeted routine written in a standard high-level language, such as C++. In some cases, this code path may already exist for platforms that do not support an OpenCL device. The program uses OpenCL for GPU devices, and the standard routine for CPU devices. Load- balancing between devices can still leverage the techniques described in Section 1.5.3, “Partitioning Work for Multiple Devices,”.</p>
</div>
<div class="section" id="contexts-and-devices">
<h4>1.5.6 Contexts and Devices<a class="headerlink" href="#contexts-and-devices" title="Permalink to this headline">¶</a></h4>
<p>The AMD OpenCL program creates at least one context, and each context can contain multiple devices. Thus, developers must choose whether to place all devices in the same context or create a new context for each device. Generally, it is easier to extend a context to support additional devices rather than duplicating the context for each device: buffers are allocated at the context level (and automatically across all devices), programs are associated with the context, and kernel compilation (via <code class="docutils literal notranslate"><span class="pre">clBuildProgram</span></code>) can easily be done for all devices in a context. However, with current OpenCL implementations, creating a separate context for each device provides more flexibility, especially in that buffer allocations can be targeted to occur on specific devices. Generally, placing the devices in the same context is the preferred solution.</p>
</div>
</div>
</div>
<div class="section" id="chapter-2-opencl-performance-and-optimiza-tion-for-gcn-devices">
<h2>Chapter 2 OpenCL Performance and Optimiza- tion for GCN Devices<a class="headerlink" href="#chapter-2-opencl-performance-and-optimiza-tion-for-gcn-devices" title="Permalink to this headline">¶</a></h2>
<p>This chapter discusses performance and optimization when programming for AMD GPU compute devices that are based on the Graphic Core Next (GCN) architecture (such as the Southern Islands, Sea Islands, and Volcanic Islands devices and Kabini APUs), as well as CPUs and multiple devices. Details specific to the Evergreen and Northern Islands families of GPUs are provided in Chapter 3, “OpenCL Performance and Optimization for Evergreen and Northern Islands Devices.”</p>
<div class="section" id="global-memory-optimization">
<h3>2.1 Global Memory Optimization<a class="headerlink" href="#global-memory-optimization" title="Permalink to this headline">¶</a></h3>
<p>The GPU consists of multiple compute units. Each compute unit (CU) contains local (on-chip) memory, L1 cache, registers, and four SIMDs. Each SIMD consists of 16 processing element (PEs). Individual work-items execute on a single processing element; one or more work-groups execute on a single compute unit. On a GPU, hardware schedules groups of work-items, called wavefronts, onto compute units; thus, work-items within a wavefront execute in lock-step; the same instruction is executed on different data.</p>
<p>Each compute unit contains 64 kB local memory, 16 kB of read/write L1 cache, four vector units, and one scalar unit. The maximum local memory allocation is 32 kB per work-group. Each vector unit contains 512 scalar registers (SGPRs) for handling branching, constants, and other data constant across a wavefront. Vector units also contain 256 vector registers (VGPRs). VGPRs actually are scalar registers, but they are replicated across the whole wavefront. Vector units contain 16 processing elements (PEs). Each PE is scalar.</p>
<p>Since the L1 cache is 16 kB per compute unit, the total L1 cache size is 16 kB * (# of compute units). For the AMD Radeon™ HD 7970, this means a total of 512 kB L1 cache. L1 bandwidth can be computed as:
L1 peak bandwidth = Compute Units * (4 threads/clock) * (128 bits per thread) * (1 byte / 8 bits) * Engine Clock
For the AMD Radeon™ HD 7970, this is ~1.9 TB/s.</p>
<p>If two memory access requests are directed to the same controller, the hardware serializes the access. This is called a channel conflict. Similarly, if two memory access requests go to the same memory bank, hardware serializes the access. This is called a bank conflict. From a developer’s point of view, there is not much difference between channel and bank conflicts. Often, a large power of two stride results in a channel conflict. The size of the power of two stride that causes a specific type of conflict depends on the chip. A stride that results in a channel conflict on a machine with eight channels might result in a bank conflict on a machine with four.</p>
<p>In this document, the term bank conflict is used to refer to either kind of conflict.</p>
<p>Typically, reads and writes go through L1 and L2. As reads and writes go through L2 in addition to through L1, there is no complete path or fast path to worry about unlike in pre-GCN devices.</p>
<div class="section" id="channel-conflicts">
<h4>2.1.1 Channel Conflicts<a class="headerlink" href="#channel-conflicts" title="Permalink to this headline">¶</a></h4>
<p>The important concept is memory stride: the increment in memory address, measured in elements, between successive elements fetched or stored by consecutive work-items in a kernel. Many important kernels do not exclusively use simple stride one accessing patterns; instead, they feature large non-unit strides. For instance, many codes perform similar operations on each dimension of a two- or three-dimensional array. Performing computations on the low dimension can often be done with unit stride, but the strides of the computations in the other dimensions are typically large values. This can result in significantly degraded performance when the codes are ported unchanged to GPU systems. A CPU with caches presents the same problem, large power-of-two strides force data into only a few cache lines.</p>
<p>One solution is to rewrite the code to employ array transpositions between the kernels. This allows all computations to be done at unit stride. Ensure that the time required for the transposition is relatively small compared to the time to perform the kernel calculation.</p>
<p>For many kernels, the reduction in performance is sufficiently large that it is worthwhile to try to understand and solve this problem.</p>
<p>In GPU programming, it is best to have adjacent work-items read or write adjacent memory addresses. This is one way to avoid channel conflicts.</p>
<p>When the application has complete control of the access pattern and address generation, the developer must arrange the data structures to minimize bank conflicts. Accesses that differ in the lower bits can run in parallel; those that differ only in the upper bits can be serialized.</p>
<p>In this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">ptr</span><span class="o">=</span><span class="n">base</span><span class="p">;</span> <span class="n">ptr</span><span class="o">&lt;</span><span class="nb">max</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">+=</span> <span class="mi">16</span><span class="n">KB</span><span class="p">)</span>
<span class="n">R0</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</pre></div>
</div>
<p>where the lower bits are all the same, the memory requests all access the same bank on the same channel and are processed serially.</p>
<p>This is a low-performance pattern to be avoided. When the stride is a power of 2 (and larger than the channel interleave), the loop above only accesses one channel of memory.</p>
<p>The hardware byte address bits are :</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="39%" />
<col width="19%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>31:x</td>
<td>bank</td>
<td>channel</td>
<td>7:0 address</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>On all AMD Radeon™ HD 79XX-series GPUs, there are 12 channels. A crossbar distributes the load to the appropriate memory channel. Each memory channel has a read/write global L2 cache, with 64 kB per channel. The cache line size is 64 bytes.</li>
</ul>
<p>Because 12 channels are not a part of the power of two memory and bank channel addressing, this is not straightforward for the AMD Radeon™ HD 79XX series. The memory channels are grouped in four quadrants, each which consisting of three channels. Bits 8, 9, and 10 of the address select a “virtual pipe.” The top two bits of this pipe select the quadrant; then, the channel within the quadrant is selected using the low bit of the pipe and the row and bank address modulo three, according to the following conditional equation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">If</span> <span class="p">(({</span> <span class="n">row</span><span class="p">,</span> <span class="n">bank</span><span class="p">}</span> <span class="o">%</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">channel_within_quadrant</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">else</span>
<span class="n">channel_within_quadrant</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Figure 2.1 illustrates the memory channel mapping.</p>
<img alt="../_images/2.1.png" src="../_images/2.1.png" />
<p><strong>Figure 2.1 Channel Remapping/Interleaving</strong></p>
<p>Note that an increase of the address by 2048 results in a 1/3 probability the same channel is hit; increasing the address by 256 results in a 1/6 probability the same channel is hit, etc.</p>
<p>On AMD Radeon™ HD 78XX GPUs, the channel selection are bits 10:8 of the byte address. For the AMD Radeon™ HD 77XX, the channel selection are bits 9:8 of the byte address. This means a linear burst switches channels every 256 bytes. Since the wavefront size is 64, channel conflicts are avoided if each work- item in a wave reads a different address from a 64-word region. All AMD Radeon™ HD 7XXX series GPUs have the same layout: channel ends at bit 8, and the memory bank is to the left of the channel.</p>
<p>For AMD Radeon HD 77XX and 78XX GPUs, a burst of 2 kB (# of channels *
256 bytes) cycles through all the channels.</p>
<p>For AMD Radeon™ HD 77XX and 78XX GPUs, when calculating an address as y*width+x, but reading a burst on a column (incrementing y), only one memory channel of the system is used, since the width is likely a multiple of 256 words = 2048 bytes. If the width is an odd multiple of 256B, then it cycles through all channels.</p>
<p>If every work-item in a work-group references consecutive memory addresses and the address of work-item 0 is aligned to 256 bytes and each work-item fetches 32 bits, the entire wavefront accesses one channel. Although this seems slow, it actually is a fast pattern because it is necessary to consider the memory access over the entire device, not just a single wavefront.</p>
<p>One or more work-groups execute on each compute unit. On the AMD Radeon™ HD 7000-series GPUs, work-groups are dispatched in a linear order, with x changing most rapidly.
For a single dimension, this is:</p>
<blockquote>
<div><strong>DispatchOrder = get_group_id(0)</strong></div></blockquote>
<p>For two dimensions, this is:</p>
<blockquote>
<div><strong>DispatchOrder = get_group_id(0) + get_group_id(1) * get_num_groups(0)</strong></div></blockquote>
<p>This is row-major-ordering of the blocks in the index space. Once all compute units are in use, additional work-groups are assigned to compute units as needed. Work-groups retire in order, so active work-groups are contiguous.</p>
<p>At any time, each compute unit is executing an instruction from a single wavefront. In memory intensive kernels, it is likely that the instruction is a
memory access. Since there are 12 channels on the AMD Radeon™ HD 7970
GPU, at most 12 of the compute units can issue a memory access operation in one cycle. It is most efficient if the accesses from 12 wavefronts go to different channels. One way to achieve this is for each wavefront to access consecutive groups of 256 = 64 * 4 bytes. Note, as shown in Figure 2.1, fetching 256 * 12 bytes in a row does not always cycle through all channels.</p>
<p>An inefficient access pattern is if each wavefront accesses all the channels. This is likely to happen if consecutive work-items access data that has a large power of two strides.</p>
<p>In the next example of a kernel for copying, the input and output buffers are interpreted as though they were 2D, and the work-group size is organized as 2D.</p>
<p>The kernel code is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define WIDTH 1024</span>
<span class="c1">#define DATA_TYPE float</span>
<span class="c1">#define A(y , x ) A[ (y) * WIDTH + (x ) ]</span>
<span class="c1">#define C(y , x ) C[ (y) * WIDTH+(x ) ]</span>
<span class="n">kernel</span> <span class="n">void</span> <span class="n">copy_float</span> <span class="p">(</span>  <span class="k">global</span> <span class="n">const</span>
<span class="n">DATA_TYPE</span> <span class="o">*</span> <span class="n">A</span><span class="p">,</span>
  <span class="k">global</span> <span class="n">DATA_TYPE</span><span class="o">*</span> <span class="n">C</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">idy</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">C</span><span class="p">(</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span> <span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By changing the width, the data type and the work-group dimensions, we get a set of kernels out of this code.</p>
<p>Given a 64x1 work-group size, each work-item reads a consecutive 32-bit address. Given a 1x64 work-group size, each work-item reads a value separated by the width in a power of two bytes.</p>
<p>To avoid power of two strides:</p>
<ul class="simple">
<li>Add an extra column to the data matrix.</li>
<li>Change the work-group size so that it is not a power of 21.</li>
<li>It is best to use a width that causes a rotation through all of the memory channels, instead of using the same one repeatedly.</li>
<li>Change the kernel to access the matrix with a staggered offset.</li>
</ul>
<div class="section" id="staggered-offsets">
<h5>2.1.1.1 Staggered Offsets<a class="headerlink" href="#staggered-offsets" title="Permalink to this headline">¶</a></h5>
<p>Staggered offsets apply a coordinate transformation to the kernel so that the data is processed in a different order. Unlike adding a column, this technique does not use extra space. It is also relatively simple to add to existing code.</p>
<p>Figure 2.2 illustrates the transformation to staggered offsets.</p>
<p><strong>Figure 2.2 Transformation to Staggered Offsets</strong></p>
<img alt="../_images/2.2.png" src="../_images/2.2.png" />
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Generally, it is not a good idea to make the work-group size something other than an integer multiple of the wavefront size, but that usually is less important than avoiding channel conflicts.</td></tr>
</tbody>
</table>
<p>The global ID values reflect the order that the hardware initiates work-groups. The values of get group ID are in ascending launch order.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">global_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The hardware launch order is fixed, but it is possible to change the launch order, as shown in the following example.</p>
<p>Assume a work-group size of k x k, where k is a power of two, and a large 2D matrix of size 2n x 2m in row-major order. If each work-group must process a block in column-order, the launch order does not work out correctly: consecutive work-groups execute down the columns, and the columns are a large power-of- two apart; so, consecutive work-groups access the same channel.</p>
<p>By introducing a transformation, it is possible to stagger the work-groups to avoid channel conflicts. Since we are executing 2D work-groups, each work group is identified by four numbers.</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">get_group_id(0)</span></code> - the x coordinate or the block within the column of the matrix.</li>
<li><code class="docutils literal notranslate"><span class="pre">get_group_id(1)</span></code> - the y coordinate or the block within the row of the matrix.</li>
<li><code class="docutils literal notranslate"><span class="pre">get_global_id(0)</span></code> - the x coordinate or the column of the matrix.</li>
<li><code class="docutils literal notranslate"><span class="pre">get_global_id(1)</span></code> - the y coordinate or the row of the matrix.</li>
</ol>
<p>To transform the code, add the following four lines to the top of the kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">get_group_id_0</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">get_group_id_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">get_global_id_0</span> <span class="o">=</span> <span class="n">get_group_id_0</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">get_global_id_1</span> <span class="o">=</span> <span class="n">get_group_id_1</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, change the global IDs and group IDs to the staggered form. The result is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span> <span class="n">void</span> <span class="n">copy_float</span> <span class="p">(</span>
<span class="n">__global</span> <span class="n">const</span> <span class="n">DATA_TYPE</span> <span class="o">*</span> <span class="n">A</span><span class="p">,</span>
<span class="n">__global</span> <span class="n">DATA_TYPE</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">size_t</span> <span class="n">get_group_id_0</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">size_t</span> <span class="n">get_group_id_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">%</span>
<span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">size_t</span> <span class="n">get_global_id_0</span> <span class="o">=</span> <span class="n">get_group_id_0</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
<span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">size_t</span> <span class="n">get_global_id_1</span> <span class="o">=</span> <span class="n">get_group_id_1</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
<span class="n">get_local_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_global_id_0</span><span class="p">;</span> <span class="o">//</span><span class="n">changed</span> <span class="n">to</span> <span class="n">staggered</span> <span class="n">form</span> <span class="nb">int</span> <span class="n">idy</span> <span class="o">=</span> <span class="n">get_global_id_1</span><span class="p">;</span> <span class="o">//</span><span class="n">changed</span> <span class="n">to</span> <span class="n">staggered</span> <span class="n">form</span>

<span class="n">C</span><span class="p">(</span><span class="n">idy</span> <span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span> <span class="n">idy</span> <span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reads-of-the-same-address">
<h5>2.1.1.2 Reads Of The Same Address<a class="headerlink" href="#reads-of-the-same-address" title="Permalink to this headline">¶</a></h5>
<p>Under certain conditions, one unexpected case of a channel conflict is that reading from the same address is a conflict, even on the FastPath.</p>
<p>This does not happen on the read-only memories, such as constant buffers, textures, or shader resource view (SRV); but it is possible on the read/write UAV memory or OpenCL global memory.</p>
<p>From a hardware standpoint, reads from a fixed address have the same upper bits, so they collide and are serialized. To read in a single value, read the value in a single work-item, place it in local memory, and then use that location:</p>
<p>Avoid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">temp</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">//</span> <span class="k">if</span> <span class="nb">input</span> <span class="ow">is</span> <span class="kn">from</span> <span class="nn">global</span> <span class="n">space</span>
</pre></div>
</div>
<p>Use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="k">if</span> <span class="p">(</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">local</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

 <span class="p">}</span>
 <span class="n">barrier</span><span class="p">(</span><span class="n">CLK_LOCAL_MEM_FENCE</span><span class="p">);</span>
<span class="n">temp</span> <span class="o">=</span> <span class="n">local</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="coalesced-writes">
<h4>2.1.2 Coalesced Writes<a class="headerlink" href="#coalesced-writes" title="Permalink to this headline">¶</a></h4>
<p>Southern Island devices do not support coalesced writes; however, continuous addresses within work-groups provide maximum performance.</p>
<p>Each compute unit accesses the memory system in quarter-wavefront units. The compute unit transfers a 32-bit address and one element-sized piece of data for each work-item. This results in a total of 16 elements + 16 addresses per quarter-wavefront. On GCN-based devices, processing quarter-wavefront requires two cycles before the data is transferred to the memory controller.</p>
</div>
</div>
<div class="section" id="local-memory-lds-optimization">
<h3>2.2 Local Memory (LDS) Optimization<a class="headerlink" href="#local-memory-lds-optimization" title="Permalink to this headline">¶</a></h3>
<p>AMD GCN-family GPUs include a Local Data Store (LDS) cache, which accelerates local memory accesses. LDS provides high-bandwidth access (more than 10X higher than global memory), efficient data transfers between work-items in a work-group, and high-performance atomic support. LDS is much faster than L1 cache access as it has twice the peak bandwidth and far lower latency. Additionally, using LDS memory can reduce global memory bandwidth usage. Local memory offers significant advantages when the data is re-used; for example, subsequent accesses can read from local memory, thus reducing global memory bandwidth. Another advantage is that local memory does not require coalescing.</p>
<p>To determine local memory size: <strong>clGetDeviceInfo( …, CL_DEVICE_LOCAL_MEM_SIZE, …. );</strong></p>
<p>All AMD Southern Islands, Sea Islands, and Volcanic Islands GPUs (collectively referred to as GCN devices) contain a 64 kB LDS for each compute unit; although only 32 kB can be allocated per work-group. The LDS contains 32- banks, each bank is four bytes wide and 256 bytes deep; the bank address is determined by bits 6:2 in the address. As shown below, programmers must carefully control the bank bits to avoid bank conflicts as much as possible. Bank conflicts are determined by what addresses are accessed on each half wavefront boundary. Threads 0 through 31 are checked for conflicts as are threads 32 through 63 within a wavefront.</p>
<p>In a single cycle, local memory can service a request for each bank (up to 32 accesses each cycle on the AMD Radeon™ HD 7970 GPU). For an AMD Radeon™ HD 7970 GPU, this delivers a memory bandwidth of over 100 GB/s for each compute unit, and more than 3.5 TB/s for the whole chip. This is more than 14X the global memory bandwidth. However, accesses that map to the same bank are serialized and serviced on consecutive cycles. LDS operations do not stall; however, the compiler inserts wait operations prior to issuing operations that depend on the results. A wavefront that generated bank conflicts does not stall implicitly, but may stall explicitly in the kernel if the compiler has inserted a wait command for the outstanding memory access. The GPU reprocesses the wavefront on subsequent cycles, enabling only the lanes receiving data, until all the conflicting accesses complete. The bank with the most conflicting accesses determines the latency for the wavefront to complete the local memory operation. The worst case occurs when all 64 work-items map to the same bank, since each access then is serviced at a rate of one per clock cycle; this case takes 64 cycles to complete the local memory access for the wavefront. A program with a large number of bank conflicts (as measured by the LDSBankConflict performance counter in the CodeXL GPU Profiler statistics) might benefit from using the constant or image memory rather than LDS.</p>
<p>Thus, the key to effectively using the LDS is to control the access pattern, so that accesses generated on the same cycle map to different banks in the LDS. One notable exception is that accesses to the same address (even though they have the same bits 6:2) can be broadcast to all requestors and do not generate a bank conflict. The LDS hardware examines the requests generated over two cycles (32 work-items of execution) for bank conflicts. Ensure, as much as possible, that the memory requests generated from a quarter-wavefront avoid bank conflicts by using unique address bits 6:2. A simple sequential address pattern, where each work-item reads a float2 value from LDS, generates a conflict-free access pattern on the AMD Radeon™ HD 7XXX GPU. Note that a sequential access pattern, where each work-item reads a float4 value from LDS, uses only half the banks on each cycle on the AMD Radeon™ HD 7XXX GPU and delivers half the performance of the float access pattern.</p>
<p>Each stream processor can generate up to two 4-byte LDS requests per cycle. Byte and short reads consume four bytes of LDS bandwidth. Developers can use the large register file: each compute unit has 256 kB of register space available (8X the LDS size) and can provide up to twelve 4-byte values/cycle (6X the LDS bandwidth). Registers do not offer the same indexing flexibility as does the LDS, but for some algorithms this can be overcome with loop unrolling and explicit addressing.</p>
<p>LDS reads require one ALU operation to initiate them. Each operation can initiate two loads of up to four bytes each.</p>
<p>The CodeXL GPU Profiler provides the following performance counter to help optimize local memory usage:</p>
<p>LDSBankConflict: The percentage of time accesses to the LDS are stalled due to bank conflicts relative to GPU Time. In the ideal case, there are no bank conflicts in the local memory access, and this number is zero.</p>
<p>Local memory is software-controlled “scratchpad” memory. In contrast, caches typically used on CPUs monitor the access stream and automatically capture recent accesses in a tagged cache. The scratchpad allows the kernel to explicitly load items into the memory; they exist in local memory until the kernel replaces them, or until the work-group ends. To declare a block of local memory, use the <code class="docutils literal notranslate"><span class="pre">___local</span></code> keyword;
for example:</p>
<blockquote>
<div><strong>__local float localBuffer[64]</strong></div></blockquote>
<p>These declarations can be either in the parameters to the kernel call or in the body of the kernel. The    local syntax allocates a single block of memory, which is shared across all work-items in the workgroup.</p>
<p>To write data into local memory, write it into an array allocated with <code class="docutils literal notranslate"><span class="pre">__local</span></code>.</p>
<p>For example: <strong>localBuffer[i] = 5.0;</strong></p>
<p>A typical access pattern is for each work-item to collaboratively write to the local memory: each work-item writes a subsection, and as the work-items execute in parallel they write the entire array. Combined with proper consideration for the access pattern and bank alignment, these collaborative write approaches can lead to highly efficient memory accessing.</p>
<p>The following example is a simple kernel section that collaboratively writes, then reads from, local memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span> <span class="n">void</span> <span class="n">localMemoryExample</span> <span class="p">(</span>  <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span><span class="n">In</span><span class="p">,</span> <span class="n">__global</span> <span class="nb">float</span> <span class="o">*</span><span class="n">Out</span><span class="p">)</span> <span class="p">{</span>
<span class="n">__local</span> <span class="nb">float</span> <span class="n">localBuffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="n">uint</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">uint</span> <span class="n">gx</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Initialize</span> <span class="n">local</span> <span class="n">memory</span><span class="p">:</span>
<span class="o">//</span> <span class="n">Copy</span> <span class="kn">from</span> <span class="nn">this</span> <span class="n">work</span><span class="o">-</span><span class="n">group</span><span class="s1">&#39;s section of global memory to local:</span>
<span class="o">//</span> <span class="n">Each</span> <span class="n">work</span><span class="o">-</span><span class="n">item</span> <span class="n">writes</span> <span class="n">one</span> <span class="n">element</span><span class="p">;</span> <span class="n">together</span> <span class="n">they</span> <span class="n">write</span> <span class="n">it</span> <span class="nb">all</span>
<span class="n">localBuffer</span><span class="p">[</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">In</span><span class="p">[</span><span class="n">gx</span><span class="p">];</span>

<span class="o">//</span> <span class="n">Ensure</span> <span class="n">writes</span> <span class="n">have</span> <span class="n">completed</span><span class="p">:</span>
<span class="n">barrier</span><span class="p">(</span><span class="n">CLK_LOCAL_MEM_FENCE</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Toy</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">a</span> <span class="n">partial</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">shows</span> <span class="n">re</span><span class="o">-</span><span class="n">use</span> <span class="kn">from</span> <span class="nn">local</span> <span class="nb">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">localBuffer</span><span class="p">[</span><span class="n">tx</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span><span class="o">=</span><span class="n">tx</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="n">f</span> <span class="o">*=</span> <span class="n">localBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">Out</span><span class="p">[</span><span class="n">gx</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the host code cannot read from, or write to, local memory. Only the kernel can access local memory.</p>
<p>Local memory is consistent across work-items only at a work-group barrier; thus, before reading the values written collaboratively, the kernel must include a <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> instruction. An important optimization is the case where the local work-group size is less than, or equal to, the wavefront size. Because the wavefront executes as an atomic unit, the explicit barrier operation is not required. The compiler automatically removes these barriers if the kernel specifies a <code class="docutils literal notranslate"><span class="pre">reqd_work_group_size</span></code> (see section 5.8 of the OpenCL Specification) that is less than the wavefront size. Developers are strongly encouraged to include the barriers where appropriate, and rely on the compiler to remove the barriers when possible, rather than manually removing the <code class="docutils literal notranslate"><span class="pre">barriers()</span></code>. This technique results in more portable code, including the ability to run kernels on CPU devices.</p>
</div>
<div class="section" id="constant-memory-optimization">
<h3>2.3 Constant Memory Optimization<a class="headerlink" href="#constant-memory-optimization" title="Permalink to this headline">¶</a></h3>
<p>Constants (data from read-only buffers shared by a wavefront) are loaded to SGPRs from memory through the L1 (and L2) cache using scalar memory read instructions. The scalar instructions can use up to two SGPR sources per cycle; vector instructions can use one SGPR source per cycle. (There are 512 SGPRs per SIMD, 4 SIMDs per CU; so a 32 CU configuration like Tahiti has 256 kB of SGPRs.)</p>
<p>GCN hardware supports specific inline literal constants. These constants are
“free” in that they do not increase code size:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">0</span>
 <span class="n">integers</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">64</span>
 <span class="n">integers</span> <span class="o">-</span><span class="mf">1.</span><span class="o">.-</span><span class="mi">16</span>
 <span class="mf">0.5</span> <span class="n">single</span> <span class="ow">or</span> <span class="n">double</span> <span class="n">floats</span>
<span class="o">-</span><span class="mf">0.5</span>
 <span class="mf">1.0</span>
<span class="o">-</span><span class="mf">1.0</span>
 <span class="mf">2.0</span>
<span class="o">-</span><span class="mf">2.0</span>
 <span class="mf">4.0</span>
<span class="o">-</span><span class="mf">4.0</span>
</pre></div>
</div>
<p>Any other literal constant increases the code size by at least 32 bits.</p>
<p>The AMD implementation of OpenCL provides three levels of performance for the “constant” memory type.</p>
<dl class="docutils">
<dt>1.Simple Direct-Addressing Patterns</dt>
<dd>Very high bandwidth can be attained when the compiler has available the constant address at compile time and can embed the constant address into the instruction. Each processing element can load up to 4x4-byte direct- addressed constant values each cycle. Typically, these cases are limited to simple non-array constants and function parameters. The executing kernel loads the constants into scalar registers and concurrently populates the constant cache. The constant cache is a tagged cache. Typically each 16 8k cache is shared among four compute units. If the constant data is already present in the constant cache, the load is serviced by the cache and does not require any global memory bandwidth. The constant cache size varies from 4k to 48k per GPU.</dd>
<dt>2.Same Index</dt>
<dd>Hardware acceleration also takes place when all work-items in a wavefront reference the same constant address. In this case, the data is loaded from memory one time, stored in the L1 cache, and then broadcast to all wave- fronts. This can reduce significantly the required memory bandwidth.</dd>
<dt>3.Varying Index</dt>
<dd>More sophisticated addressing patterns, including the case where each work- item accesses different indices, are not hardware accelerated and deliver the same performance as a global memory read with the potential for cache hits.</dd>
</dl>
<p>To further improve the performance of the AMD OpenCL stack, two methods allow users to take advantage of hardware constant buffers. These are:</p>
<ol class="arabic simple">
<li>Globally scoped constant arrays. These arrays are initialized, globally scoped, and in the constant address space (as specified in section 6.5.3 of the OpenCL specification). If the size of an array is below 64 kB, it is placed in hardware constant buffers; otherwise, it uses global memory. An example of this is a lookup table for math functions.</li>
<li>Per-pointer attribute specifying the maximum pointer size. This is specified using the max_constant_size(N) attribute. The attribute form conforms to section 6.10 of the OpenCL 1.0 specification. This attribute is restricted to top-level kernel function arguments in the constant address space. This restriction prevents a pointer of one size from being passed as an argument to a function that declares a different size. It informs the compiler that indices into the pointer remain inside this range and it is safe to allocate a constant buffer in hardware, if it fits. Using a constant pointer that goes outside of this range results in undefined behavior. All allocations are aligned on the 16-byte boundary. For example:</li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kernel</span> <span class="n">void</span> <span class="n">mykernel</span><span class="p">(</span><span class="k">global</span> <span class="nb">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span>
<span class="n">constant</span> <span class="nb">int</span><span class="o">*</span> <span class="n">b</span>   <span class="n">attribute__</span><span class="p">((</span><span class="n">max_constant_size</span> <span class="p">(</span><span class="mi">65536</span><span class="p">)))</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="n">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="mh">0x3FFF</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A kernel that uses constant buffers must use CL_DEVICE_MAX_CONSTANT_ARGS to query the device for the maximum number of constant buffers the kernel can support. This value might differ from the maximum number of hardware constant buffers available. In this case, if the number of hardware constant buffers is less than the CL_DEVICE_MAX_CONSTANT_ARGS, the compiler allocates the largest constant buffers in hardware first and allocates the rest of the constant buffers in global memory. As an optimization, if a constant pointer <strong>A</strong> uses n bytes of memory, where n is less than 64 kB, and constant pointer <strong>B</strong> uses m bytes of memory, where m is less than (64 kB - n) bytes of memory, the compiler can allocate the constant buffer pointers in a single hardware constant buffer. This optimization can be applied recursively by treating the resulting allocation as a single allocation and finding the next smallest constant pointer that fits within the space left in the constant buffer.</p>
</div>
<div class="section" id="opencl-memory-resources-capacity-and-performance">
<h3>2.4 OpenCL Memory Resources: Capacity and Performance<a class="headerlink" href="#opencl-memory-resources-capacity-and-performance" title="Permalink to this headline">¶</a></h3>
<p>Table 2.1 summarizes the hardware capacity and associated performance for the structures associated with the five OpenCL Memory Types. This information specific to the AMD Radeon™ HD 7970 GPUs with 3 GB video memory.</p>
<p><strong>Table 2.1 Hardware Performance Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="31%" />
<col width="10%" />
<col width="11%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>OpenCL Memory Type</td>
<td>Hardware Resource</td>
<td>Size/CU</td>
<td>Size/GPU</td>
<td>Peak Read Bandwidth/
Stream Core</td>
</tr>
<tr class="row-even"><td>Private</td>
<td>GPRs</td>
<td>256k</td>
<td>8192k</td>
<td>12 bytes/cycle</td>
</tr>
<tr class="row-odd"><td>Local</td>
<td>LDS</td>
<td>64k</td>
<td>2048k</td>
<td>8 bytes/cycle</td>
</tr>
<tr class="row-even"><td rowspan="3">Constant</td>
<td>Direct-addressed constant</td>
<td>&#160;</td>
<td>48k</td>
<td>4 bytes/cycle</td>
</tr>
<tr class="row-odd"><td>Same-indexed constant</td>
<td>&#160;</td>
<td>&#160;</td>
<td>4 bytes/cycle</td>
</tr>
<tr class="row-even"><td>Varying-indexed constant</td>
<td>&#160;</td>
<td>&#160;</td>
<td>~0.14 bytes/cycle</td>
</tr>
<tr class="row-odd"><td rowspan="3">Images</td>
<td>L1 Cache</td>
<td>16k</td>
<td>512k¹</td>
<td>1 bytes/cycle</td>
</tr>
<tr class="row-even"><td>L2 Cache</td>
<td>&#160;</td>
<td>768k²</td>
<td>~0.4 bytes/cycle</td>
</tr>
<tr class="row-odd"><td>Global Memory</td>
<td>&#160;</td>
<td>3G</td>
<td>~0.14 bytes/cycle</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>¹ Applies to images and buffers.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>² Applies to images and buffers.</td></tr>
</tbody>
</table>
<p>The compiler tries to map private memory allocations to the pool of GPRs in the GPU. In the event GPRs are not available, private memory is mapped to the “scratch” region, which has the same performance as global memory. Section 2.6.2, “Resource Limits on Active Wavefronts,”, has more information on register allocation and identifying when the compiler uses the scratch region. GPRs provide the highest-bandwidth access of any hardware resource. In addition to reading up to 12 bytes/cycle per processing element from the register file, the hardware can access results produced in the previous cycle without consuming any register file bandwidth.</p>
<p>Same-indexed constants can be cached in the L1 and L2 cache. Note that “same-indexed” refers to the case where all work-items in the wavefront reference the same constant index on the same cycle. The performance shown assumes an L1 cache hit.</p>
<p>Varying-indexed constants, which are cached only in L2, use the same path as global memory access and are subject to the same bank and alignment constraints described in Section 2.1, “Global Memory Optimization,”.</p>
<p>The L1 and L2 read/write caches are constantly enabled. Read only buffers can be cached in L1 and L2.</p>
<p>The L1 cache can service up to four address requests per cycle, each delivering up to 16 bytes. The bandwidth shown assumes an access size of 16 bytes; smaller access sizes/requests result in a lower peak bandwidth for the L1 cache. Using float4 with images increases the request size and can deliver higher L1 cache bandwidth.</p>
<p>Each memory channel on the GPU contains an L2 cache that can deliver up to 64 bytes/cycle. The AMD Radeon™ HD 7970 GPU has 12 memory channels; thus, it can deliver up to 768 bytes/cycle; divided among 2048 stream cores, this provides up to ~0.4 bytes/cycle for each stream core.</p>
<p>Global Memory bandwidth is limited by external pins, not internal bus bandwidth. The AMD Radeon™ HD 7970 GPU supports up to 264 GB/s of memory bandwidth which is an average of 0.14 bytes/cycle for each stream core.</p>
<p>Note that Table 2.1 shows the performance for the AMD Radeon™ HD 7970 GPU. The “Size/Compute Unit” column and many of the bandwidths/processing element apply to all Southern Islands-class GPUs; however, the “Size/GPU” column and the bandwidths for varying-indexed constant, L2, and global memory vary across different GPU devices.</p>
</div>
<div class="section" id="using-lds-or-l1-cache">
<h3>2.5 Using LDS or L1 Cache<a class="headerlink" href="#using-lds-or-l1-cache" title="Permalink to this headline">¶</a></h3>
<p>There are a number of considerations when deciding between LDS and L1 cache for a given algorithm.</p>
<p>LDS supports read/modify/write operations, as well as atomics. It is well-suited for code that requires fast read/write, read/modify/write, or scatter operations that otherwise are directed to global memory. On current AMD hardware, L1 is part of the read path; hence, it is suited to cache-read-sensitive algorithms, such as matrix multiplication or convolution.</p>
<p>LDS is typically larger than L1 (for example: 64 kB vs 16 kB on Southern Islands devices). If it is not possible to obtain a high L1 cache hit rate for an algorithm, the larger LDS size can help. On the AMD Radeon™ HD 7970 device, the theoretical LDS peak bandwidth is 3.8 TB/s, compared to L1 at 1.9 TB/sec.</p>
<p>The native data type for L1 is a four-vector of 32-bit words. On L1, fill and read addressing are linked. It is important that L1 is initially filled from global memory with a coalesced access pattern; once filled, random accesses come at no extra processing cost.</p>
<p>Currently, the native format of LDS is a 32-bit word. The theoretical LDS peak bandwidth is achieved when each thread operates on a two-vector of 32-bit words (16 threads per clock operate on 32 banks). If an algorithm requires coalesced 32-bit quantities, it maps well to LDS. The use of four-vectors or larger can lead to bank conflicts, although the compiler can mitigate some of these.</p>
<p>From an application point of view, filling LDS from global memory, and reading from it, are independent operations that can use independent addressing. Thus, LDS can be used to explicitly convert a scattered access pattern to a coalesced pattern for read and write to global memory. Or, by taking advantage of the LDS read broadcast feature, LDS can be filled with a coalesced pattern from global memory, followed by all threads iterating through the same LDS words simultaneously.</p>
<p>LDS reuses the data already pulled into cache by other wavefronts. Sharing across work-groups is not possible because OpenCL does not guarantee that LDS is in a particular state at the beginning of work-group execution. L1 content, on the other hand, is independent of work-group execution, so that successive work-groups can share the content in the L1 cache of a given Vector ALU. However, it currently is not possible to explicitly control L1 sharing across work- groups.</p>
<p>The use of LDS is linked to GPR usage and wavefront-per-Vector ALU count. Better sharing efficiency requires a larger work-group, so that more work-items share the same LDS. Compiling kernels for larger work-groups typically results in increased register use, so that fewer wavefronts can be scheduled simultaneously per Vector ALU. This, in turn, reduces memory latency hiding. Requesting larger amounts of LDS per work-group results in fewer wavefronts per Vector ALU, with the same effect.</p>
<p>LDS typically involves the use of barriers, with a potential performance impact. This is true even for read-only use cases, as LDS must be explicitly filled in from global memory (after which a barrier is required before reads can commence).</p>
</div>
<div class="section" id="ndrange-and-execution-range-optimization">
<h3>2.6 NDRange and Execution Range Optimization<a class="headerlink" href="#ndrange-and-execution-range-optimization" title="Permalink to this headline">¶</a></h3>
<p>Probably the most effective way to exploit the potential performance of the GPU is to provide enough threads to keep the device completely busy. The programmer specifies a three-dimensional NDRange over which to execute the kernel; bigger problems with larger NDRanges certainly help to more effectively use the machine. The programmer also controls how the global NDRange is divided into local ranges, as well as how much work is done in each work-item, and which resources (registers and local memory) are used by the kernel. All of these can play a role in how the work is balanced across the machine and how well it is used. This section introduces the concept of latency hiding, how many wavefronts are required to hide latency on AMD GPUs, how the resource usage in the kernel can impact the active wavefronts, and how to choose appropriate global and local work-group dimensions.</p>
<div class="section" id="hiding-memory-latency-with-alu-operations">
<h4>2.6.1 Hiding Memory Latency with ALU Operations<a class="headerlink" href="#hiding-memory-latency-with-alu-operations" title="Permalink to this headline">¶</a></h4>
<p>The read-after-write latency for most arithmetic operations (a floating-point add, for example) is only four cycles. For most Southern Island devices, each CU can execute 64 vector ALU instructions per cycle, 16 per wavefront. Also, a wavefront can issue a scalar ALU instruction every four cycles. To achieve peak ALU power, a minimum of four wavefronts must be scheduled for each CU.</p>
<p>Global memory reads generate a reference to the off-chip memory and experience a latency of 300 to 600 cycles. The wavefront that generates the global memory access is made idle until the memory request completes. During this time, the compute unit can process other independent wavefronts, if they are available.</p>
<p>Kernel execution time also plays a role in hiding memory latency: longer chains of ALU instructions keep the functional units busy and effectively hide more latency. To better understand this concept, consider a global memory access which takes 400 cycles to execute. Assume the compute unit contains many other wavefronts, each of which performs five ALU instructions before generating another global memory reference. As discussed previously, the hardware executes each instruction in the wavefront in four cycles; thus, all five instructions occupy the ALU for 20 cycles. Note the compute unit interleaves two of these wavefronts and executes the five instructions from both wavefronts (10 total instructions) in 40 cycles. To fully hide the 400 cycles of latency, the compute unit requires (400/40) = 10 pairs of wavefronts, or 20 total wavefronts. If the wavefront contains 10 instructions rather than 5, the wavefront pair would consume 80 cycles of latency, and only 10 wavefronts would be required to hide the 400 cycles of latency.</p>
<p>Generally, it is not possible to predict how the compute unit schedules the available wavefronts, and thus it is not useful to try to predict exactly which ALU block executes when trying to hide latency. Instead, consider the overall ratio of ALU operations to fetch operations - this metric is reported by the CodeXL GPU Profiler in the <code class="docutils literal notranslate"><span class="pre">ALUFetchRatio</span></code> counter. Each ALU operation keeps the compute unit busy for four cycles, so you can roughly divide 500 cycles of latency by `` (4*ALUFetchRatio)`` to determine how many wavefronts must be in-flight to hide that latency. Additionally, a low value for the <code class="docutils literal notranslate"><span class="pre">ALUBusy</span></code> performance counter can indicate that the compute unit is not providing enough wavefronts to keep the execution resources in full use. (This counter also can be low if the kernel exhausts the available DRAM bandwidth. In this case, generating more wavefronts does not improve performance; it can reduce performance by creating more contention.)</p>
<p>Increasing the wavefronts/compute unit does not indefinitely improve performance once the GPU has enough wavefronts to hide latency, additional active wavefronts provide little or no performance benefit. A closely related metric to wavefronts/compute unit is “occupancy,” which is defined as the ratio of active wavefronts to the maximum number of possible wavefronts supported by the hardware. Many of the important optimization targets and resource limits are expressed in wavefronts/compute units, so this section uses this metric rather than the related “occupancy” term.</p>
</div>
<div class="section" id="resource-limits-on-active-wavefronts">
<h4>2.6.2 Resource Limits on Active Wavefronts<a class="headerlink" href="#resource-limits-on-active-wavefronts" title="Permalink to this headline">¶</a></h4>
<p>AMD GPUs have two important global resource constraints that limit the number of in-flight wavefronts:</p>
<blockquote>
<div><ul class="simple">
<li>Southern Islands devices support a maximum of 16 work-groups per CU if a work-group is larger than one wavefront.</li>
<li>The maximum number of wavefronts that can be scheduled to a CU is 40, or 10 per Vector Unit.</li>
</ul>
</div></blockquote>
<p>These limits are largely properties of the hardware and, thus, difficult for developers to control directly. Fortunately, these are relatively generous limits. Frequently, the register and LDS usage in the kernel determines the limit on the number of active wavefronts/compute unit, and these can be controlled by the developer.</p>
<div class="section" id="gpu-registers">
<h5>2.6.2.1  GPU Registers<a class="headerlink" href="#gpu-registers" title="Permalink to this headline">¶</a></h5>
<p>Southern Islands registers are scalar, so each is 32-bits. Each wavefront can have at most 256 registers (VGPRs). To compute the number of wavefronts per CU, take (256/# registers)*4.</p>
<p>For example, a kernel that uses 120 registers (120x32-bit values) can run with eight active wavefronts on each compute unit. Because of the global limits described earlier, each compute unit is limited to 40 wavefronts; thus, kernels can use up to 25 registers (25x32-bit values) without affecting the number of wavefronts/compute unit.</p>
<p>AMD provides the following tools to examine the number of general-purpose registers (GPRs) used by the kernel.</p>
<ul class="simple">
<li>The CodeXL GPU Profiler displays the number of GPRs used by the kernel.</li>
<li>Alternatively, the CodeXL GPU Profiler generates the ISA dump , which then can be searched for the string <code class="docutils literal notranslate"><span class="pre">:NUM_GPRS.</span></code></li>
<li>The AMD CodeXL Analysis Mode shows the GPR used by the kernel, across a wide variety of GPU compilation targets.</li>
</ul>
<p>The compiler generates spill code (shuffling values to, and from, memory) if it cannot fit all the live values into registers. Spill code uses long-latency global memory and can have a large impact on performance. Spilled registers can be cached in Southern Island devices, thus reducing the impact on performance. The CodeXL GPU Profiler reports the static number of register spills in the ScratchReg field. Generally, it is a good idea to re-write the algorithm to use fewer GPRs, or tune the work-group dimensions specified at launch time to expose more registers/kernel to the compiler, in order to reduce the scratch register usage to 0.</p>
</div>
<div class="section" id="specifying-the-default-work-group-size-at-compile-time">
<h5>2.6.2.2  Specifying the Default Work-Group Size at Compile-Time<a class="headerlink" href="#specifying-the-default-work-group-size-at-compile-time" title="Permalink to this headline">¶</a></h5>
<p>The number of registers used by a work-item is determined by the compiler on compile time. The user later specifies the size of the work-group. Ideally, the OpenCL compiler knows the size of the work-group at compile-time, so it can make optimal register allocation decisions. Without knowing the work-group size, the compiler must assume an upper-bound size to avoid allocating more registers in the work-item than the hardware actually contains.</p>
<p>OpenCL provides a mechanism to specify a work-group size that the compiler can use to optimize the register allocation. In particular, specifying a smaller work-group size at compile time allows the compiler to allocate more registers for each kernel, which can avoid spill code and improve performance. The kernel
attribute syntax is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute</span> <span class="p">((</span><span class="n">reqd_work_group_size</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)))</span>
</pre></div>
</div>
<p>Section 6.7.2 of the OpenCL specification explains the attribute in more detail.</p>
</div>
<div class="section" id="local-memory-lds-size">
<h5>2.6.2.3 Local Memory (LDS) Size<a class="headerlink" href="#local-memory-lds-size" title="Permalink to this headline">¶</a></h5>
<p>In addition to registers, shared memory can also serve to limit the active wavefronts/compute unit. Each compute unit has 64 kB of LDS, which is shared among all active work-groups. Note that the maximum allocation size is 32 kB. LDS is allocated on a per-work-group granularity, so it is possible (and useful) for multiple wavefronts to share the same local memory allocation. However, large LDS allocations eventually limits the number of workgroups that can be active. Table 2.2 provides more details about how LDS usage can impact the wavefronts/compute unit.</p>
<p><strong>Table 2.2  Effect of LDS Usage on Wavefronts/CU1</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="22%" />
<col width="23%" />
<col width="23%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Local Memory/Work-Group</th>
<th class="head">LDS-Limited Wavefronts/Compute-Unit (Assume 4Wavefronts/ Work-Group)</th>
<th class="head">LDS-Limited Wavefronts/ Compute-Unit (Assume 3 Wavefronts/ Work-Group)</th>
<th class="head">LDS-Limited Wavefronts/ Compute-Unit (Assume 2 Wavefronts/ Work-Group)</th>
<th class="head">LDS-Limited Wavefronts / Compute Unit (Assume 1 Wavefront / Work-Group)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&lt;=4K</td>
<td>40</td>
<td>40</td>
<td>32</td>
<td>16</td>
</tr>
<tr class="row-odd"><td>4.0K-4.2K</td>
<td>40</td>
<td>40</td>
<td>30</td>
<td>15</td>
</tr>
<tr class="row-even"><td>4.2K-4.5K</td>
<td>40</td>
<td>40</td>
<td>28</td>
<td>14</td>
</tr>
<tr class="row-odd"><td>4.5K-4.9K</td>
<td>40</td>
<td>39</td>
<td>26</td>
<td>13</td>
</tr>
<tr class="row-even"><td>4.9K-5.3K</td>
<td>40</td>
<td>36</td>
<td>24</td>
<td>12</td>
</tr>
<tr class="row-odd"><td>5.3K-5.8K</td>
<td>40</td>
<td>33</td>
<td>22</td>
<td>11</td>
</tr>
<tr class="row-even"><td>5.8K-6.4K</td>
<td>40</td>
<td>30</td>
<td>20</td>
<td>10</td>
</tr>
<tr class="row-odd"><td>6.4K-7.1K</td>
<td>36</td>
<td>27</td>
<td>18</td>
<td>9</td>
</tr>
<tr class="row-even"><td>7.1K-8.0K</td>
<td>32</td>
<td>24</td>
<td>16</td>
<td>8</td>
</tr>
<tr class="row-odd"><td>8.0K-9.1K</td>
<td>28</td>
<td>21</td>
<td>14</td>
<td>7</td>
</tr>
<tr class="row-even"><td>9.1K-10.6K</td>
<td>24</td>
<td>18</td>
<td>12</td>
<td>6</td>
</tr>
<tr class="row-odd"><td>10.6K-12.8K</td>
<td>20</td>
<td>15</td>
<td>10</td>
<td>5</td>
</tr>
<tr class="row-even"><td>12.8K-16.0K</td>
<td>16</td>
<td>12</td>
<td>8</td>
<td>4</td>
</tr>
<tr class="row-odd"><td>16.0K-21.3K</td>
<td>12</td>
<td>9</td>
<td>6</td>
<td>3</td>
</tr>
<tr class="row-even"><td>21.3K-32.0K</td>
<td>8</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Assumes each work-group uses four wavefronts (the maximum supported by the AMD OpenCL SDK).</td></tr>
</tbody>
</table>
<p>AMD provides the following tools to examine the amount of LDS used by the kernel:</p>
<ul class="simple">
<li>The CodeXL GPU Profiler displays the LDS usage. See the LocalMem counter.</li>
<li>Alternatively, use the CodeXL GPU Profiler to generate the ISA dump, then search for the string <code class="docutils literal notranslate"><span class="pre">SQ_LDS_ALLOC:SIZE</span></code> in the ISA dump. Note that the value is shown in hexadecimal format.</li>
</ul>
</div>
<div class="section" id="partitioning-the-work">
<h5>2.6.3 Partitioning the Work<a class="headerlink" href="#partitioning-the-work" title="Permalink to this headline">¶</a></h5>
<p>In OpenCL, each kernel executes on an index point that exists in a global NDRange. The partition of the NDRange can have a significant impact on performance; thus, it is recommended that the developer explicitly specify the global `` (#work-groups)`` and local `` (#work-items/work-group)`` dimensions, rather than rely on OpenCL to set these automatically (by setting <code class="docutils literal notranslate"><span class="pre">local_work_size</span></code> to NULL in clEnqueueNDRangeKernel). This section explains the guidelines for partitioning at the global, local, and work/kernel levels.</p>
</div>
<div class="section" id="global-work-size">
<h5>2.6.3.1 Global Work Size<a class="headerlink" href="#global-work-size" title="Permalink to this headline">¶</a></h5>
<p>OpenCL does not explicitly limit the number of work-groups that can be submitted with a clEnqueueNDRangeKernel command. The hardware limits the available in- flight threads, but the OpenCL SDK automatically partitions a large number of work-groups into smaller pieces that the hardware can process. For some large workloads, the amount of memory available to the GPU can be a limitation; the problem might require so much memory capacity that the GPU cannot hold it all. In these cases, the programmer must partition the workload into multiple clEnqueueNDRangeKernel commands. The available device memory can be obtained by querying <code class="docutils literal notranslate"><span class="pre">clDeviceInfo</span></code>.</p>
<p>At a minimum, ensure that the workload contains at least as many work-groups as the number of compute units in the hardware. Work-groups cannot be split across multiple compute units, so if the number of work-groups is less than the available compute units, some units are idle. Use clGetDeviceInfo(…CL_DEVICE_MAX_COMPUTE_UNITS) to determine the value dynamically.</p>
</div>
<div class="section" id="local-work-size-work-items-per-work-group">
<h5>2.6.3.2 Local Work Size (#Work-Items per Work-Group)<a class="headerlink" href="#local-work-size-work-items-per-work-group" title="Permalink to this headline">¶</a></h5>
<p>OpenCL limits the number of work-items in each group. Call clDeviceInfo with the CL_DEVICE_MAX_WORK_GROUP_SIZE to determine the maximum number of work-groups supported by the hardware. The latest generation AMD GPUs support a maximum of 256 work-items per work-group. Note the number of work- items is the product of all work-group dimensions; for example, a work-group with dimensions 32x16 requires 512 work-items, which is not allowed with the current AMD OpenCL runtime.</p>
<p>The fundamental unit of work on AMD GPUs is called a wavefront. Each wavefront consists of 64 work-items; thus, the optimal local work size is an integer multiple of 64 (specifically 64, 128, 192, or 256) work-items per work- group.</p>
<p>Work-items in the same work-group can share data through LDS memory and also use high-speed local atomic operations. Thus, larger work-groups enable more work-items to efficiently share data, which can reduce the amount of slower global communication. However, larger work-groups reduce the number of global work-groups, which, for small workloads, could result in idle compute units. Generally, larger work-groups are better as long as the global range is big enough to provide 1-2 Work-Groups for each compute unit in the system; for small workloads it generally works best to reduce the work-group size in order to avoid idle compute units. Note that it is possible to make the decision dynamically, when the kernel is launched, based on the launch dimensions and the target device characteristics.</p>
</div>
<div class="section" id="work-group-dimensions-vs-size">
<h5>2.6.3.3 Work-Group Dimensions vs Size<a class="headerlink" href="#work-group-dimensions-vs-size" title="Permalink to this headline">¶</a></h5>
<p>The local NDRange can contain up to three dimensions, here labeled X, Y, and Z. The X dimension is returned by <code class="docutils literal notranslate"><span class="pre">get_local_id(0)</span></code>, Y is returned by <code class="docutils literal notranslate"><span class="pre">get_local_id(1)</span></code>, and Z is returned by <code class="docutils literal notranslate"><span class="pre">get_local_id(2)</span></code>. The GPU hardware schedules the kernels so that the X dimension moves fastest as the work-items are packed into wavefronts. For example, the 128 threads in a 2D work-group of dimension 32x4 (X=32 and Y=4) are packed into two wavefronts as follows (notation shown in X,Y order).</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td rowspan="4"><strong>WaveFront0</strong></td>
<td>0,0</td>
<td>1,0</td>
<td>2,0</td>
<td>3,0</td>
<td>4,0</td>
<td>5,0</td>
<td>6,0</td>
<td>7,0</td>
<td>8,0</td>
<td>9,0</td>
<td>10,0</td>
<td>11,0</td>
<td>12,0</td>
<td>13,0</td>
<td>14,0</td>
<td>15,0</td>
</tr>
<tr class="row-even"><td>16,0</td>
<td>17,0</td>
<td>18,0</td>
<td>19,0</td>
<td>20,0</td>
<td>21,0</td>
<td>22,0</td>
<td>23,0</td>
<td>24,0</td>
<td>25,0</td>
<td>26,0</td>
<td>27,0</td>
<td>28,0</td>
<td>29,0</td>
<td>30,0</td>
<td>31,0</td>
</tr>
<tr class="row-odd"><td>0,1</td>
<td>1,1</td>
<td>2,1</td>
<td>3,1</td>
<td>4,1</td>
<td>5,1</td>
<td>6,1</td>
<td>7,1</td>
<td>8,1</td>
<td>9,1</td>
<td>10,1</td>
<td>11,1</td>
<td>12,1</td>
<td>13,1</td>
<td>14,1</td>
<td>15,1</td>
</tr>
<tr class="row-even"><td>16,1</td>
<td>17,1</td>
<td>18,1</td>
<td>19,1</td>
<td>20,1</td>
<td>21,1</td>
<td>22,1</td>
<td>23,1</td>
<td>24,1</td>
<td>25,1</td>
<td>26,1</td>
<td>27,1</td>
<td>28,1</td>
<td>29,1</td>
<td>30,1</td>
<td>31,1</td>
</tr>
<tr class="row-odd"><td rowspan="4"><strong>WaveFront1</strong></td>
<td>0,2</td>
<td>1,2</td>
<td>2,2</td>
<td>3,2</td>
<td>4,2</td>
<td>5,2</td>
<td>6,2</td>
<td>7,2</td>
<td>8,2</td>
<td>9,2</td>
<td>10,2</td>
<td>11,2</td>
<td>12,2</td>
<td>13,2</td>
<td>14,2</td>
<td>15,2</td>
</tr>
<tr class="row-even"><td>16,2</td>
<td>17,2</td>
<td>18,2</td>
<td>19,2</td>
<td>20,2</td>
<td>21,2</td>
<td>22,2</td>
<td>23,2</td>
<td>24,2</td>
<td>25,2</td>
<td>26,2</td>
<td>27,2</td>
<td>28,2</td>
<td>29,2</td>
<td>30,2</td>
<td>31,2</td>
</tr>
<tr class="row-odd"><td>0,3</td>
<td>1,3</td>
<td>2,3</td>
<td>3,3</td>
<td>4,3</td>
<td>5,3</td>
<td>6,3</td>
<td>7,3</td>
<td>8,3</td>
<td>9,3</td>
<td>10,3</td>
<td>11,3</td>
<td>12,3</td>
<td>13,3</td>
<td>14,3</td>
<td>15,3</td>
</tr>
<tr class="row-even"><td>16,3</td>
<td>17,3</td>
<td>18,3</td>
<td>19,3</td>
<td>20,3</td>
<td>21,3</td>
<td>22,3</td>
<td>23,3</td>
<td>24,3</td>
<td>25,3</td>
<td>26,3</td>
<td>27,3</td>
<td>28,3</td>
<td>29,3</td>
<td>30,3</td>
<td>31,3</td>
</tr>
</tbody>
</table>
<p>The total number of work-items in the work-group is typically the most important parameter to consider, in particular when optimizing to hide latency by increasing wavefronts/compute unit. However, the choice of XYZ dimensions for the same overall work-group size can have the following second-order effects.</p>
<ul class="simple">
<li>Work-items in the same quarter-wavefront execute on the same cycle in the processing engine. Thus, global memory coalescing and local memory bank conflicts can be impacted by dimension, particularly if the fast-moving X dimension is small. Typically, it is best to choose an X dimension of at least 16, then optimize the memory patterns for a block of 16 work-items which differ by 1 in the X dimension.</li>
<li>Work-items in the same wavefront have the same program counter and execute the same instruction on each cycle. The packing order can be important if the kernel contains divergent branches. If possible, pack together work-items that are likely to follow the same direction when control-flow is encountered. For example, consider an image-processing kernel where each work-item processes one pixel, and the control-flow depends on the color of the pixel. It might be more likely that a square of 8x8 pixels is the same color than a 64x1 strip; thus, the 8x8 would see less divergence and higher performance.</li>
<li>When in doubt, a square 16x16 work-group size is a good start.</li>
</ul>
</div>
</div>
<div class="section" id="summary-of-ndrange-optimizations">
<h4>2.6.4 Summary of NDRange Optimizations<a class="headerlink" href="#summary-of-ndrange-optimizations" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>As shown above, execution range optimization is a complex topic with many interacting variables and which frequently requires some experimentation to determine the optimal values. Some general guidelines are:</dt>
<dd><ul class="first last simple">
<li>Select the work-group size to be a multiple of 64, so that the wavefronts are fully populated.</li>
<li>Schedule at least four wavefronts per compute unit.</li>
<li>Latency hiding depends on both the number of wavefronts/compute unit, as well as the execution time for each kernel. Generally, 8 to 32 wavefronts/compute unit is desirable, but this can vary significantly, depending on the complexity of the kernel and the available memory bandwidth. The CodeXL GPU Profiler and associated performance counters can help to select an optimal value.</li>
</ul>
</dd>
</dl>
</div>
</div>
<div class="section" id="instruction-selection-optimizations">
<h3>2.7 Instruction Selection Optimizations<a class="headerlink" href="#instruction-selection-optimizations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="instruction-bandwidths">
<h4>2.7.1 Instruction Bandwidths<a class="headerlink" href="#instruction-bandwidths" title="Permalink to this headline">¶</a></h4>
<p><strong>Table 2.3 Instruction Throughput (Operations/Cycle for Each Processing Element (ALU))</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="13%" />
<col width="20%" />
<col width="26%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">&#160;</th>
<th class="head" colspan="3">Rate (Operations/Cycle) for each Processing Element (ALU)</th>
</tr>
<tr class="row-even"><th class="head">&#160;</th>
<th class="head">Instruction</th>
<th class="head" colspan="3"><dl class="first last docutils">
<dt>One Quarter-Double-      | One Half-Double-                | Double-Precision-</dt>
<dd><dl class="first last docutils">
<dt>Precision-Speed Devices | Precision-Speed Devices         | Speed-Devices</dt>
<dd><div class="first last line-block">
<div class="line">(e.g. Tahiti, Cayman, Cypress) | (e.g. AMD FirePro 9100)</div>
</div>
</dd>
</dl>
</dd>
</dl>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td rowspan="7">Single Precision FP Rates</td>
<td>SPFP FMA</td>
<td>1/16</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>SPFP MAD</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>ADD</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>MUL</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>INV</td>
<td>1/4</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-even"><td>RQSRT</td>
<td>1/4</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-odd"><td>LOG</td>
<td>1/4</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-even"><td rowspan="6">Double Precision FP Rates</td>
<td>FMA</td>
<td>1/16</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-odd"><td>MAD</td>
<td>1/16</td>
<td>1/4</td>
<td>1/4</td>
</tr>
<tr class="row-even"><td>ADD</td>
<td>1/8</td>
<td>1/2</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>MUL</td>
<td>1/16</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-even"><td>INV (approx.)</td>
<td>1/16</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-odd"><td>RQSRT (approx.)</td>
<td>1/16</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-even"><td rowspan="5">Integer Instruction Rates</td>
<td>MAD</td>
<td>1/4</td>
<td>1/4</td>
<td>1/4</td>
</tr>
<tr class="row-odd"><td>ADD</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>MUL</td>
<td>1/4</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-odd"><td>Bit-shift</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Bitwise XOR</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td rowspan="2">Conversion</td>
<td>Float-to-Int</td>
<td>1/4</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-even"><td>Int-to-Float</td>
<td>1/4</td>
<td>1/4</td>
<td>1/2</td>
</tr>
<tr class="row-odd"><td rowspan="3">24-Bit Integer Inst Rates</td>
<td>MAD</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>ADD</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>MUL</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Double-precision is supported on all GCN family devices at varying rates. The use of single-precision calculation is encouraged, if that precision is acceptable. Single-precision data is also half the size of double-precision, which requires less chip bandwidth and is not as demanding on the cache structures.</p>
<p>Generally, the throughput and latency for 32-bit integer operations is the same as for single-precision floating point operations.</p>
<p>24-bit integer MULs and MADs have four times the throughput of 32-bit integer multiplies. 24-bit signed and unsigned integers are natively supported on the GCN family of devices. The use of OpenCL built-in functions for <code class="docutils literal notranslate"><span class="pre">mul24</span></code> and <code class="docutils literal notranslate"><span class="pre">mad24</span></code> is encouraged. Note that <code class="docutils literal notranslate"><span class="pre">mul24</span></code> can be useful for array indexing operations.</p>
<p>Packed 16-bit and 8-bit operations are not natively supported; however, in cases where it is known that no overflow will occur, some algorithms may be able to effectively pack 2 to 4 values into the 32-bit registers natively supported by the hardware.</p>
<p>The MAD instruction is an IEEE-compliant multiply followed by an IEEE- compliant add; it has the same accuracy as two separate MUL/ADD operations. No special compiler flags are required for the compiler to convert separate MUL/ADD operations to use the MAD instruction.</p>
<p>Table 2.3 shows the throughput for each processing element. To obtain the peak throughput for the whole device, multiply the value in the table with the number of processing elements and the engine clock. For example, according to Table 2.3, an AMD Tahiti device can perform one double-precision ADD operations/2 cycles in each processing element. An AMD Radeon™ HD 7970 GPU has 2048 processing elements and an engine clock of 925 MHz, so the entire GPU has a throughput rate of (.5*2048*925 MHz) = 947 GFlops for double- precision adds.</p>
<p>Similarly, double-precision MADs on AMD Tahiti (including the AMD HD 79XX and the AMD R9 280 products) run at 1/4 rate. Double-precision MADs on AMD Hawaii have two rates: 1/2 rate for the AMD FirePro 9100 devices, and 1/8th rate for the non-FirePro AMD devices (AMD R9 290 for example). Double-precision MADs on the other GCN devices typically run at 1/16 rate.</p>
<p>In general, the rate for double-precision ADD operations is double the rate for double-precision MAD or FMA operations.</p>
<p>For information about the device parameters for some Southern Islands devices, see 2.10, “Device Parameters for Southern Islands Devices”.</p>
</div>
<div class="section" id="amd-media-instructions">
<h4>2.7.2 AMD Media Instructions<a class="headerlink" href="#amd-media-instructions" title="Permalink to this headline">¶</a></h4>
<p>AMD provides a set of media instructions for accelerating media processing. Notably, the sum-of-absolute differences (SAD) operation is widely used in motion estimation algorithms. For the Southern Islands family of devices, new media instructions have been added; these are available under the <code class="docutils literal notranslate"><span class="pre">cl_amd_media_ops2</span></code> extensions.</p>
</div>
<div class="section" id="math-libraries">
<h4>2.7.3 Math Libraries<a class="headerlink" href="#math-libraries" title="Permalink to this headline">¶</a></h4>
<p>The GCN environment contains new instructions for increasing the previous performance of floating point division, trigonometric range reduction, certain type conversions with double-precision values, floating-point classification, and frexp/ldexp.</p>
<p>OpenCL supports two types of math library operation: <code class="docutils literal notranslate"><span class="pre">native_function()</span></code> and <code class="docutils literal notranslate"><span class="pre">function()</span></code>. Native_functions are generally supported in hardware and can run substantially faster, although at somewhat lower accuracy. The accuracy for the non-native functions is specified in section 7.4 of the OpenCL Specification. The accuracy for the native functions is implementation-defined. Developers are encouraged to use the native functions when performance is more important than accuracy.</p>
<p>Compared to previous families of GPUs, the accuracy of certain native functions is increased in the Southern Islands family. We recommend retesting applications where native function accuracy was insufficient on previous GPU devices.</p>
</div>
<div class="section" id="ompiler-optimizations">
<h4>2.7.4 ompiler Optimizations<a class="headerlink" href="#ompiler-optimizations" title="Permalink to this headline">¶</a></h4>
<p>The OpenCL compiler currently recognizes a few patterns and transforms them into a single instruction. By following these patterns, a developer can generate highly efficient code. The currently accepted patterns are:</p>
<ul class="simple">
<li>Bitfield extract on signed/unsigned integers.
<a href="#id12"><span class="problematic" id="id13">|</span></a>(A &gt;&gt; B) &amp; C ==&gt; [u]bit_extract</li>
</ul>
<blockquote>
<div><p>where</p>
<blockquote>
<div><div class="line-block">
<div class="line">B and C are compile time constants,</div>
<div class="line">A is a 8/16/32bit integer type, and</div>
<div class="line">C is a mask.</div>
</div>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li>Bitfield insert on signed/unsigned integers
| ((A &amp; B) &lt;&lt; C) | ((D &amp; E) &lt;&lt; F ==&gt; ubit_insert</li>
</ul>
<blockquote>
<div><p>where</p>
<blockquote>
<div><div class="line-block">
<div class="line">B and E have no conflicting bits (B^E == 0),</div>
<div class="line">B, C, E, and F are compile-time constants, and</div>
<div class="line">B and E are masks.</div>
<div class="line">The first bit set in B is greater than the number of bits in E plus the first bit set in E, or the first bit set in E is greater than the number of bits in B plus the first bit set in B.</div>
<div class="line">If B, C, E, or F are equivalent to the value 0, this optimization is also supported.</div>
</div>
</div></blockquote>
</div></blockquote>
</div>
</div>
<div class="section" id="additional-performance-guidance">
<h3>2.8 Additional Performance Guidance<a class="headerlink" href="#additional-performance-guidance" title="Permalink to this headline">¶</a></h3>
<p>This section is a collection of performance tips for GPU compute and AMD-specific optimizations.</p>
<div class="section" id="loop-unroll-pragma">
<h4>2.8.1 Loop Unroll pragma<a class="headerlink" href="#loop-unroll-pragma" title="Permalink to this headline">¶</a></h4>
<p>The compiler directive <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">unroll</span> <span class="pre">&lt;unroll-factor&gt;</span></code> can be placed immediately prior to a loop as a hint to the compiler to unroll a loop. <code class="docutils literal notranslate"><span class="pre">&lt;unroll-</span> <span class="pre">factor&gt;</span></code> must be a positive integer, 1 or greater. When <code class="docutils literal notranslate"><span class="pre">&lt;unroll-factor&gt;</span></code> is 1, loop unrolling is disabled. When <code class="docutils literal notranslate"><span class="pre">&lt;unroll-factor&gt;</span></code> is 2 or greater, the compiler uses this as a hint for the number of times the loop is to be unrolled.</p>
<p>Examples for using this loop follow.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">No</span> <span class="n">unrolling</span> <span class="n">example</span><span class="p">::</span>

 <span class="c1">#pragma unroll 1</span>
 <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 <span class="o">...</span>
 <span class="p">}</span>
<span class="n">Partial</span> <span class="n">unrolling</span> <span class="n">example</span><span class="p">::</span>
 <span class="c1">#pragma unroll 4</span>
 <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 <span class="o">...</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>Currently, the unroll pragma requires that the loop boundaries can be determined at compile time. Both loop bounds must be known at compile time. If n is not given, it is equivalent to the number of iterations of the loop when both loop bounds are known. If the unroll-factor is not specified, and the compiler can determine the loop count, the compiler fully unrolls the loop. If the unroll-factor is not specified, and the compiler cannot determine the loop count, the compiler does no unrolling.</p>
</div>
<div class="section" id="memory-tiling">
<h4>2.8.2 Memory Tiling<a class="headerlink" href="#memory-tiling" title="Permalink to this headline">¶</a></h4>
<p>There are many possible physical memory layouts for images. AMD devices can access memory in a tiled or in a linear arrangement.
* Linear - A linear layout format arranges the data linearly in memory such that element addresses are sequential. This is the layout that is familiar to CPU programmers. This format must be used for OpenCL buffers; it can be used for images.
* Tiled - A tiled layout format has a pre-defined sequence of element blocks arranged in sequential memory addresses (see Figure 2.3 for a conceptual illustration). A microtile consists of ABIJ; a macrotile consists of the top-left 16 squares for which the arrows are red. Only images can use this format. Translating from user address space to the tiled arrangement is transparent to the user. Tiled memory layouts provide an optimized memory access pattern to make more efficient use of the RAM attached to the GPU compute device. This can contribute to lower latency.</p>
<img alt="../_images/2.3.png" src="../_images/2.3.png" />
<p><strong>Figure 2.3 One Example of a Tiled Layout Format</strong></p>
<p><strong>Memory Access Pattern -</strong></p>
<p>Memory access patterns in compute kernels are usually different from those in the pixel shaders. Whereas the access pattern for pixel shaders is in a hierarchical, space-filling curve pattern and is tuned for tiled memory performance (generally for textures), the access pattern for a compute kernel is linear across each row before moving to the next row in the global id space. This has an effect on performance, since pixel shaders have implicit blocking, and compute kernels do not. If accessing a tiled image, best performance is achieved if the application tries to use workgroups with 16x16 (or 8x8) work-items.</p>
</div>
<div class="section" id="general-tips">
<h4>2.8.3 General Tips<a class="headerlink" href="#general-tips" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Using dynamic pointer assignment in kernels that are executed on the GPU cause inefficient code generation.</li>
<li>Many OpenCL specification compiler options that are accepted by the AMD OpenCL compiler are not implemented. The implemented options are <code class="docutils literal notranslate"><span class="pre">-D</span></code> , <code class="docutils literal notranslate"><span class="pre">-I</span></code>, <code class="docutils literal notranslate"><span class="pre">w</span></code>, <code class="docutils literal notranslate"><span class="pre">Werror</span></code>, <code class="docutils literal notranslate"><span class="pre">-clsingle-precision-constant</span></code>, <code class="docutils literal notranslate"><span class="pre">-cl-opt-disable</span></code>, and <code class="docutils literal notranslate"><span class="pre">-cl-fp32-correctly-rounded-divide-sqrt</span></code>.</li>
<li>Avoid declaring global arrays on the kernel’s stack frame as these typically cannot be allocated in registers and require expensive global memory operations.</li>
<li>Use predication rather than control-flow. The predication allows the GPU to execute both paths of execution in parallel, which can be faster than attempting to minimize the work through clever control-flow. The reason for this is that if no memory operation exists in a <code class="docutils literal notranslate"><span class="pre">?:</span></code> operator (also called a ternary operator), this operation is translated into a single cmov_logical instruction, which is executed in a single cycle. An example of this is :</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">If</span> <span class="p">(</span><span class="n">A</span><span class="o">&gt;</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span> <span class="n">C</span> <span class="o">+=</span> <span class="n">D</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">C</span> <span class="o">-=</span> <span class="n">D</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Replace this with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>int factor = (A&gt;B) ? 1:-1;
C += factor*D;
</pre></div>
</div>
<p>In the first block of code, this translates into an IF/ELSE/ENDIF sequence of conditional code, each taking ~8 cycles. If divergent, this code executes in ~36 clocks; otherwise, in ~28 clocks. A branch not taken costs four cycles (one instruction slot); a branch taken adds four slots of latency to fetch instructions from the instruction cache, for a total of 16 clocks. Since the execution mask is saved, then modified, then restored for the branch, ~12 clocks are added when divergent, ~8 clocks when not.</p>
<p>In the second block of code, the <code class="docutils literal notranslate"><span class="pre">?:</span></code> operator executes in the vector units, so no extra CF instructions are generated. Since the instructions are sequentially dependent, this block of code executes in 12 cycles, for a 1.3x speed improvement. To see this, the first cycle is the (A&gt;B) comparison, the result of which is input to the second cycle, which is the cmov_logical factor, bool, 1, -1. The final cycle is a MAD instruction that: mad C, factor, D, C. If the ratio between conditional code and ALU instructions is low, this is a good pattern to remove the control flow.</p>
<ul class="simple">
<li>Loop Unrolling</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>OpenCL kernels typically are high instruction-per-clock applications. Thus, the overhead to evaluate control-flow and execute branch instructions can consume a significant part of resource that otherwise can be used for high-throughput compute operations.</li>
<li>The AMD OpenCL compiler performs simple loop unrolling optimizations; however, for more complex loop unrolling, it may be beneficial to do this manually.</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>If possible, create a reduced-size version of your data set for easier debugging and faster turn-around on performance experimentation. GPUs do not have automatic caching mechanisms and typically scale well as resources are added. In many cases, performance optimization for the reduced-size data implementation also benefits the full-size algorithm.</li>
<li>When tuning an algorithm, it is often beneficial to code a simple but accurate algorithm that is retained and used for functional comparison. GPU tuning can be an iterative process, so success requires frequent experimentation, verification, and performance measurement.</li>
<li>The profiling and analysis tools report statistics on a per-kernel granularity. To narrow the problem further, it might be useful to remove or comment-out sections of code, then re-run the timing and profiling tool.</li>
<li>Avoid writing code with dynamic pointer assignment on the GPU. For example:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kernel</span> <span class="n">void</span> <span class="n">dyn_assign</span><span class="p">(</span><span class="k">global</span> <span class="nb">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">global</span> <span class="nb">int</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="k">global</span> <span class="nb">int</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">global</span> <span class="nb">int</span><span class="o">*</span> <span class="n">d</span><span class="p">;</span>
<span class="n">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is inefficient because the GPU compiler must know the base pointer that every load comes from and in this situation, the compiler cannot determine what â€˜d’ points to. So, both B and C are assigned to the same GPU resource, removing the ability to do certain optimizations.</p>
<p><a href="#id14"><span class="problematic" id="id15">*</span></a>If the algorithm allows changing the work-group size, it is possible to get better performance by using larger work-groups (more work-items in each work-group) because the workgroup creation overhead is reduced. On the other hand, the OpenCL CPU runtime uses a task-stealing algorithm at the work-group level, so when the kernel execution time differs because it contains conditions and/or loops of varying number of iterations, it might be better to increase the number of work-groups. This gives the runtime more flexibility in scheduling work-groups to idle CPU cores. Experimentation might be needed to reach optimal work-group size.
<a href="#id16"><span class="problematic" id="id17">*</span></a>Since the AMD OpenCL runtime supports only in-order queuing, using clFinish() on a queue and queuing a blocking command gives the same result. The latter saves the overhead of another API command.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clEnqueueWriteBuffer</span><span class="p">(</span><span class="n">myCQ</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="o">**</span><span class="n">CL_FALSE</span><span class="o">**</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffSize</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="n">clFinish</span><span class="p">(</span><span class="n">myCQ</span><span class="p">);</span>
</pre></div>
</div>
<p>is equivalent, for the AMD OpenCL runtime, to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clEnqueueWriteBuffer</span><span class="p">(</span><span class="n">myCQ</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="o">**</span><span class="n">CL_TRUE</span><span class="o">**</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffSize</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li>GPU ISA: GCN-based GPUs have 32KB of dedicated L1 instruction cache. A single instruction cache instance serves up to 4 CUs (depending upon the architecture family and device), with each CU holding up to 40 wavefronts. As each wavefront includes its own program counter, a single instruction cache unit may serve up to 160 wavefronts with each executing a different instruction in the program.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the program is larger than 32KB, the L1-L2 cache trashing can inhibit performance. The size of the ISA can be determined by using the CodeXL analysis mode, under the Statistics tab. For information about how to use CodeXL, see Chapter 4.</p>
</div>
</div>
<div class="section" id="guidance-for-cuda-programmers-using-opencl">
<h4>2.8.4 Guidance for CUDA Programmers Using OpenCL<a class="headerlink" href="#guidance-for-cuda-programmers-using-opencl" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Porting from CUDA to OpenCL is relatively straightforward. Multiple vendors have documents describing how to do this, including AMD:http://developer.amd.com/documentation/articles/pages/OpenCL-and-the-ATI-Stream-v2.0-Beta.aspx#four</li>
<li>Some specific performance recommendations which differ from other GPU architectures:<ul>
<li>Use a workgroup size that is a multiple of 64. CUDA code can use a workgroup size of 32; this uses only half the available compute resources on an AMD Radeon™ HD 7970 GPU.</li>
<li>AMD GPUs have a very high single-precision flops capability (3.788 teraflops in a single AMD Radeon™ HD 7970 GPU). Algorithms that benefit from such throughput can deliver excellent performance on AMD hardware.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="guidance-for-cpu-programmers-using-opencl-to-program-gpus">
<h4>2.8.5 Guidance for CPU Programmers Using OpenCL to Program GPUs<a class="headerlink" href="#guidance-for-cpu-programmers-using-opencl-to-program-gpus" title="Permalink to this headline">¶</a></h4>
<p>OpenCL is the industry-standard toolchain for programming GPUs and parallel devices from many vendors. It is expected that many programmers skilled in CPU programming will program GPUs for the first time using OpenCL. This section provides some guidance for experienced programmers who are programming a GPU for the first time. It specifically highlights the key differences in optimization strategy.</p>
<ul class="simple">
<li>Study the local memory (LDS) optimizations. These greatly affect the GPU performance. Note the difference in the organization of local memory on the GPU as compared to the CPU cache. Local memory is shared by many work-items (64 on Tahiti). This contrasts with a CPU cache that normally is dedicated to a single work-item. GPU kernels run well when they collaboratively load the shared memory.</li>
<li>GPUs have a large amount of raw compute horsepower, compared to memory bandwidth and to “control flow” bandwidth. This leads to some high- level differences in GPU programming strategy.<ul>
<li>A CPU-optimized algorithm may test branching conditions to minimize the workload. On a GPU, it is frequently faster simply to execute the workload.</li>
<li>A CPU-optimized version can use memory to store and later load pre- computed values. On a GPU, it frequently is faster to recompute values rather than saving them in registers. Per-thread registers are a scarce resource on the CPU; in contrast, GPUs have many available per-thread register resources.</li>
</ul>
</li>
<li>Use <code class="docutils literal notranslate"><span class="pre">float4</span></code> and the OpenCL built-ins for vector types (<code class="docutils literal notranslate"><span class="pre">vload,</span> <span class="pre">vstore</span></code>, etc.). These enable the AMD OpenCL implementation to generate efficient, packed SSE instructions when running on the CPU. Vectorization is an optimization that benefits both the AMD CPU and GPU.</li>
</ul>
</div>
<div class="section" id="optimizing-kernel-code">
<h4>2.8.6 Optimizing Kernel Code<a class="headerlink" href="#optimizing-kernel-code" title="Permalink to this headline">¶</a></h4>
<div class="section" id="using-vector-data-types">
<h5>2.8.6.1 Using Vector Data Types<a class="headerlink" href="#using-vector-data-types" title="Permalink to this headline">¶</a></h5>
<p>The CPU contains a vector unit, which can be efficiently used if the developer is writing the code using vector data types.</p>
<p>For architectures before Bulldozer, the instruction set is called SSE, and the vector width is 128 bits. For Bulldozer, there the instruction set is called AVX, for which the vector width is increased to 256 bits.</p>
<p>Using four-wide vector types (int4, float4, etc.) is preferred, even with Bulldozer.</p>
</div>
<div class="section" id="local-memory">
<h5>2.8.6.2 Local Memory<a class="headerlink" href="#local-memory" title="Permalink to this headline">¶</a></h5>
<p>The CPU does not benefit much from local memory; sometimes it is detrimental to performance. As local memory is emulated on the CPU by using the caches, accessing local memory and global memory are the same speed, assuming the information from the global memory is in the cache.</p>
</div>
<div class="section" id="using-special-cpu-instructions">
<h5>2.8.6.3 Using Special CPU Instructions<a class="headerlink" href="#using-special-cpu-instructions" title="Permalink to this headline">¶</a></h5>
<p>The Bulldozer family of CPUs FMA4 supports instructions, exchanging instructions of the form <code class="docutils literal notranslate"><span class="pre">a*b+c</span></code> with <code class="docutils literal notranslate"><span class="pre">fma(a,b,c)</span></code> or <code class="docutils literal notranslate"><span class="pre">mad(a,b,c)</span></code> allows for the use of the special hardware instructions for multiplying and adding.</p>
<p>There also is hardware support for OpenCL functions that give the new hardware implementation of rotating.</p>
<p>For example:</p>
<p><strong>sum.x += tempA0.x * tempB0.x + tempA0.y * tempB1.x + tempA0.z * tempB2.x + tempA0.w * tempB3.x;</strong></p>
<p>can be written as a composition of mad instructions which use fused multiple add
(FMA):</p>
<p><strong>sum.x += mad(tempA0.x, tempB0.x, mad(tempA0.y, tempB1.x, mad(tempA0.z, tempB2.x, tempA0.w*tempB3.x)));</strong></p>
</div>
<div class="section" id="avoid-barriers-when-possible">
<h5>2.8.6.4 Avoid Barriers When Possible<a class="headerlink" href="#avoid-barriers-when-possible" title="Permalink to this headline">¶</a></h5>
<p>Using barriers in a kernel on the CPU causes a significant performance penalty compared to the same kernel without barriers. Use a barrier only if the kernel requires it for correctness, and consider changing the algorithm to reduce barriers usage.</p>
</div>
</div>
<div class="section" id="optimizing-kernels-for-southern-island-gpus">
<h4>2.8.7 Optimizing Kernels for Southern Island GPUs<a class="headerlink" href="#optimizing-kernels-for-southern-island-gpus" title="Permalink to this headline">¶</a></h4>
<div class="section" id="remove-conditional-assignments">
<h5>2.8.7.1 Remove Conditional Assignments<a class="headerlink" href="#remove-conditional-assignments" title="Permalink to this headline">¶</a></h5>
<p>A conditional of the form “if-then-else” generates branching. Use the <code class="docutils literal notranslate"><span class="pre">select()</span></code> function to replace these structures with conditional assignments that do not cause branching. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.5</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
</pre></div>
</div>
<p>becomes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">);</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that if the body of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement contains an I/O, the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement cannot be eliminated.</p>
</div>
<div class="section" id="bypass-short-circuiting">
<h5>2.8.7.2 Bypass Short-Circuiting<a class="headerlink" href="#bypass-short-circuiting" title="Permalink to this headline">¶</a></h5>
<p>A conditional expression with many terms can compile into nested conditional code due to the C-language requirement that expressions must short circuit. To prevent this, move the expression out of the control flow statement. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&amp;&amp;</span><span class="n">b</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">){</span><span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>becomes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">a</span><span class="o">&amp;&amp;</span><span class="n">b</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">){</span><span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>The same applies to conditional expressions used in loop constructs (do, while, for).</p>
</div>
<div class="section" id="unroll-small-loops">
<h5>2.8.7.3 Unroll Small Loops<a class="headerlink" href="#unroll-small-loops" title="Permalink to this headline">¶</a></h5>
<p>If the loop bounds are known, and the loop is small (less than 16 or 32 instructions), unrolling the loop usually increases performance.</p>
</div>
<div class="section" id="avoid-nested-ifs">
<h5>2.8.7.4 Avoid Nested ifs<a class="headerlink" href="#avoid-nested-ifs" title="Permalink to this headline">¶</a></h5>
<p>Because the GPU is a Vector ALU architecture, there is a cost to executing an <code class="docutils literal notranslate"><span class="pre">if-then-else</span> <span class="pre">block</span></code> because both sides of the branch are evaluated, then one result is retained while the other is discarded. When <code class="docutils literal notranslate"><span class="pre">if</span></code> blocks are nested, the results are twice as bad; in general, if blocks are nested k levels deep, 2^k nested conditional structures are generated. In this situation, restructure the code to eliminate nesting.</p>
</div>
<div class="section" id="experiment-with-do-while-for-loops">
<h5>2.8.7.5 Experiment With do/while/for Loops<a class="headerlink" href="#experiment-with-do-while-for-loops" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> loops can generate more conditional code than equivalent <code class="docutils literal notranslate"><span class="pre">do</span></code> or <code class="docutils literal notranslate"><span class="pre">while</span></code> loops. Experiment with these different loop types to find the one with best performance.</p>
</div>
</div>
</div>
<div class="section" id="specific-guidelines-for-gcn-family-gpus">
<h3>2.9 Specific Guidelines for GCN family GPUs<a class="headerlink" href="#specific-guidelines-for-gcn-family-gpus" title="Permalink to this headline">¶</a></h3>
<p>The AMD Southern Islands (SI), Sea Islands (CI), and Volcanic Islands (VI) families of products are quite different from previous generations. These families are based on what is publicly called Graphics Core Next (GCN) and are collectively referred to as GCN chips.</p>
<p>The compute units in GCN devices are much different from those of previous chips. With previous generations, a compute unit (Vector ALU) was VLIW in nature, so four (Cayman GPUs) or five (all other Evergreen/Northern Islands GPUs) instructions could be packed into a single ALU instruction slot (called a bundle). It was not always easy to schedule instructions to fill all of these slots, so achieving peak ALU utilization was a challenge.</p>
<p>With GCN GPUs, the compute units are now scalar; however, there now are four Vector ALUs per compute unit. Each Vector ALU requires at least one wavefront scheduled to it to achieve peak ALU utilization.</p>
<p>Along with the four Vector ALUs within a compute unit, there is also a scalar unit. The scalar unit is used to handle branching instructions, constant cache accesses, and other operations that occur per wavefront. The advantage to having a scalar unit for each compute unit is that there are no longer large penalties for branching, aside from thread divergence.</p>
<p>The instruction set for SI is scalar, as are GPRs. Also, the instruction set is no longer clause-based. There are two types of GPRs: scalar GPRs (SGPRs) and vector GPRs (VGPRs). Each Vector ALU has its own SGPR and VGPR pool. There are 512 SGPRs and 256 VGPRs per Vector ALU. VGPRs handle all vector instructions (any instruction that is handled per thread, such as v_add_f32, a floating point add). SGPRs are used for scalar instructions: any instruction that is executed once per wavefront, such as a branch, a scalar ALU instruction, and constant cache fetches. (SGPRs are also used for constants, all buffer/texture definitions, and sampler definitions; some kernel arguments are stored, at least temporarily, in SGPRs.) SGPR allocation is in increments of eight, and VGPR allocation is in increments of four. These increments also represent the minimum allocation size of these resources.</p>
<p>Typical scalar instructions execute in four cycles. The scalar engine can accept one instruction per SIMD every four cycles. The latency of a scalar instruction is typically four clocks.</p>
<p>Typical vector instructions execute in four cycles.  SIMDs within a compute unit can overlap vector instruction execution; each SIMD unit is offset by one cycle from the previous one. This allows each SIMD unit to execute one Vector ALU instruction and one scalar ALU instruction every four clocks.</p>
<p>All GCN GPUs have double-precision support. For Tahiti (AMD Radeon™ HD 79XX series), double precision adds run at one-half the single precision add rate. Double-precision multiplies and MAD instructions run at one-quarter the floating- point rate.</p>
<p>The double-precision rate of Pitcairn (AMD Radeon™ HD 78XX series) and Cape Verde (AMD Radeon™ HD 77XX series) is one quarter that of Tahiti. This also affects the performance of single-precision fused multiple add (FMA).</p>
<p>Similar to previous generations local data share (LDS) is a shared resource within a compute unit. The maximum LDS allocation size for a work-group is still 32 kB, however each compute unit has a total of 64 kB of LDS. On SI GPUs, LDS memory has 32 banks; thus, it is important to be aware of LDS bank conflicts on half-wavefront boundaries. The allocation granularity for LDS is 256 bytes; the minimum size is 0 bytes. It is much easier to achieve high LDS bandwidth use on SI hardware.</p>
<p>L1 cache is still shared within a compute unit. The size has now increased to 16 kB per compute unit for all SI GPUs. The caches now are read/write, so sharing data between work-items in a work-group (for example, when LDS does not suffice) is much faster.</p>
<p>It is possible to schedule a maximum of 10 wavefronts per vector unit, assuming there are no limitations by other resources, such as registers or local memory; but there is a limit of 16 work-groups per compute unit if the work-groups are larger than a single wavefront. If the dispatch is larger than what can fit at once on the GPU, the GPU schedules new work-groups as others finish.</p>
<p>Since there are no more clauses in the instruction set architecture (ISA) for GCN devices, the compiler inserts “wait” commands to indicate that the compute unit needs the results of a memory operation before proceeding. If the scalar unit determines that a wait is required (the data is not yet ready), the Vector ALU can switch to another wavefront. There are different types of wait commands, depending on the memory access.</p>
<p><strong>Notes -</strong></p>
<ul class="simple">
<li>Vectorization is no longer needed, nor desirable; in fact, it can affect performance because it requires a greater number of VGPRs for storage. I is recommended not to combine work-items.</li>
<li>Register spilling is no greater a problem with four wavefronts per work-group than it is with one wavefront per work-group. This is because each wavefront has the same number of SGPRs and VGPRs available in either case.</li>
<li>Read coalescing does not work for 64-bit data sizes. This means reads for float2, int2, and double might be slower than expected.</li>
<li>Work-groups with 256 work-items can be used to ensure that each compute unit is being used. Barriers now are much faster.</li>
<li>The engine is wider than previous generations; this means larger dispatches are required to keep the all the compute units busy.</li>
<li>A single wavefront can take twice as long to execute compared to previous generations (assuming ALU bound). This is because GPUs with VLIW-4 could execute the four instructions in a VLIW bundle in eight clocks (typical), and SI GPUs can execute one vector instruction in four clocks (typical).</li>
<li>Execution of kernel dispatches can overlap if there are no dependencies between them and if there are resources available in the GPU. This is critical when writing benchmarks it is important that the measurements are accurate and that “false dependencies” do not cause unnecessary slowdowns.An example of false dependency is:<ol class="loweralpha">
<li>Application creates a kernel “foo”.</li>
<li>Application creates input and output buffers.</li>
<li>Application binds input and output buffers to kernel “foo”.</li>
<li>Application repeatedly dispatches “foo” with the same parameters.</li>
</ol>
</li>
</ul>
<p>If the output data is the same each time, then this is a false dependency because there is no reason to stall concurrent execution of dispatches. To avoid stalls, use multiple output buffers. The number of buffers required to get peak performance depends on the kernel.</p>
<p>Table 2.4 compares the resource limits for Northern Islands and Southern Islands
GPUs.</p>
<blockquote>
<div><strong>Table 2.4 Resource Limits for Northern Islands and Southern Islands</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="12%" />
<col width="15%" />
<col width="7%" />
<col width="10%" />
<col width="15%" />
<col width="8%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">VLIW Width</th>
<th class="head">VGPRs</th>
<th class="head">SGPRs</th>
<th class="head">LDS Size</th>
<th class="head">LDS Max Alloc</th>
<th class="head">L1$/CU</th>
<th class="head">L2$/Channel</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Northern Islands</td>
<td>4</td>
<td>256 (128-bit)</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>32 kB</td>
<td>32 kB</td>
<td>8 kB</td>
<td>64 kB</td>
</tr>
<tr class="row-odd"><td>Southern Islands</td>
<td>1</td>
<td>256(32-bit)</td>
<td>512</td>
<td>64 kB</td>
<td>32 kB</td>
<td>16 kB</td>
<td>64 kB</td>
</tr>
</tbody>
</table>
<p>Table 2.4 provides a simplified picture showing the Northern Island compute unit arrangement.</p>
<img alt="../_images/2.4.png" src="../_images/2.4.png" />
<p><strong>Figure 2.4 Northern Islands Compute Unit Arrangement</strong></p>
<p>Table 2.5 provides a simplified picture showing the Southern Island compute unit arrangement.</p>
<img alt="../_images/2.5.png" src="../_images/2.5.png" />
<p><strong>Figure 2.5 Southern Island Compute Unit Arrangement</strong></p>
</div>
<div class="section" id="device-parameters-for-southern-islands-devices">
<h3>2.10 Device Parameters for Southern Islands Devices<a class="headerlink" href="#device-parameters-for-southern-islands-devices" title="Permalink to this headline">¶</a></h3>
<p>The following table provides device-specific information for some AMD Southern Islands GPUs.</p>
<p><strong>Table 2.5 Parameters for AMD 7xxx Devices</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="11%" />
<col width="10%" />
<col width="14%" />
<col width="13%" />
<col width="12%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">Verde PRO</th>
<th class="head">Verde XT</th>
<th class="head">Pitcairn PRO</th>
<th class="head">Pitcairn XT</th>
<th class="head">Tahiti PRO</th>
<th class="head">Tahiti XT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Product Name (AMD Radeon™ HD)</td>
<td>7750</td>
<td>7770</td>
<td>7850</td>
<td>7870</td>
<td>7950</td>
<td>7970</td>
</tr>
<tr class="row-odd"><td>Engine Speed (MHz)</td>
<td>800</td>
<td>1000</td>
<td>860</td>
<td>1000</td>
<td>800</td>
<td>925</td>
</tr>
<tr class="row-even"><td colspan="7">Compute Resources</td>
</tr>
<tr class="row-odd"><td>Compute Units</td>
<td>8</td>
<td>10</td>
<td>16</td>
<td>20</td>
<td>28</td>
<td>32</td>
</tr>
<tr class="row-even"><td>Processing Elements</td>
<td>512</td>
<td>640</td>
<td>1024</td>
<td>1280</td>
<td>1792</td>
<td>2048</td>
</tr>
<tr class="row-odd"><td>Peak Gflops</td>
<td>819</td>
<td>1280</td>
<td>1761</td>
<td>2560</td>
<td>2867</td>
<td>3789</td>
</tr>
<tr class="row-even"><td colspan="7">Cache and Register Sizes</td>
</tr>
<tr class="row-odd"><td># of 32b Vector Registers/CU</td>
<td>65536</td>
<td>65536</td>
<td>65536</td>
<td>65536</td>
<td>65536</td>
<td>65536</td>
</tr>
<tr class="row-even"><td>Size of Vector Registers/CU</td>
<td>256 kB</td>
<td>256 kB</td>
<td>256 kB</td>
<td>256 kB</td>
<td>256 kB</td>
<td>256 kB</td>
</tr>
<tr class="row-odd"><td>LDS Size/ CU</td>
<td>64 kB</td>
<td>64 kB</td>
<td>64 kB</td>
<td>64 kB</td>
<td>64 kB</td>
<td>64 kB</td>
</tr>
<tr class="row-even"><td>LDS Banks / CU</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>32</td>
</tr>
<tr class="row-odd"><td>Constant Cache / GPU</td>
<td>64 kB</td>
<td>64 kB</td>
<td>128 kB</td>
<td>128 kB</td>
<td>128 kB</td>
<td>128 kB</td>
</tr>
<tr class="row-even"><td>Max Constants / 4 CUs</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
</tr>
<tr class="row-odd"><td>L1 Cache Size / CU</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
<td>16 kB</td>
</tr>
<tr class="row-even"><td>L2 Cache Size / GPU</td>
<td>512 kB</td>
<td>512 kB</td>
<td>512 kB</td>
<td>512 kB</td>
<td>768 kB</td>
<td>768 kB</td>
</tr>
<tr class="row-odd"><td colspan="7">Peak GPU Bandwidths</td>
</tr>
<tr class="row-even"><td>Register Read (GB/s)</td>
<td>4915</td>
<td>7680</td>
<td>10568</td>
<td>15360</td>
<td>17203</td>
<td>22733</td>
</tr>
<tr class="row-odd"><td>LDS Read (GB/s)</td>
<td>819</td>
<td>1280</td>
<td>1761</td>
<td>2560</td>
<td>2867</td>
<td>3789</td>
</tr>
<tr class="row-even"><td>Constant Cache Read (GB/s)</td>
<td>102</td>
<td>160</td>
<td>220</td>
<td>320</td>
<td>358</td>
<td>474</td>
</tr>
<tr class="row-odd"><td>L1 Read (GB/s)</td>
<td>410</td>
<td>640</td>
<td>881</td>
<td>1280</td>
<td>1434</td>
<td>1894</td>
</tr>
<tr class="row-even"><td>L2 Read (GB/s)</td>
<td>205</td>
<td>256</td>
<td>440</td>
<td>512</td>
<td>614</td>
<td>710</td>
</tr>
<tr class="row-odd"><td>Global Memory (GB/s)</td>
<td>72</td>
<td>72</td>
<td>154</td>
<td>154</td>
<td>240</td>
<td>264</td>
</tr>
<tr class="row-even"><td colspan="7">Global Limits</td>
</tr>
<tr class="row-odd"><td>Max Wavefronts / GPU</td>
<td>320</td>
<td>400</td>
<td>640</td>
<td>800</td>
<td>1120</td>
<td>1280</td>
</tr>
<tr class="row-even"><td>Max Wavefronts / CU (avg)</td>
<td>40</td>
<td>40</td>
<td>40</td>
<td>40</td>
<td>40</td>
<td>40</td>
</tr>
<tr class="row-odd"><td>Max Work-Items / GPU</td>
<td>20480</td>
<td>25600</td>
<td>40960</td>
<td>51200</td>
<td>71680</td>
<td>81920</td>
</tr>
<tr class="row-even"><td colspan="7">Memory</td>
</tr>
<tr class="row-odd"><td>Memory Channels</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>12</td>
<td>12</td>
</tr>
<tr class="row-even"><td>Memory  Bus Width (bits)</td>
<td>128</td>
<td>128</td>
<td>256</td>
<td>256</td>
<td>384</td>
<td>384</td>
</tr>
<tr class="row-odd"><td>Memory  Type and</td>
<td>GDDR5</td>
<td>GDDR5</td>
<td>GDDR5</td>
<td>GDDR5</td>
<td>GDDR5</td>
<td>GDDR5</td>
</tr>
<tr class="row-even"><td>Speed (MHZ)</td>
<td>1125</td>
<td>1125</td>
<td>1200</td>
<td>1200</td>
<td>1250</td>
<td>1375</td>
</tr>
<tr class="row-odd"><td>Frame Buffer</td>
<td>1GB</td>
<td>1GB</td>
<td>2GB</td>
<td>1GB or 2GB</td>
<td>3GB</td>
<td>3GB</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="chapter-3-opencl-performance-and-optimization-for-evergreen-and-northern-islands-devices">
<h2>Chapter 3 OpenCL Performance and Optimization for Evergreen and Northern Islands Devices<a class="headerlink" href="#chapter-3-opencl-performance-and-optimization-for-evergreen-and-northern-islands-devices" title="Permalink to this headline">¶</a></h2>
<p>This chapter discusses performance and optimization when programming for AMD GPU compute devices that are part of the Southern Islands family, as well as CPUs and multiple devices. Details specific to the Evergreen and Northern Islands families of GPUs are provided in Chapter 2, “OpenCL Performance and Optimization for GCN Devices.”</p>
<div class="section" id="id18">
<h3>3.1 Global Memory Optimization<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>Figure 3.1 is a block diagram of the GPU memory system. The up arrows are read paths, the down arrows are write paths. WC is the write combine cache.</p>
<p>The GPU consists of multiple compute units. Each compute unit contains 32 kB local (on-chip) memory, L1 cache, registers, and 16 processing element (PE). Each processing element contains a five-way (or four-way, depending on the GPU type) VLIW processor. Individual work-items execute on a single processing element; one or more work-groups execute on a single compute unit. On a GPU, hardware schedules the work-items. On the ATI Radeon™ HD 5000 series of GPUs, hardware schedules groups of work-items, called wavefronts, onto stream cores; thus, work-items within a wavefront execute in lock-step; the same instruction is executed on different data.</p>
<p>The L1 cache is 8 kB per compute unit. (For the ATI Radeon™ HD 5870 GPU, this means 160 kB for the 20 compute units.) The L1 cache bandwidth on the ATI Radeon™ HD 5870 GPU is one terabyte per second:</p>
<blockquote>
<div>L1 Bandwidth = Compute Units * Wavefront Size/Compute Unit * EngineClock</div></blockquote>
<p>Multiple compute units share L2 caches.
The L2 cache size on the ATI Radeon™ HD 5870 GPUs is 512 kB:L2 Cache Size = Number or channels * L2 per Channel
The bandwidth between L1 caches and the shared L2 cache is 435 GB/s:</p>
<blockquote>
<div>L2 Bandwidth = Number of channels * Wavefront Size * Engine Clock</div></blockquote>
<img alt="../_images/3.1.png" src="../_images/3.1.png" />
<p><strong>Figure 3.1 Memory System</strong></p>
<p>The ATI Radeon™ HD 5870 GPU has eight memory controllers (“Memory Channel” in Figure 3.1). The memory controllers are connected to multiple banks of memory. The memory is GDDR5, with a clock speed of 1200 MHz and a data rate of 4800 Mb/pin. Each channel is 32-bits wide, so the peak bandwidth for the ATI Radeon™ HD 5870 GPU is: (8 memory controllers) * (4800 Mb/pin) * (32 bits) * (1 B/8b) = 154 GB/s</p>
<p>If two memory access requests are directed to the same controller, the hardware serializes the access. This is called a channel conflict. Similarly, if two memory access requests go to the same memory bank, hardware serializes the access. This is called a bank conflict. From a developer’s point of view, there is not much difference between channel and bank conflicts. A large power of two stride results in a channel conflict; a larger power of two stride results in a bank conflict. The size of the power of two stride that causes a specific type of conflict depends on the chip. A stride that results in a channel conflict on a machine with eight channels might result in a bank conflict on a machine with four.</p>
<p>In this document, the term bank conflict is used to refer to either kind of conflict.</p>
<div class="section" id="two-memory-paths">
<h4>3.1.1 Two Memory Paths<a class="headerlink" href="#two-memory-paths" title="Permalink to this headline">¶</a></h4>
<p>ATI Radeon™ HD 5000 series graphics processors have two, independent memory paths between the compute units and the memory:</p>
<ul class="simple">
<li>FastPath performs only basic operations, such as loads and stores (data sizes must be a multiple of 32 bits). This often is faster and preferred when there are no advanced operations.</li>
<li>CompletePath, supports additional advanced operations, including atomics and sub-32-bit (byte/short) data transfers.</li>
</ul>
<div class="section" id="performance-impact-of-fastpath-and-completepath">
<h5>3.1.1.1 Performance Impact of FastPath and CompletePath<a class="headerlink" href="#performance-impact-of-fastpath-and-completepath" title="Permalink to this headline">¶</a></h5>
<p>There is a large difference in performance on ATI Radeon™ HD 5000 series hardware between FastPath and CompletePath. Figure 3.2 shows two kernels (one FastPath, the other CompletePath) and the delivered DRAM bandwidth for each kernel on the ATI Radeon™ HD 5870 GPU. Note that an atomic add forces CompletePath.</p>
<img alt="../_images/3.2.png" src="../_images/3.2.png" />
<p><strong>Figure 3.2 FastPath (blue) vs CompletePath (red) Using float1</strong></p>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>UAVs allow compute shaders to store results in (or write results to) a buffer at any arbitrary location.On DX11 hardware, UAVs can be created from buffers and textures. On DX10 hardware, UAVs can- not be created from typed resources (textures). This is the same as a random access target (RAT).</td></tr>
</tbody>
</table>
<p>The kernel code follows. Note that the atomic extension must be enabled under OpenCL 1.0.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span> <span class="n">void</span>
<span class="n">CopyFastPath</span><span class="p">(</span>  <span class="k">global</span> <span class="n">const</span> <span class="nb">float</span> <span class="o">*</span> <span class="nb">input</span><span class="p">,</span>
  <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">output</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">gid</span><span class="p">];</span>
<span class="k">return</span> <span class="p">;</span>
<span class="p">}</span>
  <span class="n">kernel</span> <span class="n">void</span>
<span class="n">CopyComplete</span><span class="p">(</span>  <span class="k">global</span> <span class="n">const</span> <span class="nb">float</span> <span class="o">*</span> <span class="nb">input</span><span class="p">,</span>   <span class="k">global</span> <span class="nb">float</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">gid</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
<span class="n">atom_add</span><span class="p">((</span> <span class="k">global</span> <span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">output</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">output</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">gid</span><span class="p">];</span>
<span class="k">return</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Table 3.1 lists the effective bandwidth and ratio to maximum bandwidth.</p>
<p><strong>Table 3.1 Bandwidths for 1D Copies</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="31%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kernel</th>
<th class="head">EffectiveBandwidth</th>
<th class="head">Ratio to PeakBandwidth</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>copy 32-bit 1D FP</td>
<td>96 GB/s</td>
<td>3%</td>
</tr>
<tr class="row-odd"><td>copy 32-bit 1D CP</td>
<td>18 GB/s</td>
<td>12%</td>
</tr>
</tbody>
</table>
<p>The difference in performance between FastPath and CompletePath is significant. If your kernel uses CompletePath, consider if there is another way to approach the problem that uses FastPath. OpenCL read-only images always use FastPath.</p>
</div>
<div class="section" id="determining-the-used-path">
<h5>3.1.1.2  Determining The Used Path<a class="headerlink" href="#determining-the-used-path" title="Permalink to this headline">¶</a></h5>
<p>Since the path selection is done automatically by the OpenCL compiler, your kernel may be assigned to CompletePath. This section explains the strategy the compiler uses, and how to find out what path was used.</p>
<p>The compiler is conservative when it selects memory paths. The compiler often maps all user data into a single unordered access view (UAV),[1] so a single atomic operation (even one that is not executed) may force all loads and stores to use CompletePath.</p>
<p>The effective bandwidth listing above shows two OpenCL kernels and the associated performance. The first kernel uses the FastPath while the second uses the CompletePath. The second kernel is forced to CompletePath because in CopyComplete, the compiler noticed the use of an atomic.</p>
<p>There are two ways to find out which path is used. The first method uses the CodeXL GPU Profiler, which provides the following three performance counters for this purpose:</p>
<blockquote>
<div><ol class="arabic simple">
<li>FastPath counter: The total bytes written through the FastPath (no atomics,32-bit types only).</li>
<li>CompletePath counter: The total bytes read and written through the CompletePath (supports atomics and  non-32-bit types).</li>
<li>PathUtilization counter: The percentage of bytes read and written through the FastPath or CompletePath compared to the total number of bytes transferred over the bus.</li>
</ol>
</div></blockquote>
<p>The second method is static and lets you determine the path by looking at a machine-level ISA listing (using the AMD CodeXL Static Kernel Analyzer in OpenCL).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MEM_RAT_CACHELESS</span> <span class="o">-&gt;</span> <span class="n">FastPath</span>
<span class="n">MEM_RAT</span> <span class="o">-&gt;</span> <span class="n">CompPath</span>
<span class="n">MEM_RAT_NOP_RTN</span> <span class="o">-&gt;</span> <span class="n">Comp_load</span>
</pre></div>
</div>
<p>FastPath operations appear in the listing as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">TEX</span><span class="p">:</span> <span class="o">...</span>
<span class="o">...</span> <span class="n">VFETCH</span> <span class="o">...</span>
<span class="o">...</span> <span class="n">MEM_RAT_CACHELESS_STORE_RAW</span><span class="p">:</span> <span class="o">...</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">vfetch`</span> <span class="pre">Instruction</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">load</span> <span class="pre">type</span> <span class="pre">that</span> <span class="pre">in</span> <span class="pre">graphics</span> <span class="pre">terms</span> <span class="pre">is</span> <span class="pre">called</span> <span class="pre">vertex</span> <span class="pre">a</span> <span class="pre">fetch</span> <span class="pre">(the</span> <span class="pre">group</span> <span class="pre">control</span> <span class="pre">TEX</span> <span class="pre">indicates</span> <span class="pre">that</span> <span class="pre">the</span> <span class="pre">load</span> <span class="pre">uses</span> <span class="pre">the</span> <span class="pre">L1</span> <span class="pre">cache.)</span>
<span class="pre">The</span> <span class="pre">instruction</span> <span class="pre">``MEM_RAT_CACHELESS</span></code> indicates that FastPath operations are used. Loads in CompletePath are a split-phase operation. In the first phase, hardware copies the old value of a memory location into a special buffer. This is done by performing atomic operations on the memory location. After the value has reached the buffer, a normal load is used to read the value. Note that RAT stands for random access target, which is the same as an unordered access view (UAV); it allows, on DX11 hardware, writes to, and reads from, any arbitrary location in a buffer.</p>
<p>The listing shows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">MEM_RAT_NOP_RTN_ACK</span><span class="p">:</span> <span class="n">RAT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">..</span> <span class="n">WAIT_ACK</span><span class="p">:</span> <span class="n">Outstanding_acks</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="o">..</span> <span class="n">TEX</span><span class="p">:</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="n">CNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">..</span> <span class="n">VFETCH</span> <span class="o">...</span>
</pre></div>
</div>
<p>The instruction sequence means the following:</p>
<p><strong>MEM_RAT</strong> - Read into a buffer using CompletePath, do no operation on the memory location, and send an ACK when done.</p>
<p><strong>WAIT_ACK</strong> - Suspend execution of the wavefront until the ACK is received. If there is other work pending this might be free, but if there is no other work to be done this could take 100’s of cycles.</p>
<p><strong>TEX</strong> - Use the L1 cache for the next instruction.</p>
<p><strong>VFETCH</strong> - Do a load instruction to (finally) get the value.</p>
<p>Stores appear as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">..</span> <span class="n">MEM_RAT_STORE_RAW</span><span class="p">:</span> <span class="n">RAT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The instruction <code class="docutils literal notranslate"><span class="pre">MEM_RAT_STORE</span></code> is the store along the CompletePath. <code class="docutils literal notranslate"><span class="pre">MEM_RAT</span></code> means CompletePath; <code class="docutils literal notranslate"><span class="pre">MEM_RAT_CACHELESS</span></code> means FastPath.</p>
</div>
</div>
<div class="section" id="id20">
<h4>3.1.2 Channel Conflicts<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>The important concept is memory stride: the increment in memory address, measured in elements, between successive elements fetched or stored by consecutive work-items in a kernel. Many important kernels do not exclusively use simple stride one accessing patterns; instead, they feature large non-unit strides. For instance, many codes perform similar operations on each dimension of a two- or three-dimensional array. Performing computations on the low dimension can often be done with unit stride, but the strides of the computations in the other dimensions are typically large values. This can result in significantly degraded performance when the codes are ported unchanged to GPU systems. A CPU with caches presents the same problem, large power-of-two strides force data into only a few cache lines.</p>
<p>One solution is to rewrite the code to employ array transpositions between the kernels. This allows all computations to be done at unit stride. Ensure that the time required for the transposition is relatively small compared to the time to perform the kernel calculation.</p>
<p>For many kernels, the reduction in performance is sufficiently large that it is worthwhile to try to understand and solve this problem.</p>
<p>In GPU programming, it is best to have adjacent work-items read or write adjacent memory addresses. This is one way to avoid channel conflicts.</p>
<p>When the application has complete control of the access pattern and address generation, the developer must arrange the data structures to minimize bank conflicts. Accesses that differ in the lower bits can run in parallel; those that differ only in the upper bits can be serialized.</p>
<p>In this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">ptr</span><span class="o">=</span><span class="n">base</span><span class="p">;</span> <span class="n">ptr</span><span class="o">&lt;</span><span class="nb">max</span><span class="p">;</span> <span class="n">ptr</span> <span class="o">+=</span> <span class="mi">16</span><span class="n">KB</span><span class="p">)</span>
 <span class="n">R0</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">;</span>
</pre></div>
</div>
<p>where the lower bits are all the same, the memory requests all access the same bank on the same channel and are processed serially.</p>
<p>This is a low-performance pattern to be avoided. When the stride is a power of 2 (and larger than the channel interleave), the loop above only accesses one channel of memory.</p>
<p>The hardware byte address bits are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="34%" />
<col width="28%" />
<col width="28%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>31:x</td>
<td>bank</td>
<td>channel</td>
<td>7:0 address</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>On all ATI Radeon™ HD 5000-series GPUs, the lower eight bits select an element within a channel.</li>
<li>The next set of bits select the channel. The number of channel bits varies, since the number of channels is not the same on all parts. With eight channels, three bits are used to select the channel; with two channels, a single bit is used.</li>
<li>The next set of bits selects the memory bank. The number of bits used depends on the number of memory banks.</li>
<li>The remaining bits are the rest of the address.</li>
</ul>
<p>On the ATI Radeon™ HD 5870 GPU, the channel selection are bits 10:8 of the byte address. This means a linear burst switches channels every 256 bytes. Since the wavefront size is 64, channel conflicts are avoided if each work-item in a wave reads a different address from a 64-word region. All ATI Radeon™ HD 5000 series GPUs have the same layout: channel ends at bit 8, and the memory bank is to the left of the channel.</p>
<p>A burst of 2kB (8 * 256 bytes) cycles through all the channels.</p>
<p>When calculating an address as y*width+x, but reading a burst on a column (incrementing y), only one memory channel of the system is used, since the width is likely a multiple of 256 words = 2048 bytes. If the width is an odd multiple of 256B, then it cycles through all channels.</p>
<p>Similarly, the bank selection bits on the ATI Radeon™ HD 5870 GPU are bits 14:11, so the bank switches every 2 kB. A linear burst of 32 kB cycles through all banks and channels of the system. If accessing a 2D surface along a column, with a y*width+x calculation, and the width is some multiple of 2 kB dwords (32 kB), then only 1 bank and 1 channel are accessed of the 16 banks and 8 channels available on this GPU.</p>
<p>All ATI Radeon™ HD 5000-series GPUs have an interleave of 256 bytes (64 dwords).</p>
<p>If every work-item in a work-group references consecutive memory addresses and the address of work-item 0 is aligned to 256 bytes and each work-item fetches 32 bits, the entire wavefront accesses one channel. Although this seems slow, it actually is a fast pattern because it is necessary to consider the memory access over the entire device, not just a single wavefront.</p>
<p>One or more work-groups execute on each compute unit. On the ATI Radeon™ HD 5000-series GPUs, work-groups are dispatched in a linear order, with x changing most rapidly. For a single dimension, this is:</p>
<p><strong>DispatchOrder = get_group_id(0)</strong></p>
<p>For two dimensions, this is:</p>
<p><strong>DispatchOrder = get_group_id(0) + get_group_id(1) * get_num_groups(0)</strong></p>
<p>This is row-major-ordering of the blocks in the index space. Once all compute units are in use, additional work-groups are assigned to compute units as needed. Work-groups retire in order, so active work-groups are contiguous.</p>
<p>At any time, each compute unit is executing an instruction from a single wavefront. In memory intensive kernels, it is likely that the instruction is a memory access. Since there are eight channels on the ATI Radeon™ HD 5870 GPU, at most eight of the compute units can issue a memory access operation in one cycle. It is most efficient if the accesses from eight wavefronts go to different channels. One way to achieve this is for each wavefront to access consecutive groups of 256 = 64 * 4 bytes.</p>
<p>An inefficient access pattern is if each wavefront accesses all the channels. This is likely to happen if consecutive work-items access data that has a large power of two strides.</p>
<p>In the next example of a kernel for copying, the input and output buffers are interpreted as though they were 2D, and the work-group size is organized as 2D.</p>
<p>The kernel code is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define WIDTH 1024</span>
<span class="c1">#define DATA_TYPE float</span>
<span class="c1">#define A(y , x ) A[ (y) * WIDTH + (x ) ]</span>
<span class="c1">#define C(y , x ) C[ (y) * WIDTH+(x ) ]</span>
<span class="n">kernel</span> <span class="n">void</span> <span class="n">copy_float</span> <span class="p">(</span>  <span class="k">global</span> <span class="n">const</span>
<span class="n">DATA_TYPE</span> <span class="o">*</span> <span class="n">A</span><span class="p">,</span>
  <span class="k">global</span> <span class="n">DATA_TYPE</span><span class="o">*</span> <span class="n">C</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">idy</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">C</span><span class="p">(</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span> <span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By changing the width, the data type and the work-group dimensions, we get a set of kernels out of this code.</p>
<p>Given a 64x1 work-group size, each work-item reads a consecutive 32-bit address. Given a 1x64 work-group size, each work-item reads a value separated by the width in a power of two bytes.</p>
<p>Table 3.2 shows how much the launch dimension can affect performance. It lists each kernel’s effective bandwidth and ratio to maximum bandwidth.</p>
<p><strong>Table 3.2     Bandwidths for Different Launch Dimensions</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="32%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kernel</th>
<th class="head">Effective Bandwidth</th>
<th class="head">Ratio to Peak Bandwidth</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>copy 32-bit 1D FP</td>
<td>96 GB/s</td>
<td>63%</td>
</tr>
<tr class="row-odd"><td>copy 32-bit 1D CP</td>
<td>18 GB/s</td>
<td>12%</td>
</tr>
<tr class="row-even"><td>copy 32-bit 2D</td>
<td>.3 - 93 GB/s</td>
<td>0 - 60%</td>
</tr>
<tr class="row-odd"><td>copy 128-bit 2D</td>
<td>7 - 122 GB/s</td>
<td>5 - 80%</td>
</tr>
</tbody>
</table>
<p>To avoid power of two strides:</p>
<ul class="simple">
<li>Add an extra column to the data matrix.</li>
<li>Change the work-group size so that it is not a power of 21.</li>
<li>It is best to use a width that causes a rotation through all of the memory channels, instead of using the same one repeatedly.</li>
<li>Change the kernel to access the matrix with a staggered offset.</li>
</ul>
<div class="section" id="id21">
<h5>3.1.2.1 Staggered Offsets<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h5>
<p>Staggered offsets apply a coordinate transformation to the kernel so that the data is processed in a different order. Unlike adding a column, this technique does not use extra space. It is also relatively simple to add to existing code.</p>
<p>Figure 3.3 illustrates the transformation to staggered offsets.</p>
<img alt="../_images/3.3.png" src="../_images/3.3.png" />
<p><strong>Figure 3.3 Transformation to Staggered Offsets</strong></p>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Generally, it is not a good idea to make the work-group size something other than an integer multiple of the wavefront size, but that usually is less important than avoiding channel conflicts.</td></tr>
</tbody>
</table>
<p>The global ID values reflect the order that the hardware initiates work-groups. The values of get group ID are in ascending launch order.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">global_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The hardware launch order is fixed, but it is possible to change the launch order, as shown in the following example.</p>
<p>Assume a work-group size of k x k, where k is a power of two, and a large 2D matrix of size 2n x 2m in row-major order. If each work-group must process a block in column-order, the launch order does not work out correctly: consecutive work-groups execute down the columns, and the columns are a large power-of- two apart; so, consecutive work-groups access the same channel.</p>
<p>By introducing a transformation, it is possible to stagger the work-groups to avoid channel conflicts. Since we are executing 2D work-groups, each work group is identified by four numbers.
1.``get_group_id(0)`` - the x coordinate or the block within the column of the matrix.
2.``get_group_id(1)`` - the y coordinate or the block within the row of the matrix.
3.``get_global_id(0)`` - the x coordinate or the column of the matrix.
4.``get_global_id(1)`` - the y coordinate or the row of the matrix.</p>
<p>To transform the code, add the following four lines to the top of the kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">get_group_id_0</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">get_group_id_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">get_global_id_0</span> <span class="o">=</span> <span class="n">get_group_id_0</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">get_global_id_1</span> <span class="o">=</span> <span class="n">get_group_id_1</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, change the global IDs and group IDs to the staggered form. The result is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span> <span class="n">void</span>
<span class="n">copy_float</span> <span class="p">(</span>
 <span class="n">__global</span> <span class="n">const</span> <span class="n">DATA_TYPE</span> <span class="o">*</span> <span class="n">A</span><span class="p">,</span>
 <span class="n">__global</span> <span class="n">DATA_TYPE</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">size_t</span> <span class="n">get_group_id_0</span> <span class="o">=</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 <span class="n">size_t</span> <span class="n">get_group_id_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 <span class="n">size_t</span> <span class="n">get_global_id_0</span> <span class="o">=</span> <span class="n">get_group_id_0</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 <span class="n">size_t</span> <span class="n">get_global_id_1</span> <span class="o">=</span> <span class="n">get_group_id_1</span> <span class="o">*</span> <span class="n">get_local_size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
 <span class="nb">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_global_id_0</span><span class="p">;</span> <span class="o">//</span><span class="n">changed</span> <span class="n">to</span> <span class="n">staggered</span> <span class="n">form</span> <span class="nb">int</span> <span class="n">idy</span> <span class="o">=</span> <span class="n">get_global_id_1</span><span class="p">;</span> <span class="o">//</span><span class="n">changed</span> <span class="n">to</span> <span class="n">staggered</span> <span class="n">form</span>

 <span class="n">C</span><span class="p">(</span><span class="n">idy</span> <span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span> <span class="n">idy</span> <span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h5>3.1.2.2 Reads Of The Same Address<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h5>
<p>Under certain conditions, one unexpected case of a channel conflict is that reading from the same address is a conflict, even on the FastPath.</p>
<p>This does not happen on the read-only memories, such as constant buffers, textures, or shader resource view (SRV); but it is possible on the read/write UAV memory or OpenCL global memory.</p>
<p>From a hardware standpoint, reads from a fixed address have the same upper bits, so they collide and are serialized. To read in a single value, read the value
in a single work-item, place it in local memory, and then use that location:</p>
<dl class="docutils">
<dt><strong>Avoid:</strong></dt>
<dd><code class="docutils literal notranslate"><span class="pre">temp</span> <span class="pre">=</span> <span class="pre">input[3]</span> <span class="pre">//</span> <span class="pre">if</span> <span class="pre">input</span> <span class="pre">is</span> <span class="pre">from</span> <span class="pre">global</span> <span class="pre">space</span></code></dd>
<dt><strong>Use:</strong></dt>
<dd><blockquote class="first">
<div>if (get_local_id(0) == 0)
{
local = input[3]
}</div></blockquote>
<p class="last">barrier(CLK_LOCAL_MEM_FENCE);
temp = local</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="float4-or-float1">
<h4>3.1.3 Float4 Or Float1<a class="headerlink" href="#float4-or-float1" title="Permalink to this headline">¶</a></h4>
<p>The internal memory paths on ATI Radeon™ HD 5000-series devices support 128-bit transfers. This allows for greater bandwidth when transferring data in float4 format. In certain cases (when the data size is a multiple of four), float4 operations are faster.</p>
<p>The performance of these kernels can be seen in Figure 3.4. Change to float4 after eliminating the conflicts.</p>
<img alt="../_images/3.4.png" src="../_images/3.4.png" />
<p><strong>Figure 3.4 Two Kernels: One Using float4 (blue), the Other float1 (red)</strong></p>
<p>The following code example has two kernels, both of which can do a simple copy, but Copy4 uses float4 data types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">kernel</span> <span class="n">void</span>
<span class="n">Copy4</span><span class="p">(</span>  <span class="k">global</span> <span class="n">const</span> <span class="n">float4</span> <span class="o">*</span> <span class="nb">input</span><span class="p">,</span>
  <span class="k">global</span> <span class="n">float4</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">output</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">gid</span><span class="p">];</span>
<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
  <span class="n">kernel</span> <span class="n">void</span>
<span class="n">Copy1</span><span class="p">(</span>  <span class="k">global</span> <span class="n">const</span> <span class="nb">float</span> <span class="o">*</span> <span class="nb">input</span><span class="p">,</span>
  <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">output</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">gid</span><span class="p">];</span>
<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Copying data as float4 gives the best result: 84% of absolute peak. It also speeds up the 2D versions of the copy (see  Table 3.3).</p>
<p><strong>Table 3.3 Bandwidths Including float1 and float4</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="33%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kernel</th>
<th class="head">Effective Bandwidth</th>
<th class="head">Ratio to Peak Bandwidth</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>copy 32-bit 1D FP</td>
<td>96 GB/s</td>
<td>63%</td>
</tr>
<tr class="row-odd"><td>copy 32-bit 1D CP</td>
<td>18 GB/s</td>
<td>12%</td>
</tr>
<tr class="row-even"><td>copy 32-bit 2D</td>
<td>.3 - 93 GB/s</td>
<td>0 - 61%</td>
</tr>
<tr class="row-odd"><td>copy 128-bit 2D</td>
<td>7 - 122 GB/s</td>
<td>5 - 80%</td>
</tr>
<tr class="row-even"><td>copy4 float4 1D FP</td>
<td>127 GB/s</td>
<td>83%</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id24">
<h4>3.1.4 Coalesced Writes<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>On some other vendor devices, it is important to reorder your data to use coalesced writes. The ATI Radeon™ HD 5000-series devices also support coalesced writes, but this optimization is less important than other considerations, such as avoiding bank conflicts.</p>
<p>In non-coalesced writes, each compute unit accesses the memory system in quarter-wavefront units. The compute unit transfers a 32-bit address and one element-sized piece of data for each work-item. This results in a total of 16 elements + 16 addresses per quarter-wavefront. On ATI Radeon™ HD 5000-series devices, processing quarter-wavefront requires two cycles before the data is transferred to the memory controller.</p>
<p>In coalesced writes, the compute unit transfers one 32-bit address and 16 element-sized pieces of data for each quarter-wavefront, for a total of 16 elements +1 address per quarter-wavefront. For coalesced writes, processing quarter-wavefront takes one cycle instead of two. While this is twice as fast, the times are small compared to the rate the memory controller can handle the data. See Figure 3.5.</p>
<p>On ATI Radeon™ HD 5000-series devices, the coalescing is only done on the FastPath because it supports only 32-bit access.</p>
<p>If a work-item does not write, coalesce detection ignores it.</p>
<p>The first kernel Copy1 maximizes coalesced writes: work-item k writes to address k. The second kernel writes a shifted pattern: In each quarter-wavefront of 16 work-items, work-item k writes to address k-1, except the first work-item in each quarter-wavefront writes to address k+16. There is not enough order here to coalesce on some other vendor machines. Finally, the third kernel has work-item k write to address k when k is even, and write address 63-k when k is odd. This pattern never coalesces.</p>
<img alt="../_images/3.5.png" src="../_images/3.5.png" />
<p><strong>Figure 3.5 Effect of Varying Degrees of Coalescing - Coal (blue), NoCoal red), Split (green)</strong></p>
<p>Write coalescing can be an important factor for AMD GPUs.</p>
<p>The following are sample kernels with different coalescing patterns.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">best</span> <span class="n">access</span> <span class="n">pattern</span>
  <span class="n">kernel</span> <span class="n">void</span>
<span class="n">Copy1</span><span class="p">(</span>  <span class="k">global</span> <span class="n">const</span> <span class="nb">float</span> <span class="o">*</span> <span class="nb">input</span><span class="p">,</span>   <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">uint</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">output</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">gid</span><span class="p">];</span> <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


  <span class="n">kernel</span> <span class="n">void</span> <span class="n">NoCoal</span> <span class="p">(</span>  <span class="k">global</span> <span class="n">const</span> <span class="nb">float</span> <span class="o">*</span> <span class="nb">input</span><span class="p">,</span>
  <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="o">//</span> <span class="p">(</span><span class="n">shift</span> <span class="n">by</span> <span class="mi">16</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">if</span><span class="p">((</span><span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">gid</span> <span class="o">=</span> <span class="n">gid</span> <span class="o">+</span><span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">gid</span><span class="p">];</span>
<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
  <span class="n">kernel</span> <span class="n">void</span>
<span class="o">//</span> <span class="n">inefficient</span> <span class="n">pattern</span>
<span class="n">Split</span> <span class="p">(</span> <span class="k">global</span> <span class="n">const</span> <span class="nb">float</span> <span class="o">*</span> <span class="nb">input</span><span class="p">,</span>   <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
<span class="nb">int</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span><span class="p">((</span><span class="n">gid</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="n">gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Ëœ63</span><span class="p">))</span> <span class="o">+</span><span class="mi">62</span> <span class="o">-</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">output</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">gid</span><span class="p">];</span>
<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Table 3.4 lists the effective bandwidth and ratio to maximum bandwidth for each kernel type.</p>
<p><strong>Table 3.4 Bandwidths Including Coalesced Writes</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="35%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kernel</th>
<th class="head">Effective Bandwidth</th>
<th class="head">Ratio to Peak Bandwidth</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>copy 32-bit 1D FP</td>
<td>96 GB/s</td>
<td>63%</td>
</tr>
<tr class="row-odd"><td>copy 32-bit 1D CP</td>
<td>18 GB/s</td>
<td>12%</td>
</tr>
<tr class="row-even"><td>copy 32-bit 2D</td>
<td>.3 - 93 GB/s</td>
<td>0 - 61%</td>
</tr>
<tr class="row-odd"><td>copy 128-bit 2D</td>
<td>7 - 122 GB/s</td>
<td>5 - 80%</td>
</tr>
<tr class="row-even"><td>copy4 float4 1D FP</td>
<td>127 GB/s</td>
<td>83%</td>
</tr>
<tr class="row-odd"><td>Coal 32-bit</td>
<td>97 GB/s</td>
<td>63%</td>
</tr>
<tr class="row-even"><td>NoCoal 32-bit</td>
<td>93 GB/s</td>
<td>61%</td>
</tr>
<tr class="row-odd"><td>Split 32-bit</td>
<td>90 GB/s</td>
<td>59%</td>
</tr>
</tbody>
</table>
<p>There is not much performance difference, although the coalesced version is slightly faster.</p>
</div>
<div class="section" id="alignment">
<h4>3.1.5 Alignment<a class="headerlink" href="#alignment" title="Permalink to this headline">¶</a></h4>
<p>The program in Figure 3.6 shows how the performance of a simple, unaligned access (float1) of this kernel varies as the size of offset varies. Each transfer was large (16 MB). The performance gain by adjusting alignment is small, so generally this is not an important consideration on AMD GPUs.</p>
<img alt="../_images/3.6.png" src="../_images/3.6.png" />
<p><strong>Figure 3.6 Unaligned Access Using float1</strong></p>
<dl class="docutils">
<dt>::</dt>
<dd><blockquote class="first">
<div>__kernel void
CopyAdd(global const float * input,
__global float * output,</div></blockquote>
<p class="last">const int offset)
{
int gid = get_global_id(0)+ offset;
output[gid] = input[gid];
return;
}</p>
</dd>
</dl>
<p>Table 3.5 lists the effective bandwidth and ratio to maximum bandwidth for each kernel type.</p>
<p><strong>Table 3.5 Bandwidths Including Unaligned Access</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="35%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kernel</th>
<th class="head">Effective Bandwidth</th>
<th class="head">Ratio to Peak Bandwidth</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>copy 32-bit 1D FP</td>
<td>96 GB/s</td>
<td>63%</td>
</tr>
<tr class="row-odd"><td>copy 32-bit 1D CP</td>
<td>18 GB/s</td>
<td>12%</td>
</tr>
<tr class="row-even"><td>copy 32-bit 2D</td>
<td>.3 - 93 GB/s</td>
<td>0 - 61%</td>
</tr>
<tr class="row-odd"><td>copy 128-bit 2D</td>
<td>7 - 122 GB/s</td>
<td>5 - 80%</td>
</tr>
<tr class="row-even"><td>copy4 float4 1D FP</td>
<td>127 GB/s</td>
<td>83%</td>
</tr>
<tr class="row-odd"><td>Coal</td>
<td>97</td>
<td>63%</td>
</tr>
<tr class="row-even"><td>NoCoal 32-bit</td>
<td>90 GB/s</td>
<td>59%</td>
</tr>
<tr class="row-odd"><td>Split 32-bit</td>
<td>90 GB/s</td>
<td>59%</td>
</tr>
<tr class="row-even"><td>CopyAdd 32-bit</td>
<td>92 GB/s</td>
<td>60%</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="summary-of-copy-performance">
<h4>3.1.6 Summary of Copy Performance<a class="headerlink" href="#summary-of-copy-performance" title="Permalink to this headline">¶</a></h4>
<p>The performance of a copy can vary greatly, depending on how the code is written. The measured bandwidth for these copies varies from a low of 0.3 GB/s, to a high of 127 GB/s.</p>
<p>The recommended order of steps to improve performance is:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Examine the code to ensure you are using FastPath, not CompletePath, everywhere possible. Check carefully to see if you are minimizing the number of kernels that use CompletePath operations. You might be able to use textures, image-objects, or constant buffers to help.</li>
<li>Examine the data-set sizes and launch dimensions to see if you can eliminate bank conflicts.</li>
<li>Try to use float4 instead of float1.</li>
<li>Try to change the access pattern to allow write coalescing. This is important on some hardware platforms, but only of limited importance for AMD GPU devices.</li>
<li>Finally, look at changing the access pattern to allow data alignment.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="id25">
<h3>3.2 Local Memory (LDS) Optimization<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>AMD Evergreen GPUs include a Local Data Store (LDS) cache, which accelerates local memory accesses. LDS is not supported in OpenCL on AMD R700-family GPUs. LDS provides high-bandwidth access (more than 10X higher than global memory), efficient data transfers between work-items in a work- group, and high-performance atomic support. Local memory offers significant advantages when the data is re-used; for example, subsequent accesses can read from local memory, thus reducing global memory bandwidth. Another advantage is that local memory does not require coalescing.</p>
<p>To determine local memory size:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clGetDeviceInfo</span><span class="p">(</span> <span class="o">...</span><span class="p">,</span> <span class="n">CL_DEVICE_LOCAL_MEM_SIZE</span><span class="p">,</span> <span class="o">...</span> <span class="p">);</span>
</pre></div>
</div>
<p>All AMD Evergreen GPUs contain a 32K LDS for each compute unit. On high- end GPUs, the LDS contains 32-banks, each bank is four bytes wide and 256 bytes deep; the bank address is determined by bits 6:2 in the address. On lower- end GPUs, the LDS contains 16 banks, each bank is still 4 bytes in size, and the bank used is determined by bits 5:2 in the address. As shown below, programmers should carefully control the bank bits to avoid bank conflicts as much as possible.</p>
<p>In a single cycle, local memory can service a request for each bank (up to 32 accesses each cycle on the ATI Radeon™ HD 5870 GPU). For an ATI Radeon™ HD 5870 GPU, this delivers a memory bandwidth of over 100 GB/s for each compute unit, and more than 2 TB/s for the whole chip. This is more than 14X the global memory bandwidth. However, accesses that map to the same bank are serialized and serviced on consecutive cycles. A wavefront that generates bank conflicts stalls on the compute unit until all LDS accesses have completed. The GPU reprocesses the wavefront on subsequent cycles, enabling only the lanes receiving data, until all the conflicting accesses complete. The bank with the most conflicting accesses determines the latency for the wavefront to complete the local memory operation. The worst case occurs when all 64 work- items map to the same bank, since each access then is serviced at a rate of one per clock cycle; this case takes 64 cycles to complete the local memory access for the wavefront. A program with a large number of bank conflicts (as measured by the LDSBankConflict performance counter) might benefit from using the constant or image memory rather than LDS.</p>
<p>Thus, the key to effectively using the local cache memory is to control the access pattern so that accesses generated on the same cycle map to different banks in the local memory. One notable exception is that accesses to the same address (even though they have the same bits 6:2) can be broadcast to all requestors and do not generate a bank conflict. The LDS hardware examines the requests generated over two cycles (32 work-items of execution) for bank conflicts. Ensure, as much as possible, that the memory requests generated from a quarter-wavefront avoid bank conflicts by using unique address bits 6:2. A simple sequential address pattern, where each work-item reads a float2 value from LDS, generates a conflict-free access pattern on the ATI Radeon™ HD 5870 GPU. Note that a sequential access pattern, where each work-item reads a float4 value from LDS, uses only half the banks on each cycle on the ATI Radeon™ HD 5870 GPU and delivers half the performance of the float access pattern.</p>
<p>Each stream processor can generate up to two 4-byte LDS requests per cycle. Byte and short reads consume four bytes of LDS bandwidth. Since each stream processor can execute five operations (or four, depending on the GPU type) in the VLIW each cycle (typically requiring 10-15 input operands), two local memory requests might not provide enough bandwidth to service the entire instruction. Developers can use the large register file: each compute unit has 256 kB of register space available (8X the LDS size) and can provide up to twelve 4-byte values/cycle (6X the LDS bandwidth). Registers do not offer the same indexing flexibility as does the LDS, but for some algorithms this can be overcome with loop unrolling and explicit addressing.</p>
<p>LDS reads require one ALU operation to initiate them. Each operation can initiate two loads of up to four bytes each.</p>
<dl class="docutils">
<dt>The CodeXL GPU Profiler provides the following performance counter to help optimize local memory usage:</dt>
<dd><strong>LDSBankConflict :</strong> The percentage of time accesses to the LDS are stalled due to bank conflicts relative to GPU Time. In the ideal case, there are no bank conflicts in the local memory access, and this number is zero.</dd>
</dl>
<p>Local memory is software-controlled “scratchpad” memory. In contrast, caches typically used on CPUs monitor the access stream and automatically capture recent accesses in a tagged cache. The scratchpad allows the kernel to explicitly load items into the memory; they exist in local memory until the kernel replaces them, or until the work-group ends. To declare a block of local memory, use the <code class="docutils literal notranslate"><span class="pre">__local</span></code> keyword; for example: <code class="docutils literal notranslate"><span class="pre">__local</span> <span class="pre">float</span> <span class="pre">localBuffer[64]</span></code></p>
<p>These declarations can be either in the parameters to the kernel call or in the body of the kernel. The <code class="docutils literal notranslate"><span class="pre">__local</span></code> syntax allocates a single block of memory, which is shared across all work-items in the workgroup.</p>
<p>To write data into local memory, write it into an array allocated with <code class="docutils literal notranslate"><span class="pre">__local</span></code>. For example: <code class="docutils literal notranslate"><span class="pre">localBuffer[i]</span> <span class="pre">=</span> <span class="pre">5.0;</span></code></p>
<p>A typical access pattern is for each work-item to collaboratively write to the local memory: each work-item writes a subsection, and as the work-items execute in parallel they write the entire array. Combined with proper consideration for the access pattern and bank alignment, these collaborative write approaches can lead to highly efficient memory accessing. Local memory is consistent across work-items only at a work-group barrier; thus, before reading the values written collaboratively, the kernel must include a <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> instruction.</p>
<p>The following example is a simple kernel section that collaboratively writes, then reads from, local memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span> <span class="n">void</span> <span class="n">localMemoryExample</span> <span class="p">(</span>  <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span><span class="n">In</span><span class="p">,</span>  <span class="k">global</span> <span class="nb">float</span> <span class="o">*</span><span class="n">Out</span><span class="p">)</span> <span class="p">{</span>
<span class="n">__local</span> <span class="nb">float</span> <span class="n">localBuffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="n">uint</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">get_local_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">uint</span> <span class="n">gx</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Initialize</span> <span class="n">local</span> <span class="n">memory</span><span class="p">:</span>
<span class="o">//</span> <span class="n">Copy</span> <span class="kn">from</span> <span class="nn">this</span> <span class="n">work</span><span class="o">-</span><span class="n">group</span><span class="s1">&#39;s section of global memory to local:</span>
<span class="o">//</span> <span class="n">Each</span> <span class="n">work</span><span class="o">-</span><span class="n">item</span> <span class="n">writes</span> <span class="n">one</span> <span class="n">element</span><span class="p">;</span> <span class="n">together</span> <span class="n">they</span> <span class="n">write</span> <span class="n">it</span> <span class="nb">all</span>
<span class="n">localBuffer</span><span class="p">[</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">In</span><span class="p">[</span><span class="n">gx</span><span class="p">];</span>

<span class="o">//</span> <span class="n">Ensure</span> <span class="n">writes</span> <span class="n">have</span> <span class="n">completed</span><span class="p">:</span>
<span class="n">barrier</span><span class="p">(</span><span class="n">CLK_LOCAL_MEM_FENCE</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Toy</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">a</span> <span class="n">partial</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">shows</span> <span class="n">re</span><span class="o">-</span><span class="n">use</span> <span class="kn">from</span> <span class="nn">local</span> <span class="nb">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">localBuffer</span><span class="p">[</span><span class="n">tx</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span><span class="o">=</span><span class="n">tx</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="n">f</span> <span class="o">*=</span> <span class="n">localBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">Out</span><span class="p">[</span><span class="n">gx</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the host code cannot read from, or write to, local memory. Only the kernel can access local memory.</p>
</div>
<p>Local memory is consistent across work-items only at a work-group barrier; thus, before reading the values written collaboratively, the kernel must include a <code class="docutils literal notranslate"><span class="pre">barrier()</span></code> instruction. An important optimization is the case where the local work-group size is less than, or equal to, the wavefront size. Because the wavefront executes as an atomic unit, the explicit barrier operation is not required. The compiler automatically removes these barriers if the kernel specifies a <code class="docutils literal notranslate"><span class="pre">reqd_work_group_size</span></code></p>
<p>(see section 5.8 of the OpenCL Specification) that is less than the wavefront size. Developers are strongly encouraged to include the barriers where appropriate, and rely on the compiler to remove the barriers when possible, rather than manually removing the <code class="docutils literal notranslate"><span class="pre">barriers()</span></code>. This technique results in more portable code, including the ability to run kernels on CPU devices.</p>
</div>
<div class="section" id="id26">
<h3>3.3 Constant Memory Optimization<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>The AMD implementation of OpenCL provides three levels of performance for the “constant” memory type.</p>
<ol class="arabic simple">
<li>Simple Direct-Addressing Patterns</li>
</ol>
<blockquote>
<div>Very high bandwidth can be attained when the compiler has available the constant address at compile time and can embed the constant address into the instruction. Each processing element can load up to 4x4-byte direct- addressed constant values each cycle. Typically, these cases are limited to simple non-array constants and function parameters. The GPU loads the constants into a hardware cache at the beginning of the clause that uses the constants. The cache is a tagged cache, typically each 8k blocks is shared among four compute units. If the constant data is already present in the constant cache, the load is serviced by the cache and does not require any global memory bandwidth. The constant cache size for each device varies from 4k to 48k per GPU.</div></blockquote>
<ol class="arabic simple" start="2">
<li>Same Index</li>
</ol>
<blockquote>
<div>Hardware acceleration also takes place when all work-items in a wavefront reference the same constant address. In this case, the data is loaded from memory one time, stored in the L1 cache, and then broadcast to all wave- fronts. This can reduce significantly the required memory bandwidth.</div></blockquote>
<ol class="arabic simple" start="3">
<li>Varying Index</li>
</ol>
<blockquote>
<div>More sophisticated addressing patterns, including the case where each work- item accesses different indices, are not hardware accelerated and deliver the same performance as a global memory read with the potential for cache hits.</div></blockquote>
<p>To further improve the performance of the AMD OpenCL stack, two methods allow users to take advantage of hardware constant buffers. These are:</p>
<ol class="arabic simple">
<li>Globally scoped constant arrays. These arrays are initialized, globally scoped, and in the constant address space (as specified in section 6.5.3 of the OpenCL specification). If the size of an array is below 64 kB, it is placed in hardware constant buffers; otherwise, it uses global memory. An example of this is a lookup table for math functions.</li>
<li>Per-pointer attribute specifying the maximum pointer size. This is specified using the max_constant_size(N) attribute. The attribute form conforms to section 6.10 of the OpenCL 1.0 specification. This attribute is restricted to top-level kernel function arguments in the constant address space. This restriction prevents a pointer of one size from being passed as an argument to a function that declares a different size. It informs the compiler that indices into the pointer remain inside this range and it is safe to allocate a constant buffer in hardware, if it fits. Using a constant pointer that goes outside of this range results in undefined behavior. All allocations are aligned on the 16-byte boundary.</li>
</ol>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kernel</span> <span class="n">void</span> <span class="n">mykernel</span><span class="p">(</span><span class="k">global</span> <span class="nb">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span>
<span class="n">constant</span> <span class="nb">int</span><span class="o">*</span> <span class="n">b</span>   <span class="n">attribute__</span><span class="p">((</span><span class="n">max_constant_size</span> <span class="p">(</span><span class="mi">65536</span><span class="p">)))</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="n">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="mh">0x3FFF</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A kernel that uses constant buffers must use CL_DEVICE_MAX_CONSTANT_ARGS to query the device for the maximum number of constant buffers the kernel can support. This value might differ from the maximum number of hardware constant buffers available. In this case, if the number of hardware constant buffers is less than the CL_DEVICE_MAX_CONSTANT_ARGS, the compiler allocates the largest constant buffers in hardware first and allocates the rest of the constant buffers in global memory. As an optimization, if a constant pointer <strong>A</strong> uses n bytes of memory, where n is less than 64 kB, and constant pointer <strong>B</strong> uses m bytes of memory, where m is less than (64 kB - n) bytes of memory, the compiler can allocate the constant buffer pointers in a single hardware constant buffer. This optimization can be applied recursively by treating the resulting allocation as a single allocation and finding the next smallest constant pointer that fits within the space left in the constant buffer.</p>
</div>
<div class="section" id="id27">
<h3>3.4 OpenCL Memory Resources: Capacity and Performance<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>Table 3.6 summarizes the hardware capacity and associated performance for the structures associated with the five OpenCL Memory Types. This information
specific to the ATI Radeon™ HD5870 GPUs with 1 GB video memory.</p>
<p><strong>Table 3.6 Hardware Performance Parameters</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="27%" />
<col width="9%" />
<col width="10%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">OpenCL Memory Type</th>
<th class="head">Hardware Resource</th>
<th class="head">Size/CU</th>
<th class="head">Size/GPU</th>
<th class="head">Peak Read Bandwidth/ Stream Core</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Private</td>
<td>GPRs</td>
<td>256k</td>
<td>5120k</td>
<td>48 bytes/cycle</td>
</tr>
<tr class="row-odd"><td>Local</td>
<td>LDS</td>
<td>32k</td>
<td>640k</td>
<td>8 bytes/cycle</td>
</tr>
<tr class="row-even"><td rowspan="3">Constant</td>
<td>Direct-addressed constant</td>
<td rowspan="3">&#160;</td>
<td>48k</td>
<td>16 bytes/cycle</td>
</tr>
<tr class="row-odd"><td>Same-indexed constant</td>
<td>&#160;</td>
<td>4 bytes/cycle</td>
</tr>
<tr class="row-even"><td>Varying-indexed constant</td>
<td>&#160;</td>
<td>~0.6 bytes/cycle</td>
</tr>
<tr class="row-odd"><td rowspan="2">Images</td>
<td>L1 Cache</td>
<td>8k</td>
<td>160k</td>
<td>4 bytes/cycle</td>
</tr>
<tr class="row-even"><td>L2 Cache</td>
<td>&#160;</td>
<td>512k</td>
<td>~1.6 bytes/cycle</td>
</tr>
<tr class="row-odd"><td>Global</td>
<td>Global Memory</td>
<td>&#160;</td>
<td>1G</td>
<td>~0.6 bytes/cycle</td>
</tr>
</tbody>
</table>
<p>The compiler tries to map private memory allocations to the pool of GPRs in the GPU. In the event GPRs are not available, private memory is mapped to the “scratch” region, which has the same performance as global memory. Section 3.6.2, “Resource Limits on Active Wavefronts”, has more information on register allocation and identifying when the compiler uses the scratch region. GPRs provide the highest-bandwidth access of any hardware resource. In addition to reading up to 48 bytes/cycle from the register file, the hardware can access results produced in the previous cycle (through the Previous Vector/Previous Scalar register) without consuming any register file bandwidth. GPRs have some restrictions about which register ports can be read on each cycle; but generally, these are not exposed to the OpenCL programmer.</p>
<p>Same-indexed constants can be cached in the L1 and L2 cache. Note that “same-indexed” refers to the case where all work-items in the wavefront reference the same constant index on the same cycle. The performance shown assumes an L1 cache hit.</p>
<p>Varying-indexed constants use the same path as global memory access and are subject to the same bank and alignment constraints described in Section 3.1, “Global Memory Optimization”.</p>
<p>The L1 and L2 caches are currently only enabled for images and same-indexed constants. Read only buffers can be cached in L1 and L2. To enable this, the developer must indicate to the compiler that the buffer is read only and does not alias with other buffers. For example, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kernel</span> <span class="n">void</span> <span class="n">mykernel</span><span class="p">(</span>  <span class="k">global</span> <span class="nb">int</span> <span class="n">const</span> <span class="o">*</span> <span class="n">restrict</span> <span class="n">mypointerName</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">const</span></code> indicates to the compiler that mypointerName is read only from the kernel, and the <code class="docutils literal notranslate"><span class="pre">restrict</span></code> attribute indicates to the compiler that no other pointer aliases with <code class="docutils literal notranslate"><span class="pre">mypointerName</span></code>.</p>
<p>The L1 cache can service up to four address request per cycle, each delivering up to 16 bytes. The bandwidth shown assumes an access size of 16 bytes; smaller access sizes/requests result in a lower peak bandwidth for the L1 cache. Using float4 with images increases the request size and can deliver higher L1 cache bandwidth.</p>
<p>Each memory channel on the GPU contains an L2 cache that can deliver up to 64 bytes/cycle. The ATI Radeon™ HD 5870 GPU has eight memory channels; thus, it can deliver up to 512bytes/cycle; divided among 320 stream cores, this provides up to ~1.6 bytes/cycle for each stream core.</p>
<p>Global Memory bandwidth is limited by external pins, not internal bus bandwidth. The ATI Radeon™ HD 5870 GPU supports up to 153 GB/s of memory bandwidth which is an average of 0.6 bytes/cycle for each stream core.</p>
<p>Note that Table 3.6 shows the performance for the ATI Radeon™ HD 5870 GPU. The “Size/Compute Unit” column and many of the bandwidths/processing element apply to all Evergreen-class GPUs; however, the “Size/GPU” column and the bandwidths for varying-indexed constant, L2, and global memory vary across different GPU devices.</p>
</div>
<div class="section" id="id28">
<h3>3.5 Using LDS or L1 Cache<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>There are a number of considerations when deciding between LDS and L1 cache for a given algorithm.</p>
<p>LDS supports read/modify/write operations, as well as atomics. It is well-suited for code that requires fast read/write, read/modify/write, or scatter operations that otherwise are directed to global memory. On current AMD hardware, L1 is part of the read path; hence, it is suited to cache-read-sensitive algorithms, such as matrix multiplication or convolution.</p>
<p>LDS is typically larger than L1 (for example: 32 kB vs 8 kB on Cypress). If it is not possible to obtain a high L1 cache hit rate for an algorithm, the larger LDS size can help. The theoretical LDS peak bandwidth is 2 TB/s, compared to L1 at 1 TB/sec. Currently, OpenCL is limited to 1 TB/sec LDS bandwidth.</p>
<p>The native data type for L1 is a four-vector of 32-bit words. On L1, fill and read addressing are linked. It is important that L1 is initially filled from global memory with a coalesced access pattern; once filled, random accesses come at no extra processing cost.</p>
<p>Currently, the native format of LDS is a 32-bit word. The theoretical LDS peak bandwidth is achieved when each thread operates on a two-vector of 32-bit words (16 threads per clock operate on 32 banks). If an algorithm requires coalesced 32-bit quantities, it maps well to LDS. The use of four-vectors or larger can lead to bank conflicts.</p>
<p>From an application point of view, filling LDS from global memory, and reading from it, are independent operations that can use independent addressing. Thus, LDS can be used to explicitly convert a scattered access pattern to a coalesced pattern for read and write to global memory. Or, by taking advantage of the LDS read broadcast feature, LDS can be filled with a coalesced pattern from global memory, followed by all threads iterating through the same LDS words simultaneously.</p>
<p>LDS is shared between the work-items in a work-group. Sharing across work- groups is not possible because OpenCL does not guarantee that LDS is in a particular state at the beginning of work-group execution. L1 content, on the other hand, is independent of work-group execution, so that successive work-groups can share the content in the L1 cache of a given Vector ALU. However, it currently is not possible to explicitly control L1 sharing across work-groups.</p>
<p>The use of LDS is linked to GPR usage and wavefront-per-Vector ALU count. Better sharing efficiency requires a larger work-group, so that more work items share the same LDS. Compiling kernels for larger work groups typically results in increased register use, so that fewer wavefronts can be scheduled simultaneously per Vector ALU. This, in turn, reduces memory latency hiding. Requesting larger amounts of LDS per work-group results in fewer wavefronts per Vector ALU, with the same effect.</p>
<p>LDS typically involves the use of barriers, with a potential performance impact. This is true even for read-only use cases, as LDS must be explicitly filled in from global memory (after which a barrier is required before reads can commence).</p>
</div>
<div class="section" id="id29">
<h3>3.6 NDRange and Execution Range Optimization<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>Probably the most effective way to exploit the potential performance of the GPU is to provide enough threads to keep the device completely busy. The programmer specifies a three-dimensional NDRange over which to execute the kernel; bigger problems with larger NDRanges certainly help to more effectively use the machine. The programmer also controls how the global NDRange is divided into local ranges, as well as how much work is done in each work-item, and which resources (registers and local memory) are used by the kernel. All of these can play a role in how the work is balanced across the machine and how well it is used. This section introduces the concept of latency hiding, how many wavefronts are required to hide latency on AMD GPUs, how the resource usage in the kernel can impact the active wavefronts, and how to choose appropriate global and local work-group dimensions.</p>
<div class="section" id="hiding-alu-and-memory-latency">
<h4>3.6.1 Hiding ALU and Memory Latency<a class="headerlink" href="#hiding-alu-and-memory-latency" title="Permalink to this headline">¶</a></h4>
<p>The read-after-write latency for most arithmetic operations (a floating-point add, for example) is only eight cycles. For most AMD GPUs, each compute unit can execute 16 VLIW instructions on each cycle. Each wavefront consists of 64 work- items; each compute unit executes a quarter-wavefront on each cycle, and the entire wavefront is executed in four consecutive cycles. Thus, to hide eight cycles of latency, the program must schedule two wavefronts. The compute unit executes the first wavefront on four consecutive cycles; it then immediately switches and executes the other wavefront for four cycles. Eight cycles have elapsed, and the ALU result from the first wavefront is ready, so the compute unit can switch back to the first wavefront and continue execution. Compute units running two wavefronts (128 threads) completely hide the ALU pipeline latency.</p>
<p>Global memory reads generate a reference to the off-chip memory and experience a latency of 300 to 600 cycles. The wavefront that generates the global memory access is made idle until the memory request completes. During this time, the compute unit can process other independent wavefronts, if they are available.</p>
<p>Kernel execution time also plays a role in hiding memory latency: longer kernels keep the functional units busy and effectively hide more latency. To better understand this concept, consider a global memory access which takes 400 cycles to execute. Assume the compute unit contains many other wavefronts, each of which performs five ALU instructions before generating another global memory reference. As discussed previously, the hardware executes each instruction in the wavefront in four cycles; thus, all five instructions occupy the ALU for 20 cycles. Note the compute unit interleaves two of these wavefronts and executes the five instructions from both wavefronts (10 total instructions) in 40 cycles. To fully hide the 400 cycles of latency, the compute unit requires (400/40) = 10 pairs of wavefronts, or 20 total wavefronts. If the wavefront contains 10 instructions rather than 5, the wavefront pair would consume 80 cycles of latency, and only 10 wavefronts would be required to hide the 400 cycles of latency.</p>
<p>Generally, it is not possible to predict how the compute unit schedules the available wavefronts, and thus it is not useful to try to predict exactly which ALU block executes when trying to hide latency. Instead, consider the overall ratio of ALU operations to fetch operations - this metric is reported by the CodeXL GPU Profiler in the <code class="docutils literal notranslate"><span class="pre">ALUFetchRatio</span></code> counter. Each ALU operation keeps the compute unit busy for four cycles, so you can roughly divide 500 cycles of latency by `` (4*ALUFetchRatio)`` to determine how many wavefronts must be in-flight to hide that latency. Additionally, a low value for the <code class="docutils literal notranslate"><span class="pre">ALUBusy</span></code> performance counter can indicate that the compute unit is not providing enough wavefronts to keep the execution resources in full use. (This counter also can be low if the kernel exhausts the available DRAM bandwidth. In this case, generating more wavefronts does not improve performance; it can reduce performance by creating more contention.)</p>
<p>Increasing the wavefronts/compute unit does not indefinitely improve performance; once the GPU has enough wavefronts to hide latency, additional active wavefronts provide little or no performance benefit. A closely related metric to wavefronts/compute unit is “occupancy,” which is defined as the ratio of active wavefronts to the maximum number of possible wavefronts supported by the hardware. Many of the important optimization targets and resource limits are expressed in wavefronts/compute units, so this section uses this metric rather than the related “occupancy” term.</p>
</div>
<div class="section" id="id30">
<h4>3.6.2 Resource Limits on Active Wavefronts<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<p>AMD GPUs have two important global resource constraints that limit the number of in-flight wavefronts:</p>
<ul class="simple">
<li>Each compute unit supports a maximum of eight work-groups. Recall that AMD OpenCL supports up to 256 work-items (four wavefronts) per work- group; effectively, this means each compute unit can support up to 32 wavefronts.</li>
<li>Each GPU has a global (across all compute units) limit on the number of active wavefronts. The GPU hardware is generally effective at balancing the load across available compute units. Thus, it is useful to convert this global limit into an average wavefront/compute unit so that it can be compared to the other limits discussed in this section. For example, the ATI Radeon™ HD 5870 GPU has a global limit of 496 wavefronts, shared among 20 compute units. Thus, it supports an average of 24.8 wavefronts/compute unit. Some AMD GPUs support up to 96 wavefronts/compute unit.</li>
</ul>
<p>These limits are largely properties of the hardware and, thus, difficult for developers to control directly. Fortunately, these are relatively generous limits. Frequently, the register and LDS usage in the kernel determines the limit on the</p>
<p>number of active wavefronts/compute unit, and these can be controlled by the developer.</p>
</div>
<div class="section" id="id31">
<h4>3.6.2.1  GPU Registers<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<p>Each compute unit provides 16384 GP registers, and each register contains 4x32-bit values (either single-precision floating point or a 32-bit integer). The total register size is 256 kB of storage per compute unit. These registers are shared among all active wavefronts on the compute unit; each kernel allocates only the registers it needs from the shared pool. This is unlike a CPU, where each thread is assigned a fixed set of architectural registers. However, using many registers in a kernel depletes the shared pool and eventually causes the hardware to throttle the maximum number of active wavefronts.</p>
<p>Table 3.7 shows how the registers used in the kernel impacts the register-limited wavefronts/compute unit.</p>
<p>For example, a kernel that uses 30 registers (120x32-bit values) can run with eight active wavefronts on each compute unit. Because of the global limits described earlier, each compute unit is limited to 32 wavefronts; thus, kernels can use up to seven registers (28 values) without affecting the number of wavefronts/compute unit. Finally, note that in addition to the GPRs shown in the table, each kernel has access to four clause temporary registers.</p>
<p><strong>Table 3.7 Impact of Register Type on Wavefronts/CU</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">GP Registers used by Kernel</th>
<th class="head">Register-Limited
Wavefronts/Compute-Unit</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0-1</td>
<td>248</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>124</td>
</tr>
<tr class="row-even"><td>3</td>
<td>82</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>62</td>
</tr>
<tr class="row-even"><td>5</td>
<td>49</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>41</td>
</tr>
<tr class="row-even"><td>7</td>
<td>35</td>
</tr>
<tr class="row-odd"><td>8</td>
<td>31</td>
</tr>
<tr class="row-even"><td>9</td>
<td>27</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>24</td>
</tr>
<tr class="row-even"><td>11</td>
<td>22</td>
</tr>
<tr class="row-odd"><td>12</td>
<td>20</td>
</tr>
<tr class="row-even"><td>13</td>
<td>19</td>
</tr>
<tr class="row-odd"><td>14</td>
<td>17</td>
</tr>
<tr class="row-even"><td>15</td>
<td>16</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>15</td>
</tr>
<tr class="row-even"><td>17</td>
<td>14</td>
</tr>
<tr class="row-odd"><td>18-19</td>
<td>13</td>
</tr>
<tr class="row-even"><td>19-20</td>
<td>12</td>
</tr>
<tr class="row-odd"><td>21-22</td>
<td>11</td>
</tr>
<tr class="row-even"><td>23-24</td>
<td>10</td>
</tr>
<tr class="row-odd"><td>25-27</td>
<td>9</td>
</tr>
<tr class="row-even"><td>28-31</td>
<td>8</td>
</tr>
<tr class="row-odd"><td>32-35</td>
<td>7</td>
</tr>
<tr class="row-even"><td>36-41</td>
<td>6</td>
</tr>
<tr class="row-odd"><td>42-49</td>
<td>5</td>
</tr>
<tr class="row-even"><td>50-62</td>
<td>4</td>
</tr>
<tr class="row-odd"><td>63-82</td>
<td>3</td>
</tr>
<tr class="row-even"><td>83-124</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>AMD provides the following tools to examine the number of general-purpose registers (GPRs) used by the kernel.</p>
<ul class="simple">
<li>The CodeXL GPU Profiler displays the number of GPRs used by the kernel.</li>
<li>Alternatively, the CodeXL GPU Profiler generates the ISA dump , which then can be searched for the string :NUM_GPRS.</li>
<li>The AMD CodeXL Static Kernel Analyzer also shows the GPR used by the kernel, across a wide variety of GPU compilation targets.</li>
</ul>
<p>The compiler generates spill code (shuffling values to, and from, memory) if it cannot fit all the live values into registers. Spill code uses long-latency global memory and can have a large impact on performance. The CodeXL GPU Profiler reports the static number of register spills in the ScratchReg field. Generally, it is a good idea to re-write the algorithm to use fewer GPRs, or tune the work- group dimensions specified at launch time to expose more registers/kernel to the compiler, in order to reduce the scratch register usage to 0.</p>
<div class="section" id="id32">
<h5>3.6.2.2 Specifying the Default Work-Group Size at Compile-Time<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h5>
<p>The number of registers used by a work-item is determined when the kernel is compiled. The user later specifies the size of the work-group. Ideally, the OpenCL compiler knows the size of the work-group at compile-time, so it can make optimal register allocation decisions. Without knowing the work-group size, the compiler must assume an upper-bound size to avoid allocating more registers in the work-item than the hardware actually contains.</p>
<p>For example, if the compiler allocates 70 registers for the work-item, Table 3.7 shows that only three wavefronts (192 work-items) are supported. If the user later launches the kernel with a work-group size of four wavefronts (256 work-items), the launch fails because the work-group requires 70*256=17920 registers, which is more than the hardware allows. To prevent this from happening, the compiler performs the register allocation with the conservative assumption that the kernel is launched with the largest work-group size (256 work-items). The compiler guarantees that the kernel does not use more than 62 registers (the maximum number of registers which supports a work-group with four wave-fronts), and generates low-performing register spill code, if necessary.</p>
<p>Fortunately, OpenCL provides a mechanism to specify a work-group size that the compiler can use to optimize the register allocation. In particular, specifying a smaller work-group size at compile time allows the compiler to allocate more registers for each kernel, which can avoid spill code and improve performance.</p>
<p>The kernel attribute syntax is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute</span> <span class="p">((</span><span class="n">reqd_work_group_size</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)))</span>
</pre></div>
</div>
<p>Section 6.7.2 of the OpenCL specification explains the attribute in more detail.</p>
</div>
<div class="section" id="id33">
<h5>3.6.2.3 Local Memory (LDS) Size<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h5>
<p>In addition to registers, shared memory can also serve to limit the active wavefronts/compute unit. Each compute unit has 32k of LDS, which is shared among all active work-groups. LDS is allocated on a per-work-group granularity, so it is possible (and useful) for multiple wavefronts to share the same local memory allocation. However, large LDS allocations eventually limits the number of workgroups that can be active. Table 3.8 provides more details about how LDS usage can impact the wavefronts/compute unit.</p>
<p><strong>Table 3.8 Effect of LDS Usage on Wavefronts/CU</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="24%" />
<col width="24%" />
<col width="24%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Local Memory/Work-Group</th>
<th class="head">LDS-Limited Wavefronts/Compute-Unit (Assume 4 Wavefronts/Work-Group)</th>
<th class="head">LDS-Limited Wavefronts/Compute-Unit (Assume 3 Wavefronts/Work-Group)</th>
<th class="head">LDS-Limited Wavefronts/Compute-Unit (Assume 2 Wavefronts/Work-Group)</th>
<th class="head">LDS-Limited Work-Groups (Assume 1 Wavefront/Work-Group)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&lt;=4K</td>
<td>32</td>
<td>24</td>
<td>16</td>
<td>8</td>
</tr>
<tr class="row-odd"><td>4.0K-4.6K</td>
<td>28</td>
<td>21</td>
<td>14</td>
<td>7</td>
</tr>
<tr class="row-even"><td>4.6K-5.3K</td>
<td>24</td>
<td>18</td>
<td>12</td>
<td>6</td>
</tr>
<tr class="row-odd"><td>5.3K-6.4K</td>
<td>20</td>
<td>15</td>
<td>10</td>
<td>5</td>
</tr>
<tr class="row-even"><td>6.4K-8.0K</td>
<td>16</td>
<td>12</td>
<td>8</td>
<td>4</td>
</tr>
<tr class="row-odd"><td>8.0K-10.7K</td>
<td>12</td>
<td>9</td>
<td>6</td>
<td>3</td>
</tr>
<tr class="row-even"><td>10.7K-16.0K</td>
<td>8</td>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>16.0K-32.0K</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>1.Assumes each work-group uses four wavefronts (the maximum supported by the AMD OpenCL SDK).</p>
<p>AMD provides the following tools to examine the amount of LDS used by the kernel:</p>
<ul class="simple">
<li>The CodeXL GPU Profiler displays the LDS usage. See the <code class="docutils literal notranslate"><span class="pre">LocalMem</span></code> counter.</li>
<li>Alternatively, use the CodeXL GPU Profiler to generate the ISA dump , then search for the string <code class="docutils literal notranslate"><span class="pre">SQ_LDS_ALLOC:SIZE</span></code> in the ISA dump. Note that the value is shown in hexadecimal format.</li>
</ul>
</div>
</div>
<div class="section" id="id34">
<h4>3.6.3 Partitioning the Work<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h4>
<p>In OpenCL, each kernel executes on an index point that exists in a global NDRange. The partition of the NDRange can have a significant impact on performance; thus, it is recommended that the developer explicitly specify the global (<code class="docutils literal notranslate"><span class="pre">#work-groups</span></code>) and local (<code class="docutils literal notranslate"><span class="pre">#work-items/work-group</span></code>) dimensions, rather than rely on OpenCL to set these automatically (by setting <code class="docutils literal notranslate"><span class="pre">local_work_size</span></code> to NULL in clEnqueueNDRangeKernel). This section explains the guidelines for partitioning at the global, local, and work/kernel levels.</p>
<div class="section" id="id35">
<h5>3.6.3.1 Global Work Size<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h5>
<p>OpenCL does not explicitly limit the number of work-groups that can be submitted with a clEnqueueNDRangeKernel command. The hardware limits the available in- flight threads, but the OpenCL SDK automatically partitions a large number of work-groups into smaller pieces that the hardware can process. For some large workloads, the amount of memory available to the GPU can be a limitation; the problem might require so much memory capacity that the GPU cannot hold it all. In these cases, the programmer must partition the workload into multiple clEnqueueNDRangeKernel commands. The available device memory can be obtained by querying clDeviceInfo.</p>
<p>At a minimum, ensure that the workload contains at least as many work-groups as the number of compute units in the hardware. Work-groups cannot be split across multiple compute units, so if the number of work-groups is less than the available compute units, some units are idle. Evergreen and Northern Islands GPUs have 2-24 compute units. (Use clGetDeviceInfo(…CL_DEVICE_MAX_COMPUTE_UNITS) to determine the value dynamically).</p>
</div>
<div class="section" id="id36">
<h5>3.6.3.2 Local Work Size (#Work-Items per Work-Group)<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h5>
<p>OpenCL limits the number of work-items in each group. Call clDeviceInfo with the CL_DEVICE_MAX_WORK_GROUP_SIZE to determine the maximum number of work-groups supported by the hardware. The latest generation AMD GPUs support a maximum of 256 work-items per work-group. Note the number of work-items is the product of all work-group dimensions; for example, a work-group with dimensions 32x16 requires 512 work-items, which is not allowed with the current AMD OpenCL runtime.</p>
<p>The fundamental unit of work on AMD GPUs is called a wavefront. Each wavefront consists of 64 work-items; thus, the optimal local work size is an integer multiple of 64 (specifically 64, 128, 192, or 256) work-items per work- group.</p>
<p>Work-items in the same work-group can share data through LDS memory and also use high-speed local atomic operations. Thus, larger work-groups enable more work-items to efficiently share data, which can reduce the amount of slower global communication. However, larger work-groups reduce the number of global work-groups, which, for small workloads, could result in idle compute units. Generally, larger work-groups are better as long as the global range is big enough to provide 1-2 Work-Groups for each compute unit in the system; for small workloads it generally works best to reduce the work-group size in order to avoid idle compute units. Note that it is possible to make the decision dynamically, when the kernel is launched, based on the launch dimensions and the target device characteristics.</p>
</div>
<div class="section" id="moving-work-to-the-kernel">
<h5>3.6.3.3 Moving Work to the Kernel<a class="headerlink" href="#moving-work-to-the-kernel" title="Permalink to this headline">¶</a></h5>
<p>Often, work can be moved from the work-group into the kernel. For example, a matrix multiply where each work-item computes a single element in the output array can be written so that each work-item generates multiple elements. This technique can be important for effectively using the processing elements available in the five-wide (or four-wide, depending on the GPU type) VLIW processing engine (see the ALUPacking performance counter reported by the CodeXL GPU Profiler). The mechanics of this technique often is as simple as adding a for loop around the kernel, so that the kernel body is run multiple times inside this loop, then adjusting the global work size to reduce the work-items. Typically, the local work-group is unchanged, and the net effect of moving work into the kernel is that each work-group does more effective processing, and fewer global work-groups are required. When moving work to the kernel, often it is best to combine work-items that are separated by 16 in the NDRange index space, rather than combining adjacent work-items. Combining the work-items in this fashion preserves the memory access patterns optimal for global and local memory accesses. For example, consider a kernel where each kernel accesses one four-byte element in array A.
The resulting access pattern is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="19%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Work-item</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td rowspan="2">&#160;</td>
</tr>
<tr class="row-even"><td><strong>Cycle0</strong></td>
<td>A+0</td>
<td>A+1</td>
<td>A+2</td>
<td>A+3</td>
</tr>
</tbody>
</table>
<p>If we naively combine four adjacent work-items to increase the work processed per kernel, so that the first work-item accesses array elements A+0 to A+3 on
successive cycles, the overall access pattern is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="9%" />
<col width="9%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Work-item</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td rowspan="5">&#160;</td>
</tr>
<tr class="row-even"><td><strong>Cycle0</strong></td>
<td>A+0</td>
<td>A+4</td>
<td>A+8</td>
<td>A+12</td>
<td>A+16</td>
<td>A+20</td>
</tr>
<tr class="row-odd"><td><strong>Cycle1</strong></td>
<td>A+1</td>
<td>A+5</td>
<td>A+9</td>
<td>A+13</td>
<td>A+17</td>
<td>A+21</td>
</tr>
<tr class="row-even"><td><strong>Cycle2</strong></td>
<td>A+2</td>
<td>A+6</td>
<td>A+10</td>
<td>A+14</td>
<td>A+18</td>
<td>A+22</td>
</tr>
<tr class="row-odd"><td><strong>Cycle3</strong></td>
<td>A+3</td>
<td>A+7</td>
<td>A+11</td>
<td>A+15</td>
<td>A+19</td>
<td>A+23</td>
</tr>
</tbody>
</table>
<p>This pattern shows that on the first cycle the access pattern contains “holes.” Also, this pattern results in bank conflicts on the LDS. A better access pattern is to combine four work-items so that the first work-item accesses array elements
A+0, A+16, A+32, and A+48. The resulting access pattern is:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Work-item</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr class="row-even"><td><strong>Cycle0</strong></td>
<td>A+0</td>
<td>A+1</td>
<td>A+2</td>
<td>A+3</td>
<td>A+4</td>
<td>A+5</td>
</tr>
<tr class="row-odd"><td><strong>Cycle1</strong></td>
<td>A+16</td>
<td>A+17</td>
<td>A+18</td>
<td>A+19</td>
<td>A+20</td>
<td>A+21</td>
</tr>
<tr class="row-even"><td><strong>Cycle2</strong></td>
<td>A+32</td>
<td>A+33</td>
<td>A+34</td>
<td>A+35</td>
<td>A+36</td>
<td>A+37</td>
</tr>
<tr class="row-odd"><td><strong>Cycle3</strong></td>
<td>A+48</td>
<td>A+49</td>
<td>A+50</td>
<td>A+51</td>
<td>A+52</td>
<td>A+53</td>
</tr>
</tbody>
</table>
<p>Note that this access patterns preserves the sequentially-increasing addressing of the original kernel and generates efficient global and LDS memory references.</p>
<p>Increasing the processing done by the kernels can allow more processing to be done on the fixed pool of local memory available to work-groups. For example, consider a case where an algorithm requires 32x32 elements of shared memory. If each work-item processes only one element, it requires 1024 work-items/work- group, which exceeds the maximum limit. Instead, each kernel can be written to process four elements, and a work-group of 16x16 work-items could be launched to process the entire array. A related example is a blocked algorithm, such as a matrix multiply; the performance often scales with the size of the array that can be cached and used to block the algorithm. By moving processing tasks into the kernel, the kernel can use the available local memory rather than being limited by the work-items/work-group.</p>
</div>
<div class="section" id="id37">
<h5>3.6.3.4 Work-Group Dimensions vs Size<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h5>
<p>The local NDRange can contain up to three dimensions, here labeled X, Y, and Z. The X dimension is returned by get_local_id(0), Y is returned by get_local_id(1), and Z is returned by get_local_id(2). The GPU hardware schedules the kernels so that the X dimensions moves fastest as the work-items are packed into wavefronts. For example, the 128 threads in a 2D work-group of dimension 32x4 (X=32 and Y=4) would be packed into two wavefronts as follows (notation shown in X,Y order):</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
<col width="5%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td rowspan="4"><strong>WaveFront0</strong></td>
<td>0,0</td>
<td>1,0</td>
<td>2,0</td>
<td>3,0</td>
<td>4,0</td>
<td>5,0</td>
<td>6,0</td>
<td>7,0</td>
<td>8,0</td>
<td>9,0</td>
<td>10,0</td>
<td>11,0</td>
<td>12,0</td>
<td>13,0</td>
<td>14,0</td>
<td>15,0</td>
</tr>
<tr class="row-even"><td>16,0</td>
<td>17,0</td>
<td>18,0</td>
<td>19,0</td>
<td>20,0</td>
<td>21,0</td>
<td>22,0</td>
<td>23,0</td>
<td>24,0</td>
<td>25,0</td>
<td>26,0</td>
<td>27,0</td>
<td>28,0</td>
<td>29,0</td>
<td>30,0</td>
<td>31,0</td>
</tr>
<tr class="row-odd"><td>0,1</td>
<td>1,1</td>
<td>2,1</td>
<td>3,1</td>
<td>4,1</td>
<td>5,1</td>
<td>6,1</td>
<td>7,1</td>
<td>8,1</td>
<td>9,1</td>
<td>10,1</td>
<td>11,1</td>
<td>12,1</td>
<td>13,1</td>
<td>14,1</td>
<td>15,1</td>
</tr>
<tr class="row-even"><td>16,1</td>
<td>17,1</td>
<td>18,1</td>
<td>19,1</td>
<td>20,1</td>
<td>21,1</td>
<td>22,1</td>
<td>23,1</td>
<td>24,1</td>
<td>25,1</td>
<td>26,1</td>
<td>27,1</td>
<td>28,1</td>
<td>29,1</td>
<td>30,1</td>
<td>31,1</td>
</tr>
<tr class="row-odd"><td rowspan="4"><strong>WaveFront1</strong></td>
<td>0,2</td>
<td>1,2</td>
<td>2,2</td>
<td>3,2</td>
<td>4,2</td>
<td>5,2</td>
<td>6,2</td>
<td>7,2</td>
<td>8,2</td>
<td>9,2</td>
<td>10,2</td>
<td>11,2</td>
<td>12,2</td>
<td>13,2</td>
<td>14,2</td>
<td>15,2</td>
</tr>
<tr class="row-even"><td>16,2</td>
<td>17,2</td>
<td>18,2</td>
<td>19,2</td>
<td>20,2</td>
<td>21,2</td>
<td>22,2</td>
<td>23,2</td>
<td>24,2</td>
<td>25,2</td>
<td>26,2</td>
<td>27,2</td>
<td>28,2</td>
<td>29,2</td>
<td>30,2</td>
<td>31,2</td>
</tr>
<tr class="row-odd"><td>0,3</td>
<td>1,3</td>
<td>2,3</td>
<td>3,3</td>
<td>4,3</td>
<td>5,3</td>
<td>6,3</td>
<td>7,3</td>
<td>8,3</td>
<td>9,3</td>
<td>10,3</td>
<td>11,3</td>
<td>12,3</td>
<td>13,3</td>
<td>14,3</td>
<td>15,3</td>
</tr>
<tr class="row-even"><td>16,3</td>
<td>17,3</td>
<td>18,3</td>
<td>19,3</td>
<td>20,3</td>
<td>21,3</td>
<td>22,3</td>
<td>23,3</td>
<td>24,3</td>
<td>25,3</td>
<td>26,3</td>
<td>27,3</td>
<td>28,3</td>
<td>29,3</td>
<td>30,3</td>
<td>31,3</td>
</tr>
</tbody>
</table>
<p>The total number of work-items in the work-group is typically the most important parameter to consider, in particular when optimizing to hide latency by increasing wavefronts/compute unit. However, the choice of XYZ dimensions for the same overall work-group size can have the following second-order effects.</p>
<ul class="simple">
<li>Work-items in the same quarter-wavefront execute on the same cycle in the processing engine. Thus, global memory coalescing and local memory bank conflicts can be impacted by dimension, particularly if the fast-moving X dimension is small. Typically, it is best to choose an X dimension of at least 16, then optimize the memory patterns for a block of 16 work-items which differ by 1 in the X dimension.</li>
<li>Work-items in the same wavefront have the same program counter and execute the same instruction on each cycle. The packing order can be important if the kernel contains divergent branches. If possible, pack together work-items that are likely to follow the same direction when control-flow is encountered. For example, consider an image-processing kernel where each work-item processes one pixel, and the control-flow depends on the color of the pixel. It might be more likely that a square of 8x8 pixels is the same color than a 64x1 strip; thus, the 8x8 would see less divergence and higher performance.</li>
<li>When in doubt, a square 16x16 work-group size is a good start.</li>
</ul>
</div>
</div>
<div class="section" id="optimizing-for-cedar">
<h4>3.6.4 Optimizing for Cedar<a class="headerlink" href="#optimizing-for-cedar" title="Permalink to this headline">¶</a></h4>
<p>To focus the discussion, this section has used specific hardware characteristics that apply to most of the Evergreen series. The value Evergreen part, referred to as Cedar and used in products such as the ATI Radeon™ HD 5450 GPU, has different architecture characteristics, as shown below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="47%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">Evergreen Cypress, Juniper, Redwood</th>
<th class="head">Evergreen Cedar</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Work-items/Wavefront</td>
<td>64</td>
<td>32</td>
</tr>
<tr class="row-odd"><td>Stream Cores / CU</td>
<td>16</td>
<td>8</td>
</tr>
<tr class="row-even"><td>GP Registers / CU</td>
<td>16384</td>
<td>8192</td>
</tr>
<tr class="row-odd"><td>Local Memory Size</td>
<td>32K</td>
<td>32K</td>
</tr>
<tr class="row-even"><td>Maximum Work-Group Size</td>
<td>256</td>
<td>128</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the maximum workgroup size can be obtained with clGetDeviceInfo…(…,CL_DEVICE_MAX_WORK_GROUP_SIZE,…). Applications must ensure that the requested kernel launch dimensions that are fewer than the threshold reported by this API call.</p>
</div>
<p>The difference in total register size can impact the compiled code and cause register spill code for kernels that were tuned for other devices. One technique that can be useful is to specify the required work-group size as 128 (half the default of 256). In this case, the compiler has the same number of registers available as for other devices and uses the same number of registers. The developer must ensure that the kernel is launched with the reduced work size (128) on Cedar-class devices.</p>
</div>
<div class="section" id="id38">
<h4>3.6.5 Summary of NDRange Optimizations<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h4>
<p>As shown above, execution range optimization is a complex topic with many interacting variables and which frequently requires some experimentation to determine the optimal values. Some general guidelines are:</p>
<blockquote>
<div><ul class="simple">
<li>Select the work-group size to be a multiple of 64, so that the wavefronts are fully populated.</li>
<li>Always provide at least two wavefronts (128 work-items) per compute unit. For a ATI Radeon™ HD 5870 GPU, this implies 40 wave-fronts or 2560 work- items. If necessary, reduce the work-group size (but not below 64 work- items) to provide work-groups for all compute units in the system.</li>
<li>Latency hiding depends on both the number of wavefronts/compute unit, as well as the execution time for each kernel. Generally, two to eight wavefronts/compute unit is desirable, but this can vary significantly, depending on the complexity of the kernel and the available memory bandwidth. The CodeXL GPU Profiler and associated performance counters can help to select an optimal value.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="id39">
<h3>3.7 Using Multiple OpenCL Devices<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h3>
<p>The AMD OpenCL runtime supports both CPU and GPU devices. This section introduces techniques for appropriately partitioning the workload and balancing it across the devices in the system.</p>
<div class="section" id="id40">
<h4>3.7.1 CPU and GPU Devices<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>Table 3.9 lists some key performance characteristics of two exemplary CPU and GPU devices: a quad-core AMD Phenom II X4 processor running at 2.8 GHz, and a mid-range ATI Radeon™ 5670 GPU running at 750 MHz. The “best” device in each characteristic is highlighted, and the ratio of the best/other device is shown in the final column.</p>
<blockquote>
<div><strong>Table 3.9 CPU and GPU Performance Characteristics</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="22%" />
<col width="24%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">CPU</th>
<th class="head">GPU</th>
<th class="head">Winner Ratio</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Example Device</td>
<td>AMD Phenom™ II X4</td>
<td>ATI Radeon™ HD 5670</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Core Frequency</td>
<td>2800 MHz</td>
<td>750 MHz</td>
<td>4 X</td>
</tr>
<tr class="row-even"><td>Compute Units</td>
<td>4</td>
<td>5</td>
<td>1.3 X</td>
</tr>
<tr class="row-odd"><td>Approx. Power1</td>
<td>95 W</td>
<td>64 W</td>
<td>1.5 X</td>
</tr>
<tr class="row-even"><td>Approx. Power/Compute Unit</td>
<td>19 W</td>
<td>13 W</td>
<td>1.5 X</td>
</tr>
<tr class="row-odd"><td>Peak Single-Precision
Billion Floating-Point Ops/Sec</td>
<td>90</td>
<td>600</td>
<td>7 X</td>
</tr>
<tr class="row-even"><td>Approx GFLOPS/Watt</td>
<td>0.9</td>
<td>9.4</td>
<td>10 X</td>
</tr>
<tr class="row-odd"><td>Max In-flight HW Threads</td>
<td>4</td>
<td>15872</td>
<td>3968 X</td>
</tr>
<tr class="row-even"><td>Simultaneous Executing Threads</td>
<td>4</td>
<td>80</td>
<td>20 X</td>
</tr>
<tr class="row-odd"><td>Memory Bandwidth</td>
<td>26 GB/s</td>
<td>64 GB/s</td>
<td>2.5 X</td>
</tr>
<tr class="row-even"><td>Int Add latency</td>
<td>0.4 ns</td>
<td>10.7 ns</td>
<td>30 X FP</td>
</tr>
<tr class="row-odd"><td>Add Latency</td>
<td>1.4 ns</td>
<td>10.7 ns</td>
<td>7 X</td>
</tr>
<tr class="row-even"><td>Approx DRAM Latency</td>
<td>50 ns</td>
<td>300 ns</td>
<td>6 X</td>
</tr>
<tr class="row-odd"><td>L2+L3 cache capacity</td>
<td>8192 KB</td>
<td>128 kB</td>
<td>64 X</td>
</tr>
<tr class="row-even"><td>Approx Kernel Launch Latency</td>
<td>25 μs</td>
<td>225 μs</td>
<td>9 X</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>For the power specifications of the AMD Phenom™ II x4, see <a class="reference external" href="http://www.amd.com/us/products/desk">http://www.amd.com/us/products/desk</a>- top/processors/phenom-ii/Pages/phenom-ii-model-number-comparison.aspx. For the power specifications of the ATI Radeon™ HD 5670, see <a class="reference external" href="http://www.amd.com/us/products/desktop/graphics/ati-radeon">http://www.amd.com/us/products/desktop/graphics/ati-radeon</a>- hd-5000/ati-radeon-hd-5670-overview/Pages/ati-radeon-hd-5670-specifications.aspx.</td></tr>
</tbody>
</table>
<p>The GPU excels at high-throughput: the peak execution rate (measured in FLOPS) is 7X higher than the CPU, and the memory bandwidth is 2.5X higher than the CPU. The GPU also consumes approximately 65% the power of the CPU; thus, for this comparison, the power efficiency in flops/watt is 10X higher. While power efficiency can vary significantly with different devices, GPUs generally provide greater power efficiency (flops/watt) than CPUs because they optimize for throughput and eliminate hardware designed to hide latency.</p>
<p>Conversely, CPUs excel at latency-sensitive tasks. For example, an integer add is 30X faster on the CPU than on the GPU. This is a product of both the CPUs higher clock rate (2800 MHz vs 750 MHz for this comparison), as well as the operation latency; the CPU is optimized to perform an integer add in just one cycle, while the GPU requires eight cycles. The CPU also has a latency- optimized path to DRAM, while the GPU optimizes for bandwidth and relies on many in-flight threads to hide the latency. The ATI Radeon™ HD 5670 GPU, for example, supports more than 15,000 in-flight threads and can switch to a new thread in a single cycle. The CPU supports only four hardware threads, and thread-switching requires saving and restoring the CPU registers from memory. The GPU requires many active threads to both keep the execution resources busy, as well as provide enough threads to hide the long latency of cache misses.</p>
<p>Each GPU thread has its own register state, which enables the fast single-cycle switching between threads. Also, GPUs can be very efficient at gather/scatter operations: each thread can load from any arbitrary address, and the registers are completely decoupled from the other threads. This is substantially more flexible and higher-performing than a classic Vector ALU-style architecture (such as SSE on the CPU), which typically requires that data be accessed from contiguous and aligned memory locations. SSE supports instructions that write parts of a register (for example, <code class="docutils literal notranslate"><span class="pre">MOVLPS</span></code> and <code class="docutils literal notranslate"><span class="pre">MOVHPS</span></code>, which write the upper and lower halves, respectively, of an SSE register), but these instructions generate additional microarchitecture dependencies and frequently require additional pack instructions to format the data correctly.</p>
<p>In contrast, each GPU thread shares the same program counter with 63 other threads in a wavefront. Divergent control-flow on a GPU can be quite expensive and can lead to significant under-utilization of the GPU device. When control flow substantially narrows the number of valid work-items in a wave-front, it can be faster to use the CPU device.</p>
<p>CPUs also tend to provide significantly more on-chip cache than GPUs. In this example, the CPU device contains 512k L2 cache/core plus a 6 MB L3 cache that is shared among all cores, for a total of 8 MB of cache. In contrast, the GPU device contains only 128 k cache shared by the five compute units. The larger CPU cache serves both to reduce the average memory latency and to reduce memory bandwidth in cases where data can be re-used from the caches.</p>
<p>Finally, note the approximate 9X difference in kernel launch latency. The GPU launch time includes both the latency through the software stack, as well as the time to transfer the compiled kernel and associated arguments across the PCI- express bus to the discrete GPU. Notably, the launch time does not include the time to compile the kernel. The CPU can be the device-of-choice for small, quick- running problems when the overhead to launch the work on the GPU outweighs the potential speedup. Often, the work size is data-dependent, and the choice of device can be data-dependent as well. For example, an image-processing algorithm may run faster on the GPU if the images are large, but faster on the CPU when the images are small.</p>
<p>The differences in performance characteristics present interesting optimization opportunities. Workloads that are large and data parallel can run orders of magnitude faster on the GPU, and at higher power efficiency. Serial or small parallel workloads (too small to efficiently use the GPU resources) often run significantly faster on the CPU devices. In some cases, the same algorithm can exhibit both types of workload. A simple example is a reduction operation such as a sum of all the elements in a large array. The beginning phases of the operation can be performed in parallel and run much faster on the GPU. The end of the operation requires summing together the partial sums that were computed in parallel; eventually, the width becomes small enough so that the overhead to parallelize outweighs the computation cost, and it makes sense to perform a serial add. For these serial operations, the CPU can be significantly faster than the GPU.</p>
</div>
<div class="section" id="id42">
<h4>3.7.2 When to Use Multiple Devices<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<p>One of the features of GPU computing is that some algorithms can run substantially faster and at better energy efficiency compared to a CPU device. Also, once an algorithm has been coded in the data-parallel task style for OpenCL, the same code typically can scale to run on GPUs with increasing compute capability (that is more compute units) or even multiple GPUs (with a little more work).</p>
<p>For some algorithms, the advantages of the GPU (high computation throughput, latency hiding) are offset by the advantages of the CPU (low latency, caches, fast launch time), so that the performance on either devices is similar. This case is more common for mid-range GPUs and when running more mainstream algorithms. If the CPU and the GPU deliver similar performance, the user can get the benefit of either improved power efficiency (by running on the GPU) or higher peak performance (use both devices).</p>
<p>Usually, when the data size is small, it is faster to use the CPU because the start- up time is quicker than on the GPU due to a smaller driver overhead and avoiding the need to copy buffers from the host to the device.</p>
</div>
<div class="section" id="id43">
<h4>3.7.3 Partitioning Work for Multiple Devices<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h4>
<p>By design, each OpenCL command queue can only schedule work on a single OpenCL device. Thus, using multiple devices requires the developer to create a separate queue for each device, then partition the work between the available command queues.</p>
<p>A simple scheme for partitioning work between devices would be to statically determine the relative performance of each device, partition the work so that faster devices received more work, launch all the kernels, and then wait for them to complete. In practice, however, this rarely yields optimal performance. The relative performance of devices can be difficult to determine, in particular for kernels whose performance depends on the data input. Further, the device performance can be affected by dynamic frequency scaling, OS thread scheduling decisions, or contention for shared resources, such as shared caches and DRAM bandwidth. Simple static partitioning algorithms which “guess wrong” at the beginning can result in significantly lower performance, since some devices finish and become idle while the whole system waits for the single, unexpectedly slow device.</p>
<p>For these reasons, a dynamic scheduling algorithm is recommended. In this approach, the workload is partitioned into smaller parts that are periodically scheduled onto the hardware. As each device completes a part of the workload, it requests a new part to execute from the pool of remaining work. Faster devices, or devices which work on easier parts of the workload, request new input faster, resulting in a natural workload balancing across the system. The approach creates some additional scheduling and kernel submission overhead, but dynamic scheduling generally helps avoid the performance cliff from a single bad initial scheduling decision, as well as higher performance in real-world system environments (since it can adapt to system conditions as the algorithm runs).</p>
<p>Multi-core runtimes, such as Cilk, have already introduced dynamic scheduling algorithms for multi-core CPUs, and it is natural to consider extending these scheduling algorithms to GPUs as well as CPUs. A GPU introduces several new aspects to the scheduling process:</p>
<ul>
<li><p class="first"><strong>Heterogeneous Compute Devices</strong></p>
<p>Most existing multi-core schedulers target only homogenous computing devices. When scheduling across both CPU and GPU devices, the scheduler must be aware that the devices can have very different performance characteristics (10X or more) for some algorithms. To some extent, dynamic scheduling is already designed to deal with heterogeneous workloads (based on data input the same algorithm can have very different performance, even when run on the same device), but a system with heterogeneous devices makes these cases more common and more extreme. Here are some suggestions for these situations.
~ The scheduler should support sending different workload sizes to different devices. GPUs typically prefer larger grain sizes, and higher- performing GPUs prefer still larger grain sizes.
~ The scheduler should be conservative about allocating work until after it has examined how the work is being executed. In particular, it is important to avoid the performance cliff that occurs when a slow device is assigned an important long-running task. One technique is to use small grain allocations at the beginning of the algorithm, then switch to larger grain allocations when the device characteristics are well-known.
~ As a special case of the above rule, when the devices are substantially different in performance (perhaps 10X), load-balancing has only a small potential performance upside, and the overhead of scheduling the load probably eliminates the advantage. In the case where one device is far faster than everything else in the system, use only the fast device.
~ The scheduler must balance small-grain-size (which increase the adaptiveness of the schedule and can efficiently use heterogeneous devices) with larger grain sizes (which reduce scheduling overhead). Note that the grain size must be large enough to efficiently use the GPU.</p>
</li>
<li><p class="first"><strong>Asynchronous Launch</strong></p>
<p>OpenCL devices are designed to be scheduled asynchronously from a command-queue. The host application can enqueue multiple kernels, flush the kernels so they begin executing on the device, then use the host core for other work. The AMD OpenCL implementation uses a separate thread for each command-queue, so work can be transparently scheduled to the GPU in the background.</p>
<p>One situation that should be avoided is starving the high-performance GPU devices. This can occur if the physical CPU core, which must re-fill the device queue, is itself being used as a device. A simple approach to this problem is to dedicate a physical CPU core for scheduling chores. The device fission extension (see the Extensions appendix of the AMD OpenCL User Guide) can be used to reserve a core for scheduling. For example, on a quad-core device, device fission can be used to create an OpenCL device with only three cores.</p>
<p>Another approach is to schedule enough work to the device so that it can tolerate latency in additional scheduling. Here, the scheduler maintains a watermark of uncompleted work that has been sent to the device, and refills the queue when it drops below the watermark. This effectively increase the grain size, but can be very effective at reducing or eliminating device starvation. Developers cannot directly query the list of commands in the OpenCL command queues; however, it is possible to pass an event to each <code class="docutils literal notranslate"><span class="pre">clEnqueue</span></code> call that can be queried, in order to determine the execution status (in particular the command completion time); developers also can maintain their own queue of outstanding requests. For many algorithms, this technique can be effective enough at hiding latency so that a core does not need to be reserved for scheduling. In particular, algorithms where the work-load is largely known up-front often work well with a deep queue and watermark. Algorithms in which work is dynamically created may require a dedicated thread to provide low-latency scheduling.</p>
</li>
<li><p class="first"><strong>Data Location</strong></p>
<p>Discrete GPUs use dedicated high-bandwidth memory that exists in a separate address space. Moving data between the device address space and the host requires time-consuming transfers over a relatively slow PCI- Express bus. Schedulers should be aware of this cost and, for example, attempt to schedule work that consumes the result on the same device producing it.</p>
<p>CPU and GPU devices share the same memory bandwidth, which results in additional interactions of kernel executions.</p>
</li>
</ul>
</div>
<div class="section" id="id44">
<h4>3.7.4 Synchronization Caveats<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h4>
<p>The OpenCL functions that enqueue work  (clEnqueueNDRangeKernel) merely enqueue the requested work in the command queue; they do not cause it to begin executing. Execution begins when the user executes a synchronizing command, such as <code class="docutils literal notranslate"><span class="pre">clFlush</span></code> or <code class="docutils literal notranslate"><span class="pre">clWaitForEvents</span></code>. Enqueuing several commands before flushing can enable the host CPU to batch together the command submission, which can reduce launch overhead.</p>
<p>Command-queues that are configured to execute in-order are guaranteed to complete execution of each command before the next command begins. This synchronization guarantee can often be leveraged to avoid explicit <code class="docutils literal notranslate"><span class="pre">clWaitForEvents()</span></code> calls between command submissions. Using <code class="docutils literal notranslate"><span class="pre">clWaitForEvents()</span></code> requires intervention by the host CPU and additional synchronization cost between the host and the GPU; by leveraging the in-order queue property, back-to-back kernel executions can be efficiently handled directly on the GPU hardware.</p>
<p>AMD Evergreen GPUs currently do not support the simultaneous execution of multiple kernels. For efficient execution, design a single kernel to use all the available execution resources on the GPU.</p>
<p>The AMD OpenCL implementation spawns a new thread to manage each command queue. Thus, the OpenCL host code is free to manage multiple devices from a single host thread. Note that <code class="docutils literal notranslate"><span class="pre">clFinish</span></code> is a blocking operation; the thread that calls <code class="docutils literal notranslate"><span class="pre">clFinish</span></code> blocks until all commands in the specified command-queue have been processed and completed. If the host thread is managing multiple devices, it is important to call clFlush for each command- queue before calling <code class="docutils literal notranslate"><span class="pre">clFinish</span></code>, so that the commands are flushed and execute in parallel on the devices. Otherwise, the first call to <code class="docutils literal notranslate"><span class="pre">clFinish</span></code> blocks, the commands on the other devices are not flushed, and the devices appear to execute serially rather than in parallel.</p>
<p>For low-latency CPU response, it can be more efficient to use a dedicated spin loop and not call <code class="docutils literal notranslate"><span class="pre">clFinish()</span></code> Calling <code class="docutils literal notranslate"><span class="pre">clFinish()</span></code> indicates that the application wants to wait for the GPU, putting the thread to sleep. For low latency, the application should use <code class="docutils literal notranslate"><span class="pre">clFlush()</span></code>, followed by a loop to wait for the event to complete. This is also true for blocking maps. The application should use non- blocking maps followed by a loop waiting on the event. The following provides sample code for this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if (sleep)
 {
 // this puts host thread to sleep, useful if power is a consideration or overhead is not a concern
 ``clFinish`` (cmd_queue_);
 }
 else
 {
 // this keeps the host thread awake, useful if latency is a concern clFlush(cmd_queue_);
 error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS,
 sizeof(cl_int), &amp;eventStatus, NULL);
 while (eventStatus &gt; 0)
 {
 error_ = clGetEventInfo(event, CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), &amp;eventStatus, NULL);
 Sleep(0);     // be nice to other threads, allow scheduler to find
 other work if possible
 // Choose your favorite way to yield, SwitchToThread() for example, in place of Sleep(0)
 }
 }
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h4>3.7.5 GPU and CPU Kernels<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<p>While OpenCL provides functional portability so that the same kernel can run on any device, peak performance for each device is typically obtained by tuning the OpenCL kernel for the target device.</p>
<p>Code optimized for the Cypress device (the ATI Radeon™ HD 5870 GPU) typically runs well across other members of the Evergreen family. There are some differences in cache size and LDS bandwidth that might impact some kernels. The Cedar ASIC has a smaller wavefront width and fewer registers (see Section 3.6.4, “Optimizing for Cedar”, for optimization information specific to this device).</p>
<p>As described in Section 3.9, “Clause Boundaries”, CPUs and GPUs have very different performance characteristics, and some of these impact how one writes an optimal kernel. Notable differences include:</p>
<ul class="simple">
<li>The Vector ALU floating point resources in a CPU (SSE) require the use of vectorized types (float4) to enable packed SSE code generation and extract good performance from the Vector ALU hardware. The GPU VLIW hardware is more flexible and can efficiently use the floating-point hardware even without the explicit use of float4. See Section 3.8.4, “VLIW and SSE Packing”, for more information and examples; however, code that can use float4 often generates hi-quality code for both the CPU and the AMD GPUs.</li>
<li>The AMD OpenCL CPU implementation runs work-items from the same work-group back-to-back on the same physical CPU core. For optimally coalesced memory patterns, a common access pattern for GPU-optimized algorithms is for work-items in the same wavefront to access memory locations from the same cache line. On a GPU, these work-items execute in parallel and generate a coalesced access pattern. On a CPU, the first work- item runs to completion (or until hitting a barrier) before switching to the next. Generally, if the working set for the data used by a work-group fits in the CPU caches, this access pattern can work efficiently: the first work-item brings a line into the cache hierarchy, which the other work-items later hit. For large working-sets that exceed the capacity of the cache hierarchy, this access pattern does not work as efficiently; each work-item refetches cache lines that were already brought in by earlier work-items but were evicted from the cache hierarchy before being used. Note that AMD CPUs typically provide 512k to 2 MB of L2+L3 cache for each compute unit.</li>
<li>CPUs do not contain any hardware resources specifically designed to accelerate local memory accesses. On a CPU, local memory is mapped to the same cacheable DRAM used for global memory, and there is no performance benefit from using the <code class="docutils literal notranslate"><span class="pre">__local</span></code> qualifier. The additional memory operations to write to LDS, and the associated barrier operations can reduce performance. One notable exception is when local memory is used to pack values to avoid non-coalesced memory patterns.</li>
<li>CPU devices only support a small number of hardware threads, typically two to eight. Small numbers of active work-group sizes reduce the CPU switching overhead, although for larger kernels this is a second-order effect.</li>
</ul>
<p>For a balanced solution that runs reasonably well on both devices, developers are encouraged to write the algorithm using float4 vectorization. The GPU is more sensitive to algorithm tuning; it also has higher peak performance potential. Thus, one strategy is to target optimizations to the GPU and aim for reasonable performance on the CPU. For peak performance on all devices, developers can choose to use conditional compilation for key code loops in the kernel, or in some cases even provide two separate kernels. Even with device-specific kernel optimizations, the surrounding host code for allocating memory, launching kernels, and interfacing with the rest of the program generally only needs to be written once.</p>
<p>Another approach is to leverage a CPU-targeted routine written in a standard high-level language, such as C++. In some cases, this code path may already exist for platforms that do not support an OpenCL device. The program uses OpenCL for GPU devices, and the standard routine for CPU devices. Load- balancing between devices can still leverage the techniques described in Section 3.7.3, “Partitioning Work for Multiple Devices”.</p>
</div>
<div class="section" id="id46">
<h4>3.7.6 Contexts and Devices<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h4>
<p>The AMD OpenCL program creates at least one context, and each context can contain multiple devices. Thus, developers must choose whether to place all devices in the same context or create a new context for each device. Generally, it is easier to extend a context to support additional devices rather than duplicating the context for each device: buffers are allocated at the context level (and automatically across all devices), programs are associated with the context, and kernel compilation (via <code class="docutils literal notranslate"><span class="pre">clBuildProgram</span></code>) can easily be done for all devices in a context. However, with current OpenCL implementations, creating a separate context for each device provides more flexibility, especially in that buffer allocations can be targeted to occur on specific devices. Generally, placing the devices in the same context is the preferred solution.</p>
</div>
</div>
<div class="section" id="id47">
<h3>3.8 Instruction Selection Optimizations<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id48">
<h4>3.8.1 Instruction Bandwidths<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h4>
<p>Table 3.10 lists the throughput of instructions for GPUs.</p>
<p><strong>Table 3.10 Instruction Throughput (Operations/Cycle for Each Stream Processor)</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="16%" />
<col width="28%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2"><div class="first last line-block">
<div class="line"><br /></div>
</div>
</th>
<th class="head" colspan="2">Rate (Operations/Cycle) for each Stream Processor</th>
</tr>
<tr class="row-even"><th class="head">&#160;</th>
<th class="head">Instruction</th>
<th class="head">Non-Double-Precision- Capable
(Evergreen and later) Devices</th>
<th class="head">Double-Precision-Capable
Devices(Evergreen and later)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td rowspan="7"><strong>Single Precision FP Rates</strong></td>
<td>SPFP FMA</td>
<td>0</td>
<td>4</td>
</tr>
<tr class="row-even"><td>SPFP MAD</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>ADD</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-even"><td>MUL</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>INV</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>RQSRT</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>LOG</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td rowspan="6"><strong>Double PrecisionFP Rates</strong></td>
<td>FMA</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>MAD</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-even"><td>ADD</td>
<td>0</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>MUL</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-even"><td>INV (approx.)</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>RQSRT (approx.)</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-even"><td rowspan="5"><strong>Integer Instruction Rates</strong></td>
<td>MAD</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>ADD</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-even"><td>MUL</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>Bit-shift</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-even"><td>Bitwise XOR</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-odd"><td rowspan="2"><strong>Conversion</strong></td>
<td>Float-to-Int</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Int-to-Float</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-odd"><td rowspan="3"><strong>24-Bit Integer Inst Rates</strong></td>
<td>MAD</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-even"><td>ADD</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>MUL</td>
<td>5</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>Note that single precision MAD operations have five times the throughput of the double-precision rate, and that double-precision is only supported on the AMD Radeon™ HD69XX devices. The use of single-precision calculation is encouraged, if that precision is acceptable. Single-precision data is also half the size of double-precision, which requires less chip bandwidth and is not as demanding on the cache structures.</p>
<p>Generally, the throughput and latency for 32-bit integer operations is the same as for single-precision floating point operations.</p>
<p>24-bit integer MULs and MADs have five times the throughput of 32-bit integer multiplies. 24-bit unsigned integers are natively supported only on the Evergreen family of devices and later. Signed 24-bit integers are supported only on the Northern Island family of devices and later. The use of OpenCL built-in functions for <code class="docutils literal notranslate"><span class="pre">mul24</span></code> and <code class="docutils literal notranslate"><span class="pre">mad24</span></code> is encouraged. Note that <code class="docutils literal notranslate"><span class="pre">mul24</span></code> can be useful for array indexing operations.</p>
<p>Packed 16-bit and 8-bit operations are not natively supported; however, in cases where it is known that no overflow will occur, some algorithms may be able to effectively pack 2 to 4 values into the 32-bit registers natively supported by the hardware.</p>
<p>The MAD instruction is an IEEE-compliant multiply followed by an IEEE- compliant add; it has the same accuracy as two separate MUL/ADD operations. No special compiler flags are required for the compiler to convert separate MUL/ADD operations to use the MAD instruction.</p>
<p>Table 3.10 shows the throughput for each stream processing core. To obtain the peak throughput for the whole device, multiply the number of stream cores and the engine clock. For example, according to Table 3.10, a Cypress device can perform two double-precision ADD operations/cycle in each stream core. An ATI Radeon™ HD 5870 GPU has 320 Stream Cores and an engine clock of 850 MHz, so the entire GPU has a throughput rate of (2*320*850 MHz) = 544 GFlops for double-precision adds.</p>
</div>
<div class="section" id="id49">
<h4>3.8.2 AMD Media Instructions<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h4>
<p>AMD provides a set of media instructions for accelerating media processing. Notably, the sum-of-absolute differences (SAD) operation is widely used in motion estimation algorithms. For a brief listing and description of the AMD media operations, see the Extensions appendix of the AMD OpenCL User Guide.</p>
</div>
<div class="section" id="id50">
<h4>3.8.3 Math Libraries<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h4>
<p>OpenCL supports two types of math library operation: <code class="docutils literal notranslate"><span class="pre">native_function()</span></code> and <code class="docutils literal notranslate"><span class="pre">function()</span></code>. Native_functions are generally supported in hardware and can run substantially faster, although at somewhat lower accuracy. The accuracy for the non-native functions is specified in section 7.4 of the OpenCL Specification. The accuracy for the native functions is implementation-defined. Developers are encouraged to use the native functions when performance is more important than precision. Table 3.11 lists the native speedup factor for certain functions.</p>
<blockquote>
<div><strong>Table 3.11 Native Speedup Factor</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Native Speedup Factor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>sin()</td>
<td>27.1x</td>
</tr>
<tr class="row-odd"><td>cos()</td>
<td>34.2x</td>
</tr>
<tr class="row-even"><td>tan()</td>
<td>13.4x</td>
</tr>
<tr class="row-odd"><td>exp()</td>
<td>4.0x</td>
</tr>
<tr class="row-even"><td>exp2()</td>
<td>3.4x</td>
</tr>
<tr class="row-odd"><td>exp10()</td>
<td>5.2x</td>
</tr>
<tr class="row-even"><td>log()</td>
<td>12.3x</td>
</tr>
<tr class="row-odd"><td>log2()</td>
<td>11.3x</td>
</tr>
<tr class="row-even"><td>log10()</td>
<td>12.8x</td>
</tr>
<tr class="row-odd"><td>sqrt()</td>
<td>1.8x</td>
</tr>
<tr class="row-even"><td>rsqrt()</td>
<td>6.4x</td>
</tr>
<tr class="row-odd"><td>powr()</td>
<td>28.7x</td>
</tr>
<tr class="row-even"><td>divide()</td>
<td>4.4x</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vliw-and-sse-packing">
<h4>3.8.4 VLIW and SSE Packing<a class="headerlink" href="#vliw-and-sse-packing" title="Permalink to this headline">¶</a></h4>
<p>Each stream core in the AMD GPU is programmed with a five-wide (or four-wide, depending on the GPU type) VLIW instruction. Efficient use of the GPU hardware requires that the kernel contain enough parallelism to fill all five processing elements; serial dependency chains are scheduled into separate instructions. A classic technique for exposing more parallelism to the compiler is loop unrolling. To assist the compiler in disambiguating memory addresses so that loads can be combined, developers should cluster load and store operations. In particular, re- ordering the code to place stores in adjacent code lines can improve performance. Figure 3.7 shows an example of unrolling a loop and then
clustering the stores.</p>
<img alt="../_images/3.7.png" src="../_images/3.7.png" />
<p><strong>Figure 3.7 Unmodified Loop</strong></p>
<p>Figure 3.8 is the same loop unrolled 4x.</p>
<p>Figure 3.9 shows and example of an unrolled loop with clustered stores.</p>
<p>Unrolling the loop to expose the underlying parallelism typically allows the GPU compiler to pack the instructions into the slots in the VLIW word. For best results, unrolling by a factor of at least 5 (perhaps 8 to preserve power-of-two factors) may deliver best performance. Unrolling increases the number of required registers, so some experimentation may be required.</p>
<p>The CPU back-end requires the use of vector types (float4) to vectorize and generate packed SSE instructions. To vectorize the loop above, use float4 for the array arguments. Obviously, this transformation is only valid in the case where the array elements accessed on each loop iteration are adjacent in memory. The explicit use of float4 can also improve the GPU performance, since it clearly identifies contiguous 16-byte memory operations that can be more efficiently coalesced.</p>
<p>Figure 3.10 is an example of an unrolled kernel that uses float4 for vectorization.</p>
</div>
<div class="section" id="compiler-optimizations">
<h4>3.8.5 Compiler Optimizations<a class="headerlink" href="#compiler-optimizations" title="Permalink to this headline">¶</a></h4>
<p>The OpenCL compiler currently recognizes a few patterns and transforms them into a single instruction. By following these patterns, a developer can generate highly efficient code. The currently accepted patterns are:</p>
<ul>
<li><dl class="first docutils">
<dt>Bitfield extract on signed/unsigned integers.</dt>
<dd><blockquote class="first">
<div><div class="line-block">
<div class="line">(A &gt;&gt; B) &amp; C ==&gt; [u]bit_extract</div>
</div>
</div></blockquote>
<p>where</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">B and C are compile time constants,</div>
<div class="line">A is a 8/16/32bit integer type, and</div>
<div class="line">C is a mask.</div>
</div>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Bitfield insert on signed/unsigned integers</dt>
<dd><blockquote class="first">
<div><div class="line-block">
<div class="line">((A &amp; B) &lt;&lt; C) | ((D &amp; E) &lt;&lt; F ==&gt; ubit_insert</div>
</div>
</div></blockquote>
<p>where</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">B and E have no conflicting bits (B^E == 0),</div>
<div class="line">B, C, E, and F are compile-time constants, and</div>
<div class="line">B and E are masks.</div>
<div class="line">The first bit set in B is greater than the number of bits in E plus the first bit set in E, or the first bit set in E is greater than the number of bits in B plus the first bit set in B.</div>
<div class="line">If B, C, E, or F are equivalent to the value 0, this optimization is also supported.</div>
</div>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</div>
</div>
<div class="section" id="clause-boundaries">
<h3>3.9 Clause Boundaries<a class="headerlink" href="#clause-boundaries" title="Permalink to this headline">¶</a></h3>
<p>AMD GPUs groups instructions into clauses. These are broken at control-flow boundaries when:</p>
<blockquote>
<div><ul class="simple">
<li>the instruction type changes (for example, from FETCH to ALU), or</li>
<li>if the clause contains the maximum amount of operations (the maximum size for an ALU clause is 128 operations).</li>
</ul>
</div></blockquote>
<p>ALU and LDS access instructions are placed in the same clause. FETCH, ALU/LDS, and STORE instructions are placed into separate clauses.</p>
<p>The GPU schedules a pair of wavefronts (referred to as the “even” and “odd” wavefront). The even wavefront executes for four cycles (each cycle executes a quarter-wavefront); then, the odd wavefront executes for four cycles. While the odd wavefront is executing, the even wavefront accesses the register file and prepares operands for execution. This fixed interleaving of two wavefronts allows the hardware to efficiently hide the eight-cycle register-read latencies.</p>
<p>With the exception of the special treatment for even/odd wavefronts, the GPU scheduler only switches wavefronts on clause boundaries. Latency within a clause results in stalls on the hardware. For example, a wavefront that generates an LDS bank conflict stalls on the compute unit until the LDS access completes; the hardware does not try to hide this stall by switching to another available wavefront.</p>
<p>ALU dependencies on memory operations are handled at the clause level. Specifically, an ALU clause can be marked as dependent on a FETCH clause. All FETCH operations in the clause must complete before the ALU clause begins execution.</p>
<p>Switching to another clause in the same wavefront requires approximately 40 cycles. The hardware immediately schedules another wavefront if one is available, so developers are encouraged to provide multiple wavefronts/compute unit. The cost to switch clauses is far less than the memory latency; typically, if the program is designed to hide memory latency, it hides the clause latency as well.</p>
<p>The address calculations for FETCH and STORE instructions execute on the same hardware in the compute unit as do the ALU clauses. The address calculations for memory operations consumes the same executions resources that are used for floating-point computations.</p>
<blockquote>
<div><ul class="simple">
<li>The ISA dump shows the clause boundaries. See the example shown below. For more information on clauses, see the AMD Evergreen-Family ISA Microcode</li>
</ul>
</div></blockquote>
<p>And Instructions (v1.0b) and the AMD R600/R700/Evergreen Assembly Language Format documents.</p>
<p>The following is an example disassembly showing clauses. There are 13 clauses in the kernel. The first clause is an ALU clause and has 6 instructions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">00</span> <span class="n">ALU_PUSH_BEFORE</span><span class="p">:</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="n">CNT</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span> <span class="n">KCACHE0</span><span class="p">(</span><span class="n">CB1</span><span class="p">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">15</span><span class="p">)</span> <span class="n">KCACHE1</span><span class="p">(</span><span class="n">CB0</span><span class="p">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">15</span><span class="p">)</span>
   <span class="mi">0</span>   <span class="n">x</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R3</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
       <span class="n">y</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R2</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
       <span class="n">z</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R2</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
       <span class="n">w</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R2</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">w</span>
    <span class="mi">1</span>  <span class="n">x</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R4</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
       <span class="n">y</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R2</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>
       <span class="n">z</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R2</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
       <span class="n">w</span><span class="p">:</span> <span class="n">MOV</span>          <span class="n">R2</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">KC0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">w</span>
       <span class="n">t</span><span class="p">:</span> <span class="n">SETGT_INT</span>    <span class="n">R5</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">PV0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>    <span class="mf">0.0</span><span class="n">f</span>
     <span class="mi">2</span>         <span class="n">t</span><span class="p">:</span> <span class="n">MULLO_INT</span>    <span class="n">__</span><span class="p">,</span>     <span class="n">R1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="n">KC1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
      <span class="mi">3</span>        <span class="n">y</span><span class="p">:</span> <span class="n">ADD_INT</span>      <span class="n">__</span><span class="p">,</span>     <span class="n">R0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="n">PS2</span>
     <span class="mi">4</span>         <span class="n">x</span><span class="p">:</span> <span class="n">ADD_INT</span>      <span class="n">R0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="n">PV3</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>  <span class="n">KC1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
     <span class="mi">5</span>         <span class="n">x</span><span class="p">:</span> <span class="n">PREDNE_INT</span>   <span class="n">__</span><span class="p">,</span>     <span class="n">R5</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span>    <span class="n">UPDATE_EXEC_MASK</span> <span class="n">UPDATE_PRED</span>

<span class="mi">01</span> <span class="n">JUMP</span>        <span class="n">POP_CNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="mi">02</span> <span class="n">ALU</span><span class="p">:</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span> <span class="n">CNT</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">KCACHE0</span><span class="p">(</span><span class="n">CB1</span><span class="p">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">15</span><span class="p">)</span>
     <span class="mi">6</span> <span class="n">z</span><span class="p">:</span> <span class="n">LSHL</span>                 <span class="n">__</span><span class="p">,</span>     <span class="n">R0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
     <span class="mi">7</span> <span class="n">y</span><span class="p">:</span> <span class="n">ADD_INT</span>      <span class="n">__</span><span class="p">,</span>     <span class="n">KC0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>       <span class="n">PV6</span><span class="o">.</span><span class="n">z</span>
     <span class="mi">8</span> <span class="n">x</span><span class="p">:</span> <span class="n">LSHR</span>         <span class="n">R1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="n">PV7</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>     <span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="mf">2.802596929e-45</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
<span class="mi">03</span> <span class="n">LOOP_DX10</span> <span class="n">i0</span> <span class="n">FAIL_JUMP_ADDR</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">04</span> <span class="n">ALU</span><span class="p">:</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="n">CNT</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
     <span class="mi">9</span> <span class="n">x</span><span class="p">:</span> <span class="n">ADD_INT</span>      <span class="n">R3</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span><span class="p">,</span>     <span class="n">R3</span><span class="o">.</span><span class="n">x</span>
       <span class="n">y</span><span class="p">:</span> <span class="n">LSHR</span>                 <span class="n">R0</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>   <span class="n">R4</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="mf">2.802596929e-45</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
       <span class="n">t</span><span class="p">:</span> <span class="n">ADD_INT</span>      <span class="n">R4</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="n">R4</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="p">(</span><span class="mh">0x00000004</span><span class="p">,</span> <span class="mf">5.605193857e-45</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">y</span>
<span class="mi">05</span> <span class="n">WAIT_ACK</span><span class="p">:</span> <span class="n">Outstanding_acks</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="mi">06</span> <span class="n">TEX</span><span class="p">:</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="n">CNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="mi">10</span>        <span class="n">VFETCH</span>          <span class="n">R0</span><span class="o">.</span><span class="n">x__</span><span class="p">,</span>         <span class="n">R0</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">fc156</span> <span class="n">MEGA</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
       <span class="n">FETCH_TYPE</span><span class="p">(</span><span class="n">NO_INDEX_OFFSET</span><span class="p">)</span>
<span class="mi">07</span> <span class="n">ALU</span><span class="p">:</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">54</span><span class="p">)</span> <span class="n">CNT</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="mi">11</span>        <span class="n">x</span><span class="p">:</span> <span class="n">MULADD_e</span>     <span class="n">R0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="n">R0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mh">0x40C00000</span><span class="p">,</span> <span class="mf">6.0</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>     <span class="p">(</span><span class="mh">0x41880000</span><span class="p">,</span> <span class="mf">17.0</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
       <span class="n">t</span><span class="p">:</span> <span class="n">SETE_INT</span>     <span class="n">R2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="n">R3</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span>
<span class="mi">08</span> <span class="n">MEM_RAT_CACHELESS_STORE_RAW_ACK</span><span class="p">:</span> <span class="n">RAT</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">R1</span><span class="p">]</span><span class="o">.</span><span class="n">x__</span><span class="p">,</span>    <span class="n">R0</span><span class="p">,</span>      <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="n">MARK</span>    <span class="n">VPM</span>
<span class="mi">09</span> <span class="n">ALU_BREAK</span><span class="p">:</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">57</span><span class="p">)</span> <span class="n">CNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
     <span class="mi">12</span>        <span class="n">x</span><span class="p">:</span> <span class="n">PREDE_INT</span>    <span class="n">__</span><span class="p">,</span>     <span class="n">R2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span>    <span class="n">UPDATE_EXEC_MASK</span> <span class="n">UPDATE_PRED</span>
<span class="mi">10</span> <span class="n">ENDLOOP</span> <span class="n">i0</span> <span class="n">PASS_JUMP_ADDR</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">11</span> <span class="n">POP</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">ADDR</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="mi">12</span> <span class="n">NOP</span> <span class="n">NO_BARRIER</span>
<span class="n">END_OF_PROGRAM</span>
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h3>3.10 Additional Performance Guidance<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<p>This section is a collection of performance tips for GPU compute and AMD- specific optimizations.</p>
<div class="section" id="id52">
<h4>3.10.1 Loop Unroll pragma<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h4>
<p>The compiler directive  <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">unroll</span> <span class="pre">&lt;unroll-factor&gt;</span></code> can be placed immediately prior to a loop as a hint to the compiler to unroll a loop. <code class="docutils literal notranslate"><span class="pre">&lt;unroll-</span> <span class="pre">factor&gt;</span></code> must be a positive integer, 1 or greater. When <code class="docutils literal notranslate"><span class="pre">&lt;unroll-factor&gt;</span></code> is 1, loop unrolling is disabled. When <code class="docutils literal notranslate"><span class="pre">&lt;unroll-factor&gt;</span></code> is 2 or greater, the compiler uses this as a hint for the number of times the loop is to be unrolled.</p>
<p>Examples for using this loop follow.</p>
<p>No unrolling example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#pragma unroll 1</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Partial unrolling example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#pragma unroll 4</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Currently, the unroll pragma requires that the loop boundaries can be determined at compile time. Both loop bounds must be known at compile time. If n is not given, it is equivalent to the number of iterations of the loop when both loop bounds are known. If the unroll-factor is not specified, and the compiler can determine the loop count, the compiler fully unrolls the loop. If the unroll-factor is not specified, and the compiler cannot determine the loop count, the compiler does no unrolling.</p>
</div>
<div class="section" id="id53">
<h4>3.10.2 Memory Tiling<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h4>
<p>There are many possible physical memory layouts for images. AMD devices can access memory in a tiled or in a linear arrangement.</p>
<blockquote>
<div><ul class="simple">
<li>Linear - A linear layout format arranges the data linearly in memory such that element addresses are sequential. This is the layout that is familiar to CPU programmers. This format must be used for OpenCL buffers; it can be used for images.</li>
<li>Tiled - A tiled layout format has a pre-defined sequence of element blocks arranged in sequential memory addresses (see Figure 3.11 for a conceptual illustration). A microtile consists of ABIJ; a macrotile consists of the top-left 16 squares for which the arrows are red. Only images can use this format. Translating from user address space to the tiled arrangement is transparent to the user. Tiled memory layouts provide an optimized memory access pattern to make more efficient use of the RAM attached to the GPU compute device. This can contribute to lower latency.</li>
</ul>
</div></blockquote>
<img alt="../_images/3.11.png" src="../_images/3.11.png" />
<p><strong>Figure 3.11 One Example of a Tiled Layout Format</strong></p>
<p><strong>Memory Access Pattern -</strong></p>
<p>Memory access patterns in compute kernels are usually different from those in the pixel shaders. Whereas the access pattern for pixel shaders is in a hierarchical, space-filling curve pattern and is tuned for tiled memory performance (generally for textures), the access pattern for a compute kernel is linear across each row before moving to the next row in the global id space. This has an effect on performance, since pixel shaders have implicit blocking, and compute kernels do not. If accessing a tiled image, best performance is achieved if the application tries to use workgroups as a simple blocking strategy.</p>
</div>
<div class="section" id="id54">
<h4>3.10.3 General Tips<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Using dynamic pointer assignment in kernels that are executed on the GPU cause inefficient code generation.</p>
</li>
<li><p class="first">Many OpenCL specification compiler options that are accepted by the AMD OpenCL compiler are not implemented. The implemented options are <code class="docutils literal notranslate"><span class="pre">-D,</span> <span class="pre">-I,</span> <span class="pre">w,</span> <span class="pre">Werror,</span> <span class="pre">-clsingle-precision-constant,</span> <span class="pre">-cl-opt-disable,</span></code> and <code class="docutils literal notranslate"><span class="pre">-cl-fp32-correctly-rounded-divide-sqrt</span></code>.</p>
</li>
<li><p class="first">Avoid declaring global arrays on the kernel’s stack frame as these typically cannot be allocated in registers and require expensive global memory operations.</p>
</li>
<li><p class="first">Use predication rather than control-flow. The predication allows the GPU to execute both paths of execution in parallel, which can be faster than attempting to minimize the work through clever control-flow. The reason for this is that if no memory operation exists in a <code class="docutils literal notranslate"><span class="pre">?:</span></code> operator (also called a ternary operator), this operation is translated into a single <code class="docutils literal notranslate"><span class="pre">cmov_logical</span></code> instruction, which is executed in a single cycle. An example of this is :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">If</span> <span class="p">(</span><span class="n">A</span><span class="o">&gt;</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span> <span class="n">C</span> <span class="o">+=</span> <span class="n">D</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">C</span> <span class="o">-=</span> <span class="n">D</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Replace this with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>int factor = (A&gt;B) ? 1:-1;
C += factor*D;
</pre></div>
</div>
</li>
</ul>
<p>In the first block of code, this translates into an IF/ELSE/ENDIF sequence of CF clauses, each taking ~40 cycles. The math inside the control flow adds two cycles if the control flow is divergent, and one cycle if it is not. This code executes in ~120 cycles.</p>
<p>In the second block of code, the <code class="docutils literal notranslate"><span class="pre">?:</span></code> operator executes in an ALU clause, so no extra CF instructions are generated. Since the instructions are sequentially dependent, this block of code executes in three cycles, for a ~40x speed improvement. To see this, the first cycle is the (A&gt;B) comparison, the result of which is input to the second cycle, which is the <code class="docutils literal notranslate"><span class="pre">cmov_logical</span></code> factor, bool, 1, -1. The final cycle is a MAD instruction that: mad C, factor, D, C. If the ratio between CF clauses and ALU instructions is low, this is a good pattern to remove the control flow.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>Loop Unrolling</dt>
<dd><ul class="first last simple">
<li>OpenCL kernels typically are high instruction-per-clock applications. Thus, the overhead to evaluate control-flow and execute branch instructions can consume a significant part of resource that otherwise can be used for high-throughput compute operations.</li>
<li>The AMD OpenCL compiler performs simple loop unrolling optimizations; however, for more complex loop unrolling, it may be beneficial to do this manually.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">If possible, create a reduced-size version of your data set for easier debugging and faster turn-around on performance experimentation. GPUs do not have automatic caching mechanisms and typically scale well as resources are added. In many cases, performance optimization for the reduced-size data implementation also benefits the full-size algorithm.</p>
</li>
<li><p class="first">When tuning an algorithm, it is often beneficial to code a simple but accurate algorithm that is retained and used for functional comparison. GPU tuning can be an iterative process, so success requires frequent experimentation, verification, and performance measurement.</p>
</li>
<li><p class="first">The profiler and analysis tools report statistics on a per-kernel granularity. To narrow the problem further, it might be useful to remove or comment-out sections of code, then re-run the timing and profiling tool.</p>
</li>
<li><p class="first">Writing code with dynamic pointer assignment should be avoided on the GPU. For example:</p>
<p>kernel void dyn_assign(global int* a, global int* b, global int* c)
{
global int* d;
size_t idx = get_global_id(0);
if (idx &amp; 1) {
d = b;
} else {
d = c;
}
a[idx] = d[idx];
}</p>
<p>This is inefficient because the GPU compiler must know the base pointer that every load comes from and in this situation, the compiler cannot determine what â€˜d’ points to. So, both B and C are assigned to the same GPU resource, removing the ability to do certain optimizations.</p>
</li>
<li><p class="first">If the algorithm allows changing the work-group size, it is possible to get better performance by using larger work-groups (more work-items in each work-group) because the workgroup creation overhead is reduced. On the other hand, the OpenCL CPU runtime uses a task-stealing algorithm at the work-group level, so when the kernel execution time differs because it contains conditions and/or loops of varying number of iterations, it might be better to increase the number of work-groups. This gives the runtime more flexibility in scheduling work-groups to idle CPU cores. Experimentation might be needed to reach optimal work-group size.</p>
</li>
<li><p class="first">Since the AMD OpenCL runtime supports only in-order queuing, using <code class="docutils literal notranslate"><span class="pre">clFinish</span></code> () on a queue and queuing a blocking command gives the same result. The latter saves the overhead of another API command.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>clEnqueueWriteBuffer(myCQ, buff, **CL_FALSE**, 0, buffSize, input, 0, NULL, NULL);``
clFinish(myCQ);
</pre></div>
</div>
<p>is equivalent, for the AMD OpenCL runtime, to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>clEnqueueWriteBuffer(myCQ, buff, **CL_TRUE**, 0, buffSize, input, 0, NULL, NULL);``
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id55">
<h4>3.10.4 Guidance for CUDA Programmers Using OpenCL<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul>
<li><p class="first">Porting from CUDA to OpenCL is relatively straightforward. Multiple vendors have documents describing how to do this, including AMD : <a class="reference external" href="http://developer.amd.com/tools-and-sdks/opencl-zone/">http://developer.amd.com/tools-and-sdks/opencl-zone/</a></p>
</li>
<li><p class="first">Some specific performance recommendations which differ from other GPU architectures:</p>
<blockquote>
<div><ul class="simple">
<li>Use a workgroup size that is a multiple of 64. CUDA code can use a workgroup size of 32; this uses only half the available compute resources on an ATI Radeon™ HD 5870 GPU.</li>
<li>Vectorization can lead to substantially greater efficiency. The <code class="docutils literal notranslate"><span class="pre">ALUPacking</span></code> counter provided by the Profiler can track how well the kernel code is using the five-wide (or four-wide, depending on the GPU type) VLIW unit. Values below 70 percent may indicate that dependencies are preventing the full use of the processor. For some kernels, vectorization can be used to increase efficiency and improve kernel performance.</li>
<li>AMD GPUs have a very high single-precision flops capability (2.72 teraflops in a single ATI Radeon™ HD 5870 GPU). Algorithms that benefit from such throughput can deliver excellent performance on AMD hardware.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id56">
<h4>3.10.5 Guidance for CPU Programmers Using OpenCL to Program GPUs<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h4>
<p>OpenCL is the industry-standard toolchain for programming GPUs and parallel devices from many vendors. It is expected that many programmers skilled in CPU programming will program GPUs for the first time using OpenCL. This section provides some guidance for experienced programmers who are programming a GPU for the first time. It specifically highlights the key differences in optimization strategy.</p>
<blockquote>
<div><ul>
<li><p class="first">Study the local memory (LDS) optimizations. These greatly affect the GPU performance. Note the difference in the organization of local memory on the GPU as compared to the CPU cache. Local memory is shared by many work-items (64 on Cypress). This contrasts with a CPU cache that normally is dedicated to a single work-item. GPU kernels run well when they collaboratively load the shared memory.</p>
</li>
<li><p class="first">GPUs have a large amount of raw compute horsepower, compared to memory bandwidth and to “control flow” bandwidth. This leads to some high- level differences in GPU programming strategy.</p>
<blockquote>
<div><ul class="simple">
<li>A CPU-optimized algorithm may test branching conditions to minimize the workload. On a GPU, it is frequently faster simply to execute the workload.</li>
<li>A CPU-optimized version can use memory to store and later load pre- computed values. On a GPU, it frequently is faster to recompute values rather than saving them in registers. Per-thread registers are a scarce resource on the CPU; in contrast, GPUs have many available per-thread register resources.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Use <code class="docutils literal notranslate"><span class="pre">float4</span></code> and the OpenCL built-ins for vector types `` (vload, vstore,`` etc.). These enable the AMD OpenCL implementation to generate efficient, packed SSE instructions when running on the CPU. Vectorization is an optimization that benefits both the AMD CPU and GPU.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id57">
<h4>3.10.6 Optimizing Kernel Code<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id58">
<h5>3.10.6.1 Using Vector Data Types<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h5>
<p>The CPU contains a vector unit, which can be efficiently used if the developer is writing the code using vector data types.</p>
<p>For architectures before Bulldozer, the instruction set is called SSE, and the vector width is 128 bits. For Bulldozer, there the instruction set is called AVX, for which the vector width is increased to 256 bits.</p>
<p>Using four-wide vector types (int4, float4, etc.) is preferred, even with Bulldozer.</p>
</div>
<div class="section" id="id59">
<h5>3.10.6.2  Local Memory<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h5>
<p>The CPU does not benefit much from local memory; sometimes it is detrimental to performance. As local memory is emulated on the CPU by using the caches, accessing local memory and global memory are the same speed, assuming the information from the global memory is in the cache.</p>
</div>
<div class="section" id="id60">
<h5>3.10.6.3 Using Special CPU Instructions<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h5>
<p>The Bulldozer family of CPUs supports FMA4 instructions, exchanging instructions of the form <code class="docutils literal notranslate"><span class="pre">a*b+c</span></code> with <code class="docutils literal notranslate"><span class="pre">fma(a,b,c)</span></code> or <code class="docutils literal notranslate"><span class="pre">mad(a,b,c)</span></code> allows for the use of the special hardware instructions for multiplying and adding.</p>
<p>There also is hardware support for OpenCL functions that give the new hardware implementation of rotating.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">tempA0</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">tempB0</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">tempA0</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">tempB1</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">tempA0</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">tempB2</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">tempA0</span><span class="o">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">tempB3</span><span class="o">.</span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p>can be written as a composition of mad instructions which use fused multiple add
(FMA):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">mad</span><span class="p">(</span><span class="n">tempA0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tempB0</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mad</span><span class="p">(</span><span class="n">tempA0</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">tempB1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mad</span><span class="p">(</span><span class="n">tempA0</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">tempB2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tempA0</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">tempB3</span><span class="o">.</span><span class="n">x</span><span class="p">)));</span>
</pre></div>
</div>
</div>
<div class="section" id="id61">
<h5>3.10.6.4 Avoid Barriers When Possible<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h5>
<p>Using barriers in a kernel on the CPU causes a significant performance penalty compared to the same kernel without barriers. Use a barrier only if the kernel requires it for correctness, and consider changing the algorithm to reduce barriers usage.</p>
</div>
</div>
<div class="section" id="optimizing-kernels-for-evergreen-and-69xx-series-gpus">
<h4>3.10.7 Optimizing Kernels for Evergreen and 69XX-Series GPUs<a class="headerlink" href="#optimizing-kernels-for-evergreen-and-69xx-series-gpus" title="Permalink to this headline">¶</a></h4>
<div class="section" id="clauses">
<h5>3.10.7.1 Clauses<a class="headerlink" href="#clauses" title="Permalink to this headline">¶</a></h5>
<p>The architecture for the 69XX series of GPUs is clause-based. A clause is similar to a basic block, a sequence of instructions that execute without flow control or I/O. Processor efficiency is determined in large part by the number of instructions in a clause, which is determined by the frequency of branching and I/O at the source-code level. An efficient kernel averages at least 16 or 32 instructions per clause.</p>
<p>The AMD CodeXL Static Kernel Analyzer assembler listing lets you view clauses. Try the optimizations listed here from inside the AMD CodeXL Static Kernel Analyzer to see the improvements in performance.</p>
</div>
<div class="section" id="id62">
<h5>3.10.7.2 Remove Conditional Assignments<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h5>
<p>A conditional of the form “if-then-else” generates branching and thus generates one or more clauses. Use the <code class="docutils literal notranslate"><span class="pre">select()</span></code> function to replace these structures with conditional assignments that do not cause branching. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.5</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
</pre></div>
</div>
<p>becomes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">);</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that if the body of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement contains an I/O, the if statement cannot be eliminated.</p>
</div>
<div class="section" id="id63">
<h5>3.10.7.3  Bypass Short-Circuiting<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h5>
<p>A conditional expression with many terms can compile into a number of clauses due to the C-language requirement that expressions must short circuit. To prevent this, move the expression out of the control flow statement. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&amp;&amp;</span><span class="n">b</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">){</span><span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>becomes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">a</span><span class="o">&amp;&amp;</span><span class="n">b</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">){</span><span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>The same applies to conditional expressions used in loop constructs `` (do, while, for)``.</p>
</div>
<div class="section" id="id64">
<h5>3.10.7.4 Unroll Small Loops<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h5>
<p>If the loop bounds are known, and the loop is small (less than 16 or 32 instructions), unrolling the loop usually increases performance.</p>
</div>
<div class="section" id="id65">
<h5>3.10.7.5 Avoid Nested ifs<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h5>
<p>Because the GPU is a Vector ALU architecture, there is a cost to executing an if-then-else block because both sides of the branch are evaluated, then one result is retained while the other is discarded. When if blocks are nested, the results are twice as bad; in general, if blocks are nested k levels deep, there 2^k clauses are generated. In this situation, restructure the code to eliminate nesting.</p>
</div>
<div class="section" id="id66">
<h5>3.10.7.6 Experiment With do/while/for Loops<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> loops can generate more clauses than equivalent <code class="docutils literal notranslate"><span class="pre">do</span></code> or <code class="docutils literal notranslate"><span class="pre">while</span></code> loops. Experiment with these different loop types to find the one with best performance.</p>
</div>
<div class="section" id="do-i-o-with-4-word-data">
<h5>3.10.7.7  Do I/O With 4-Word Data<a class="headerlink" href="#do-i-o-with-4-word-data" title="Permalink to this headline">¶</a></h5>
<p>The native hardware I/O transaction size is four words (float4, int4 types). Avoid I/Os with smaller data, and rewrite the kernel to use the native size data. Kernel performance increases, and only 25% as many work items need to be dispatched.</p>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Thomas Edvalson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>