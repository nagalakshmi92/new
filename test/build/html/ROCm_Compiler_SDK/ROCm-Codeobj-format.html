

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ROCm Code Object Format &mdash; ReadTheDocs-Breathe 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ReadTheDocs-Breathe
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../ROCm.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Current_Release_Notes/Current-Release-Notes.html">Current Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Installation_Guide/Installation-Guide.html">ROCm Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Programming_Guides/Programming-Guides.html">Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_GPU_Tunning_Guides/ROCm-GPU-Tunning-Guides.html">ROCm GPU Tuning Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GCN_ISA_Manuals/GCN-ISA-Manuals.html">GCN ISA Manuals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_API_References/ROCm-API-References.html">ROCm API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Tools/ROCm-Tools.html">ROCm Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Libraries/ROCm_Libraries.html">ROCm Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="ROCm-Compiler-SDK.html">ROCm Compiler SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_System_Managment/ROCm-System-Managment.html">ROCm System Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Virtualization_Containers/ROCm-Virtualization-&amp;-Containers.html">ROCm Virtualization &amp; Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Remote_Device_Programming/Remote-Device-Programming.html">Remote Device Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Deep_learning/Deep-learning.html">Deep Learning on ROCm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Other_Solutions/Other-Solutions.html">System Level Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorial/Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Glossary/ROCm-Glossary.html">ROCm Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ReadTheDocs-Breathe</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>ROCm Code Object Format</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/ROCm_Compiler_SDK/ROCm-Codeobj-format.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="rocm-code-object-format">
<span id="rocm-codeobj-format"></span><h1>ROCm Code Object Format<a class="headerlink" href="#rocm-code-object-format" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../ROCm_Tools/hcFFT.html#introduction"><span class="std std-ref">Introduction</span></a></li>
<li><a class="reference internal" href="#finalize"><span class="std std-ref">Finalizer, Code Object, Executable and Loader</span></a></li>
<li><a class="reference internal" href="#kernel-dispatch"><span class="std std-ref">Kernel dispatch</span></a></li>
<li><a class="reference internal" href="#hardware-registers-setup"><span class="std std-ref">Hardware registers setup</span></a></li>
<li><a class="reference internal" href="#initia-kernel-register-state"><span class="std std-ref">Initial kernel register state</span></a></li>
<li><a class="reference internal" href="#kernel-prolog-code"><span class="std std-ref">Kernel prolog code</span></a></li>
<li><a class="reference internal" href="#global-readonly-kernarg"><span class="std std-ref">Global/Readonly/Kernarg segments</span></a></li>
<li><a class="reference internal" href="#scratch-memory-swizzling"><span class="std std-ref">Scratch memory swizzling</span></a></li>
<li><a class="reference internal" href="#flat-addressing"><span class="std std-ref">Flat addressing</span></a></li>
<li><a class="reference internal" href="ROCm-Native-ISA.html#flat-scratch"><span class="std std-ref">Flat Scratch</span></a></li>
<li><a class="reference internal" href="#m0-register"><span class="std std-ref">M0 Register</span></a></li>
<li><a class="reference internal" href="#dynamic-call-stack"><span class="std std-ref">Dynamic call stack</span></a></li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#memory-model"><span class="std std-ref">Memory model</span></a></dt>
<dd><ul class="first last">
<li><a class="reference internal" href="#memory-model-overview"><span class="std std-ref">Memory model Overview</span></a></li>
<li><a class="reference internal" href="#memory-operation-constraints-global"><span class="std std-ref">Memory operation constraints for global segment</span></a></li>
<li><a class="reference internal" href="#memory-operation-constraints-group"><span class="std std-ref">Memory operation constraints for group segment</span></a></li>
<li><a class="reference internal" href="#memory-fence-constraints"><span class="std std-ref">Memory fence constraints</span></a></li>
</ul>
</dd>
</dl>
</li>
<li><a class="reference internal" href="#instruction-set-architecture"><span class="std std-ref">Instruction set architecture</span></a></li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#amd-kernel-code"><span class="std std-ref">AMD Kernel Code</span></a></dt>
<dd><ul class="first last">
<li><a class="reference internal" href="#amd-kernel-code-object"><span class="std std-ref">AMD Kernel Code Object amd_kernel_code_t</span></a></li>
<li><a class="reference internal" href="#compute-shader-settings-1"><span class="std std-ref">Compute shader program settings 1 amd_compute_pgm_rsrc1_t</span></a></li>
<li><a class="reference internal" href="#compute-shader-settings-2"><span class="std std-ref">Compute shader program settings 2 amd_compute_pgm_rsrc2_t</span></a></li>
<li><a class="reference internal" href="#amd-machine-kind"><span class="std std-ref">AMD Machine Kind amd_machine_kind_t</span></a></li>
<li><a class="reference internal" href="#float-round-mode"><span class="std std-ref">Float Round Mode amd_float_round_mode_t</span></a></li>
<li><a class="reference internal" href="#denorm-mode"><span class="std std-ref">Denorm Mode amd_float_denorm_mode_t</span></a></li>
</ul>
</dd>
</dl>
</li>
<li><a class="reference internal" href="#pcie-gen3-atomic"><span class="std std-ref">PCIe Gen3 Atomic Operations</span></a></li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#amd-queue"><span class="std std-ref">AMD Queue</span></a></dt>
<dd><ul class="first last">
<li><a class="reference internal" href="#hsa-aql"><span class="std std-ref">HSA AQL Queue Object hsa_queue_t</span></a></li>
<li><a class="reference internal" href="#amd-aql"><span class="std std-ref">AMD AQL Queue Object amd_queue_t</span></a></li>
<li><a class="reference internal" href="#queue-operations"><span class="std std-ref">Queue-operations</span></a></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#signals"><span class="std std-ref">Signals</span></a></dt>
<dd><ul class="first last">
<li><a class="reference internal" href="#signals-overview"><span class="std std-ref">Signals overview</span></a></li>
<li><a class="reference internal" href="#signal-kind"><span class="std std-ref">Signal kind amd_signal_kind_t</span></a></li>
<li><a class="reference internal" href="#signal-object"><span class="std std-ref">Signal object amd_signal_t</span></a></li>
<li><a class="reference internal" href="#signal-kernel-machine-code"><span class="std std-ref">Signal kernel machine code</span></a></li>
</ul>
</dd>
</dl>
</li>
<li><a class="reference internal" href="#debugtrap"><span class="std std-ref">Debugtrap</span></a></li>
<li><a class="reference internal" href="#references"><span class="std std-ref">References</span></a></li>
</ul>
</div></blockquote>
<div class="section" id="introduction">
<span id="id1"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This specification defines the application binary interface (ABI) provided by the AMD implementation of the HSA runtime for AMD GPU architecture agents. The AMD GPU architecture is a family of GPU agents which differ in machine code encoding and functionality.</p>
</div>
<div class="section" id="finalizer-code-object-executable-and-loader">
<span id="finalize"></span><h2>Finalizer, Code Object, Executable and Loader<a class="headerlink" href="#finalizer-code-object-executable-and-loader" title="Permalink to this headline">¶</a></h2>
<p>Finalizer, Code Object, Executable and Loader are defined in “HSA Programmer Reference Manual Specification”. AMD Code Object uses ELF format. In this document, Finalizer is any compiler producing code object, including kernel machine code.</p>
</div>
<div class="section" id="kernel-dispatch">
<span id="id2"></span><h2>Kernel dispatch<a class="headerlink" href="#kernel-dispatch" title="Permalink to this headline">¶</a></h2>
<p>The HSA Architected Queuing Language (AQL) defines a user space memory interface, an AQL Queue, to an agent that can be used to control the dispatch of kernels, using AQL Packets, in an agent independent way. All AQL packets are 64 bytes and are defined in “HSA Platform System Architecture Specification”. The packet processor of a kernel agent is responsible for detecting and dispatching kernels from the AQL Queues associated with it. For AMD GPUs the packet processor is implemented by the Command Processor (CP).</p>
<p>The AMD HSA runtime allocates the AQL Queue object. It uses the AMD Kernel Fusion Driver (KFD) to initialize and register the AQL Queue with CP. Refer to “AMD Queue” for more information.</p>
<p>A kernel dispatch is initiated with the following sequence defined in “HSA System Architecture Specification” (it may occur on CPU host agent from a host program, or from an HSA kernel agent such as a GPU from another kernel):</p>
<blockquote>
<div><ul class="simple">
<li>A pointer to an AQL Queue for the kernel agent on which the kernel is to be executed is obtained.</li>
<li>A pointer to the amd_kernel_code_t object of the kernel to execute is obtained. It must be for a kernel that was loaded on the      kernel agent with which the AQL Queue is associated.</li>
<li>Space is allocated for the kernel arguments using the HSA runtime allocator for a memory region with the kernarg property for      the kernel agent that will execute the kernel, and the values of the kernel arguments are assigned. This memory corresponds to   the backing memory for the kernarg segment within the kernel being called. Its layout is defined in “HSA Programmer Reference  Manual Specification”. For AMD the kernel execution directly uses the backing memory for the kernarg segment as the kernarg      segment.</li>
<li>Queue operations is used to reserve space in the AQL queue for the packet.</li>
<li>The packet contents are set up, including information about the actual dispatch, such as grid and work-group size, together with      information from the code object about the kernel, such as segment sizes.</li>
<li>The packet is assigned to packet processor by changing format field from INVALID to KERNEL_DISPATCH. Atomic memory operation       must be used.</li>
<li>A doorbell signal for the queue is signaled to notify packet processor.</li>
</ul>
</div></blockquote>
<p>At some point, CP performs actual kernel execution:</p>
<blockquote>
<div><ul class="simple">
<li>CP detects a packet on AQL queue.</li>
<li>CP executes micro-code for setting up the GPU and wavefronts for a kernel dispatch.</li>
<li>CP ensures that when a wavefront starts executing the kernel machine code, the scalar general purpose registers (SGPR) and         vector general purpose registers (VGPR) are set up based on flags in amd_kernel_code_t (see “Initial kernel register state”).</li>
<li>When a wavefront start executing the kernel machine code, the prolog (see “Kernel prolog code”) sets up the machine state as         necessary.</li>
<li>When the kernel dispatch has completed execution, CP signals the completion signal specified in the kernel dispatch packet if      not 0.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="hardware-registers-setup">
<span id="id3"></span><h2>Hardware registers setup<a class="headerlink" href="#hardware-registers-setup" title="Permalink to this headline">¶</a></h2>
<p>SH_MEM_CONFIG register:</p>
<blockquote>
<div><ul class="simple">
<li>DEFAULT_MTYPE = 1 (MTYPE_NC)</li>
<li>ALIGNMENT_MODE = 3 (SH_MEM_ALIGNMENT_MODE_UNALIGNED)</li>
<li>PTR32 = 1 in 32-bit mode and 0 in 64-bit mode</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="initial-kernel-register-state">
<span id="initia-kernel-register-state"></span><h2>Initial kernel register state<a class="headerlink" href="#initial-kernel-register-state" title="Permalink to this headline">¶</a></h2>
<p>Prior to start of every wavefront execution, CP/SPI sets up the register state based on enable_sgpr_* and enable_vgpr_* flags in amd_kernel_code_t object:</p>
<blockquote>
<div><ul class="simple">
<li>SGPRs before the Work-Group Ids are set by CP using the 16 User Data registers.</li>
<li>Work-group Id registers X, Y, Z are set by SPI which supports any combination including none.</li>
<li>Scratch Wave Offset is also set by SPI which is why its value cannot be added into the value Flat Scratch Offset (which would      avoid the Finalizer generated prolog having to do the add).</li>
<li>The VGPRs are set by SPI which only supports specifying either (X), (X, Y) or (X, Y, Z).</li>
</ul>
</div></blockquote>
<p>SGPR register numbers used for enabled registers are dense starting at SGPR0: the first enabled register is SGPR0, the next enabled register is SGPR1 etc.; disabled registers do not have an SGPR number. Because of hardware constraints, the initial SGPRs comprise up to 16 User SRGPs that are set up by CP and apply to all waves of the grid. It is possible to specify more than 16 User SGPRs using the enable_sgpr_* bit fields, in which case only the first 16 are actually initialized. These are then immediately followed by the System SGPRs that are set up by ADC/SPI and can have different values for each wave of the grid dispatch.</p>
<p>The number of enabled registers must match value in compute_pgm_rsrc2.user_sgpr (the total count of SGPR user data registers enabled). The enableGridWorkGroupCount* is currently not implemented in CP and should always be 0.</p>
<p>The following table defines SGPR registers that can be enabled and their order.</p>
<table border="1" class="docutils">
<colgroup>
<col width="2%" />
<col width="2%" />
<col width="6%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">SGPR Order</th>
<th class="head">Number
of Registers</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>First</td>
<td>4</td>
<td><blockquote class="first">
<div>Private Segment Buffer</div></blockquote>
<p class="last">(enable_sgpr_private_segment_buffer)</p>
</td>
<td>V# that can be used, together with Scratch Wave Offset as an
offset, to access the Private/Spill/Arg segments using a segment                                                                        address. CP uses the value from
amd_queue_t.scratch_resource_descriptor.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>2</td>
<td>Dispatch Ptr
(enable_sgpr_dispatch_ptr)</td>
<td>64 bit address of AQL dispatch packet for kernel actually
executing.</td>
</tr>
<tr class="row-even"><td>then</td>
<td>2</td>
<td>Queue Ptr
(enable_sgpr_queue_ptr)</td>
<td>64 bit address of amd_queue_t object for AQL queue on which the
dispatch packet was queued.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>2</td>
<td>Kernarg Segment Ptr</td>
<td>64 bit address of Kernarg segment. This is directly copied                                 (enable_sgpr_kernarg_segment_ptr)    from the kernarg_address in the kernel dispatch packet. Having                                                                          CP load it once avoids loading it at the beginning of                                                                           every  wavefront.</td>
</tr>
<tr class="row-even"><td>then</td>
<td>2</td>
<td>Dispatch Id
(enable_sgpr_dispatch_id)</td>
<td>64 bit Dispatch ID of the dispatch packet being executed.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>2</td>
<td>Flat Scratch Init
(enable_sgpr_flat_scratch_init)</td>
<td><dl class="first last docutils">
<dt>Value used for FLAT_SCRATCH register initialization. Refer to</dt>
<dd>Flat scratch for more information.</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>then</td>
<td>1</td>
<td>Private Segment Size
(enable_sgpr_private_segment_size)</td>
<td>The 32 bit byte size of a single work-items scratch memory
allocation. This is the value from the kernel dispatch packet                                                                           Private Segment Byte Size rounded up by CP to a multiple of                                                                             WORD. Having CP load it once avoids loading it at the beginning                                                                         of every wavefront. Not used for GFX7/GFX8 since it is the same                                                                         value as the second SGPR of Flat Scratch Init.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>1</td>
<td>Grid Work-Group Count X</td>
<td>32 bit count of the number of work-groups in the X dimension                                    (enable_sgpr_grid_workgroup_count_X)    for the grid being executed. Computed from the fields in the                                                                            kernel dispatch packet as ((grid_size.x + workgroup_size.x -                                                                            1) /workgroup_size.x).</td>
</tr>
<tr class="row-even"><td>then</td>
<td>1</td>
<td>Grid Work-Group Count Y</td>
<td>32 bit count of the number of work-groups in the Y dimension                                    (enable_sgpr_grid_workgroup_count_Y     for the grid being executed. Computed from the fields in the                                    &amp;&amp; less than 16 previous SGPRs)         kernel dispatch packet as ((grid_size.y + workgroup_size.1) /                                                                           workgroupSize.y). Only initialized if &lt;16 previous SGPRs                                                                                initialized.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>1</td>
<td>Grid Work-Group Count Z
(enable_sgpr_grid_workgroup_count_Z
&amp;&amp; less than 16 previous SGPRs)</td>
<td>32 bit count of the number of work-groups in the Z dimension
for the grid being executed. Computed from the fields in the
kernel dispatch packet as ((grid_size.z + workgroup_size.z -                                                                            1) / workgroupSize.z). Only initialized if &lt;16 previous SGPRs                                                                           initialized.</td>
</tr>
<tr class="row-even"><td>then</td>
<td>1</td>
<td>Work-Group Id X
(enable_sgpr_workgroup_id_X)</td>
<td>32 bit work group id in X dimension of grid for wavefront.
Always present.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>1</td>
<td>Work-Group Id Y
(enable_sgpr_workgroup_id_Y)</td>
<td>32 bit work group id in Y dimension of grid for wavefront.</td>
</tr>
<tr class="row-even"><td>then</td>
<td>1</td>
<td>Work-Group Id Z
(enable_sgpr_workgroup_id_Z)</td>
<td>32 bit work group id in Z dimension of grid for wavefront. If                                                                           present then Work-group Id Y will also be present.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>1</td>
<td>Work-Group Info
(enable_sgpr_workgroup_info)</td>
<td>{first_wave, 14b0000, ordered_append_term[10:0],
threadgroup_size_in_waves[5:0]}</td>
</tr>
<tr class="row-even"><td>then</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">Private Segment Wave Byte Offset</div>
</div>
</td>
<td><blockquote class="first">
<div>32 bit byte offset from base of scratch base of queue the                                    |  (enable_sgpr_private_segment_wave       executing  kernel dispatch. Must be used as an offset with                                   |  _byte_offset)                         Private/Spill/Arg  segment address when using Scratch Segment</div></blockquote>
<p class="last">Buffer. It must be added to Flat Scratch Offset if setting up                                                                           FLAT SCRATCH for flat addressing.</p>
</td>
</tr>
</tbody>
</table>
<p>VGPR register numbers used for enabled registers are dense starting at VGPR0: the first enabled register is VGPR0, the next enabled register is VGPR1 etc.; disabled registers do not have a VGPR number.</p>
<p>The following table defines VGPR registers that can be enabled and their order.</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="7%" />
<col width="21%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">VGPR Order</th>
<th class="head">No.Registers</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>First</td>
<td>1</td>
<td>Work-Item Id X (Always initialized)</td>
<td>32 bit work item id in X dimension of work-group for                                                                            wavefront lane.</td>
</tr>
<tr class="row-odd"><td>then</td>
<td>1</td>
<td>Work-Item Id Y (enable_vgpr_workitem_id &gt; 0)</td>
<td>32 bit work item id in Y dimension of work-group for                                                                            wavefront lane.</td>
</tr>
<tr class="row-even"><td>then</td>
<td>1</td>
<td>Work-Item Id Z (enable_vgpr_workitem_id &gt; 1)</td>
<td>32 bit work item id in Z dimension of work-group for                                                                            wavefront lane.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="kernel-prolog-code">
<span id="id4"></span><h2>Kernel prolog code<a class="headerlink" href="#kernel-prolog-code" title="Permalink to this headline">¶</a></h2>
<p>For certain features, kernel is expected to perform initialization actions, normally done in kernel prologue. This is only needed if kernel uses those features.</p>
</div>
<div class="section" id="global-readonly-kernarg-segments">
<span id="global-readonly-kernarg"></span><h2>Global/Readonly/Kernarg segments<a class="headerlink" href="#global-readonly-kernarg-segments" title="Permalink to this headline">¶</a></h2>
<p>Global segment can be accessed either using flat or buffer operations. Buffer operations cannot be used for large machine model for GFX7 and later as V# support for 64 bit addressing is not available.</p>
<p>If buffer operations are used then the Global Buffer used to access Global/Readonly/Kernarg (combined) segments using a segment address is not passed into the kernel code by CP since its base address is always 0. The prolog code initializes 4 SGPRs with a V# that has the following properties, and then uses that in the buffer instructions:</p>
<blockquote>
<div><ul class="simple">
<li>base address of 0</li>
<li>no swizzle</li>
<li>ATC: 1 if IOMMU present (such as APU)</li>
<li>MTYPE set to support memory coherence specified in amd_kernel_code_t.global_memory_coherence</li>
</ul>
</div></blockquote>
<p>If buffer operations are used to access Kernarg segment, Kernarg address must be added. It is available in dispatch packet (kernarg_address field) or as Kernarg Segment Ptr SGPR. Alternatively, scalar loads can be used if the kernarg offset is uniform, as the kernarg segment is constant for the duration of the kernel dispatch execution.</p>
<p>For GFX9, global segment can be accessed with new GLOBAL_* instructions.</p>
</div>
<div class="section" id="scratch-memory-swizzling">
<span id="id5"></span><h2>Scratch memory swizzling<a class="headerlink" href="#scratch-memory-swizzling" title="Permalink to this headline">¶</a></h2>
<p>Scratch memory may be used for private/spill/stack segment. Hardware will interleave (swizzle) scratch accesses of each lane of a wavefront by interleave (swizzle) element size to ensure each work-item gets a distinct memory location. Interleave size must be 2, 4, 8 or 16. The value used must match the value that the runtime configures the GPU flat scratch (SH_STATIC_MEM_CONFIG.ELEMENT_SIZE).</p>
<p>For GFX8 and earlier, all load and store operations done to scratch buffer must not exceed this size. For example, if the element size is 4 (32-bits or dword) and a 64-bit value must be loaded, it must be split into two 32-bit loads. This ensures that the interleaving will get the work-item specific dword for both halves of the 64-bit value. If it just did a 64-bit load then it would get one dword which belonged to its own work-item, but the second dword would belong to the adjacent lane work-item since the interleaving is in dwords.</p>
<p>AMD HSA Runtime Finalizer uses value 4.</p>
</div>
<div class="section" id="flat-addressing">
<span id="id6"></span><h2>Flat addressing<a class="headerlink" href="#flat-addressing" title="Permalink to this headline">¶</a></h2>
<p>Flat address can be used in FLAT instructions and can access global, private (scratch) and group (lds) memory.</p>
<p>Flat access to scratch requires hardware aperture setup and setup in kernel prologue (see Flat scratch).</p>
<p>For GFX7/GFX8, flat access to lds requires hardware aperture setup and M0 register setup (see M0 register).</p>
<p>Address operations for group/private segment may use fields from amd_queue_t, the address of which can be obtained with Queue Ptr SGPR.</p>
<dl class="docutils">
<dt>To obtain null address value for a segment (nullptr HSAIL instruction),</dt>
<dd><ul class="first last simple">
<li>For global, readonly and flat segment use value 0.</li>
<li>For group, private and kernarg segments, use value -1 (32-bit).</li>
</ul>
</dd>
<dt>To convert segment address to flat address (stof HSAIL instruction),</dt>
<dd><ul class="first last simple">
<li>For global segment, use the same value.</li>
<li>For kernarg segment, add Kernarg Segment Ptr. For small model, this is a 32-bit add. For large model, this is 32-bit add to         64-bit base address.</li>
<li><dl class="first docutils">
<dt>For group segment,</dt>
<dd><ul class="first last">
<li>for large model, combine group_segment_aperture_base_hi (upper half) and segment address (lower half),</li>
<li>for small model, add group_segment_aperture_base_hi and segment address.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For private/spill/arg segment,</dt>
<dd><ul class="first last">
<li>for large model, combine private_segment_aperture_base_hi (upper half) and segment address (lower half),</li>
<li>for small model, add private_segment_aperture_base_hi and segment address.</li>
</ul>
</dd>
</dl>
</li>
<li>If flat address may be null, kernarg, group and private/spill arg segment machine code must have additional sequence (use V_CMP      and V_CNDMASK).</li>
</ul>
</dd>
</dl>
<p>To convert flat address to segment address (ftos HSAIL instruction),</p>
<blockquote>
<div><ul class="simple">
<li>For global segment, use the same value.</li>
<li>For kernarg segment, subtract Kernarg Segment Ptr. For small model, this is a 32-bit subtract. For large model, this is 32-bit      subtract from lower half of the 64-bit flat address.</li>
<li><dl class="first docutils">
<dt>For group segment,</dt>
<dd><ul class="first last">
<li>for large model, use low half of the flat address,</li>
<li>for small model, subtract group_segment_aperture_base_hi.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For private/spill/arg segment,</dt>
<dd><ul class="first last">
<li>for large model, use low half of the flat address,</li>
<li>for small model, subtract private_segment_aperture_base_hi.</li>
</ul>
</dd>
</dl>
</li>
<li>If segment address may be null, kernarg, group and private/spill arg segment machine code must have additional sequence (use        V_CMP and V_CNDMASK).</li>
</ul>
</div></blockquote>
<p>To determine if given flat address lies within a segment (segmentp HSAIL instruction),</p>
<blockquote>
<div><ul class="simple">
<li>For global segment, check that address does not lie in group/private segments</li>
<li><dl class="first docutils">
<dt>For group segment, check if address lies in group segment aperture</dt>
<dd><ul class="first last">
<li>for large model, check that upper half of 64-bit address == group_segment_aperture_base_hi,</li>
<li>for small model, check that most significant 16 bits of 32-bit address (address &amp; ~0xFFFF) == group_segment_aperture_base_hi.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For private segment, check if address lies in private segment aperture</dt>
<dd><ul class="first last">
<li>for large model, check that upper half of 64-bit address == private_segment_aperture_base_hi,</li>
<li>for small model, check that most significant 16 bits of 32-bit address (address &amp; ~0xFFFF) == group_segment_aperture_base_hi.</li>
</ul>
</dd>
</dl>
</li>
<li>If flat address may be null, machine code must have additional sequence (use V_CMP).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="flat-scratch">
<span id="id7"></span><h2>Flat scratch<a class="headerlink" href="#flat-scratch" title="Permalink to this headline">¶</a></h2>
<p>If kernel may use flat operations to access scratch memory, the prolog code must set up FLAT_SCRATCH register pair (FLAT_SCRATCH_LO/FLAT_SCRATCH_HI or SGPRn-4/SGPRn-3).</p>
<p>For GFX7/GFX8, initialization uses Flat Scratch Init and Scratch Wave Offset sgpr registers (see Initial kernel register state):</p>
<blockquote>
<div><ul class="simple">
<li>The low word of Flat Scratch Init is 32 bit byte offset from SH_HIDDEN_PRIVATE_BASE_VIMID to base of memory for scratch for the      queue executing the kernel dispatch. This is the lower 32 bits of amd_queue_t.scratch_backing_memory_location and is the same           offset used in computing the Scratch Segment Buffer base address. The prolog must add the value of Scratch Wave Offset to it,           shift right by 8 (offset is in 256-byte units) and move to FLAT_SCRATCH_LO for use as the FLAT SCRATCH BASE in flat memory              instructions.</li>
<li>The second word of Flat Scratch Init is 32 bit byte size of a single work-items scratch memory usage. This is directly loaded from    the kernel dispatch packet Private Segment Byte Size and rounded up to a multiple of DWORD. Having CP load it once avoids loading      it at the beginning of every wavefront. The prolog must move it to FLAT_SCRATCH_LO for use as FLAT SCRATCH SIZE.</li>
</ul>
</div></blockquote>
<p>For GFX9, Flat Scrath Init contains 64-bit address of scratch backing memory. The initialization sequence for FLAT_SCRATCH does 64-bit add of Flat Scratch Init and Scratch Wave Offset.</p>
</div>
<div class="section" id="m0-register">
<span id="id8"></span><h2>M0 Register<a class="headerlink" href="#m0-register" title="Permalink to this headline">¶</a></h2>
<p>For GF7/GFX8, M0 register must be initialized with total LDS size if kernel may access LDS via DS or flat operations. Total LDS size is available in dispatch packet. For M0, it is also possible to use maximum possible value of LDS for given target.</p>
</div>
<div class="section" id="dynamic-call-stack">
<span id="id9"></span><h2>Dynamic call stack<a class="headerlink" href="#dynamic-call-stack" title="Permalink to this headline">¶</a></h2>
<p>In certain cases, Finalizer cannot compute the total private segment size at compile time. This can happen if calls are implemented using a call stack and recursion, alloca or calls to indirect functions are present. In this case, workitem_private_segment_byte_size field in code object only specifies the statically known private segment size. When performing actual kernel dispatch, private_segment_size_bytes field in dispatch packet will contain static private segment size plus additional space for the call stack.</p>
</div>
<div class="section" id="memory-model">
<span id="id10"></span><h2>Memory model<a class="headerlink" href="#memory-model" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="memory-model-overview">
<span id="id11"></span><h2>Memory model Overview<a class="headerlink" href="#memory-model-overview" title="Permalink to this headline">¶</a></h2>
<p>A memory model describes the interactions of threads through memory and their shared use of the data. Many modern programming languages implement a memory model. This section describes the mapping of common memory model constructs onto AMD GPU architecture.</p>
<p>Through this section, definitions and constraints from “HSA Platform System Architecture Specification 1.0” are used as reference, although similar notions exist elsewhere (for example, in C99 or C++ 11).</p>
<p>The following memory scopes are defined:</p>
<blockquote>
<div><ul class="simple">
<li>Work-item (wi)</li>
<li>Wavefront (wave)</li>
<li>Work-group (wg)</li>
<li>Agent (agent)</li>
<li>System (system)</li>
</ul>
</div></blockquote>
<p>The following memory orders are defined:</p>
<blockquote>
<div><ul class="simple">
<li>scacq: sequentially consistent acquire</li>
<li>screl: sequentially consistent release</li>
<li>scar: sequentially consistent acquire and release</li>
<li>rlx: relaxed</li>
</ul>
</div></blockquote>
<p>The following memory operations are defined:</p>
<blockquote>
<div><ul class="simple">
<li>Ordinary Load/Store (non-synchronizing operations)</li>
<li>Atomic Load/Atomic Store (synchronizing operations)</li>
<li>Atomic RMW (Read-Modify-Write: add, sub, max, min, and, or, xor, wrapinc, wrapdec, exch, cas (synchronizing operations)</li>
<li>Memory Fence (synchronizing operation)</li>
</ul>
</div></blockquote>
<p>Sometimes derived notation is used. For example, agent+ means agent and system scopes, wg- means work-group, wavefront and work-item scopes.</p>
<p>In the following sections, a combination of memory segment, operation, order and scope is assigned a machine code sequence. Note that if s_waitcnt vmcnt(0) is used to enforce a completion of earlier memory operations in same workitem, it can be omitted if it is also enforced using some other mechanism or proven by compiler (for example, if there are no preceding synchronizing memory operations). Similiarily, if s_waitcnt vmcnt(0) is used to enforce completion of this memory operation before the following memory operations, sometimes it can be omitted (for example, if there are no following synchronizing memory operations).</p>
<p>For a flat memory operation, if it may affect either global or group segment, group constraints must be applied to flat operations as well.</p>
</div>
<div class="section" id="memory-operation-constraints-for-global-segment">
<span id="memory-operation-constraints-global"></span><h2>Memory operation constraints for global segment<a class="headerlink" href="#memory-operation-constraints-for-global-segment" title="Permalink to this headline">¶</a></h2>
<p>For global segment, the following machine code instructions may be used (see Global/Readonly/Kernarg segments):</p>
<blockquote>
<div><ul class="simple">
<li>Ordinary Load/Store: BUFFER_LOAD/BUFFER_STORE or FLAT_LOAD/FLAT_STORE</li>
<li>Atomic Load/Store: BUFFER_LOAD/BUFFER_STORE or FLAT_LOAD/FLAT_STORE</li>
<li>Atomic RMW: BUFFER_ATOMIC or FLAT_ATOMIC</li>
</ul>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="20%" />
<col width="12%" />
<col width="55%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Operation</td>
<td>Memory order</td>
<td>Memory scope</td>
<td>Machine code sequence</td>
</tr>
<tr class="row-even"><td>Ordinary Load</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>load with glc=0</td>
</tr>
<tr class="row-odd"><td>Atomic Load</td>
<td>rlx,scacq</td>
<td>wg-</td>
<td>load with glc=0</td>
</tr>
<tr class="row-even"><td>Atomic Load</td>
<td>rlx</td>
<td>agent+</td>
<td>load with glc=1</td>
</tr>
<tr class="row-odd"><td>Atomic Load</td>
<td>scacq</td>
<td>agent+</td>
<td>load with glc=1; s_waitcnt vmcnt(0); buffer_wbinv_vol</td>
</tr>
<tr class="row-even"><td>Ordinary Store</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>store with glc=0</td>
</tr>
<tr class="row-odd"><td>Atomic Store</td>
<td>rlx,screl</td>
<td>wg-</td>
<td>store with glc=0</td>
</tr>
<tr class="row-even"><td>Atomic Store</td>
<td>rlx</td>
<td>agent+</td>
<td>store with glc=0</td>
</tr>
<tr class="row-odd"><td>Atomic Store</td>
<td>screl</td>
<td>agent+</td>
<td>s_waitcnt vmcnt(0); store with glc=0; s_waitcnt vmcnt(0)</td>
</tr>
<tr class="row-even"><td>Atomic RMW</td>
<td>rlx,scacq, screl, scar</td>
<td>wg-</td>
<td>atomic</td>
</tr>
<tr class="row-odd"><td>Atomic RMW</td>
<td>rlx</td>
<td>agent+</td>
<td>atomic</td>
</tr>
<tr class="row-even"><td>Atomic RMW</td>
<td>scacq</td>
<td>agent+</td>
<td>atomic; s_waitcnt vmcnt(0); buffer_wbinv_vol</td>
</tr>
<tr class="row-odd"><td>Atomic RMW</td>
<td>screl</td>
<td>agent+</td>
<td>s_waitcnt vmcnt(0); atomic</td>
</tr>
<tr class="row-even"><td>Atomic RMW</td>
<td>scar</td>
<td>agent+</td>
<td>s_waitcnt vmcnt(0); atomic; s_waitcnt vmcnt(0); buffer_wbinv_vol</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="memory-operation-constraints-for-group-segment">
<span id="memory-operation-constraints-group"></span><h2>Memory operation constraints for group segment<a class="headerlink" href="#memory-operation-constraints-for-group-segment" title="Permalink to this headline">¶</a></h2>
<p>For group segment, the following machine code instructions are used:</p>
<blockquote>
<div><ul class="simple">
<li>Ordinary Load/Store: DS_READ/DS_WRITE</li>
<li>Atomic Load/Store: DS_READ/DS_WRITE</li>
<li>Atomic RMW: DS_ADD, DS_SUB, DS_MAX, DS_MIN, DS_AND, DS_OR, DS_XOR, DS_INC, DS_DEC, DS_WRXCHG, DS_CMPST (and corresponding RTN       variants)</li>
</ul>
</div></blockquote>
<p>AMD LDS hardware is sequentially consistent. This means that it is not necessary to use lgkmcnt to enforce ordering in single work-item for group segment synchronization. s_waitcnt lgkmcnt(0) should still be used to enforce data dependencies, for example, after a load into a register and before use of that register (same applies to non-synchronizing operations).</p>
<p>The current model (and HSA) requires that global and group segments are coherent. This is why synchronizing group segment operations and memfence also use s_waitcnt vmcnt(0).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="15%" />
<col width="15%" />
<col width="52%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Operation</td>
<td>Memory order</td>
<td>Memory scope</td>
<td>Machine code sequence</td>
</tr>
<tr class="row-even"><td>Ordinary Load</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>load</td>
</tr>
<tr class="row-odd"><td>Atomic Load</td>
<td>rlx</td>
<td>wg-</td>
<td>load</td>
</tr>
<tr class="row-even"><td>Atomic Load</td>
<td>scacq</td>
<td>wg-</td>
<td>s_waitcnt vmcnt(0); load; buffer_wbinvl1_vol</td>
</tr>
<tr class="row-odd"><td>Ordinary Store</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>store</td>
</tr>
<tr class="row-even"><td>Atomic Store</td>
<td>rlx</td>
<td>wg-</td>
<td>store</td>
</tr>
<tr class="row-odd"><td>Atomic Store</td>
<td>screl</td>
<td>wg-</td>
<td>s_waitcnt vmcnt(0); store</td>
</tr>
<tr class="row-even"><td>Atomic RMW</td>
<td>scacq</td>
<td>wg-</td>
<td>s_waitcnt vmcnt(0); atomic; buffer_wbinvl1_vol</td>
</tr>
<tr class="row-odd"><td>Atomic RMW</td>
<td>screl</td>
<td>wg-</td>
<td>s_waitcnt vmcnt(0); atomic</td>
</tr>
<tr class="row-even"><td>Atomic RMW</td>
<td>scacq</td>
<td>wg-</td>
<td>s_waitcnt vmcnt(0); atomic; buffer_wbinvl1_vol</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="memory-fence-constraints">
<span id="id12"></span><h2>Memory fence constraints<a class="headerlink" href="#memory-fence-constraints" title="Permalink to this headline">¶</a></h2>
<p>Memory fence is currently applied to all segments (cross-segment synchronization). In machine code, memory fence does not have separate instruction and maps to s_waitcnt and buffer_wbinvl1_vol instructions. In addition, memory fence must not be moved in machine code with respect to other synchronizing operations. In the following table, ‘memfence’ refers to conceptual memory fence location.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="19%" />
<col width="16%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operation</th>
<th class="head">Memory order</th>
<th class="head">Memory scope</th>
<th class="head">Machine code sequence</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Memory Fence</td>
<td>scacq,screl,scar</td>
<td>wg-</td>
<td>memfence (no additional constraints)</td>
</tr>
<tr class="row-odd"><td>Memory Fence</td>
<td>scacq</td>
<td>agent+</td>
<td>memfence; s_waitcnt 0; buffer_wbinvl1_vol</td>
</tr>
<tr class="row-even"><td>Memory Fence</td>
<td>screl</td>
<td>agent+</td>
<td>s_waitcnt 0; memfence</td>
</tr>
<tr class="row-odd"><td>Memory Fence</td>
<td>scar</td>
<td>agent +</td>
<td>memfence; s_waitcnt 0; buffer_wbinvl1_vol</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="instruction-set-architecture">
<span id="id13"></span><h2>Instruction set architecture<a class="headerlink" href="#instruction-set-architecture" title="Permalink to this headline">¶</a></h2>
<p>AMDGPU ISA specifies instruction set architecture and capabilities used by machine code. It consists of several fields:</p>
<blockquote>
<div><ul class="simple">
<li>Vendor (“AMD”)</li>
<li>Architecture (“AMDGPU”)</li>
<li>Major (GFXIP), minor and stepping versions</li>
</ul>
</div></blockquote>
<p>These fields may be combined to form one defining string, for example, “AMD:AMDGPU:8:0:1”.</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="6%" />
<col width="3%" />
<col width="3%" />
<col width="4%" />
<col width="13%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Vendor</th>
<th class="head">Architecture</th>
<th class="head">Major</th>
<th class="head">Minor</th>
<th class="head">Stepping</th>
<th class="head">Comments</th>
<th class="head">Products</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>AMD</td>
<td>AMDGPU</td>
<td>7</td>
<td>0</td>
<td>0</td>
<td>Legacy, GFX7, 1/16 double FP</td>
<td>A10-7400 series APU</td>
</tr>
<tr class="row-odd"><td>AMD</td>
<td>AMDGPU</td>
<td>7</td>
<td>0</td>
<td>1</td>
<td>GFX7, 1/2 double FP</td>
<td>FirePro W8100, W9100, S9150, S9170; Radeon R9 290,                                                                                      R9 290x, R390,R390x</td>
</tr>
<tr class="row-even"><td>AMD</td>
<td>AMDGPU</td>
<td>8</td>
<td>0</td>
<td>0</td>
<td>Legacy, GFX8, SPI register
limitation,</td>
<td>XNACK FirePro S7150, S7100, W7100; Radeon R285,
R9 380, R9 385; Mobile FirePro M7170</td>
</tr>
<tr class="row-odd"><td>AMD</td>
<td>AMDGPU</td>
<td>8</td>
<td>0</td>
<td>1</td>
<td>GFX8, XNACK enabled</td>
<td>A10-8700 series APU</td>
</tr>
<tr class="row-even"><td>AMD</td>
<td>AMDGPU</td>
<td>8</td>
<td>0</td>
<td>2</td>
<td>GFX8, SPI register limitation
XNACK disabled,
PCIe Gen3 atomics</td>
<td><dl class="first last docutils">
<dt>FirePro S7150, S7100, W7100; Radeon R285, R9 380,</dt>
<dd>R9 385; Mobile FirePro M7170</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>AMD</td>
<td>AMDGPU</td>
<td>8</td>
<td>0</td>
<td>3</td>
<td><dl class="first last docutils">
<dt>GFX8, XNACK disabled,</dt>
<dd>PCIe Gen3 atomics</dd>
</dl>
</td>
<td>Radeon R9 Nano, R9 Fury, R9 FuryX, Pro Duo, RX 460,
RX 470, RX 480; FirePro S9300x2</td>
</tr>
<tr class="row-even"><td>AMD</td>
<td>AMDGPU</td>
<td>8</td>
<td>0</td>
<td>4</td>
<td>GFX8, -XNACK Legacy,</td>
<td><dl class="first last docutils">
<dt>Radeon R9 Nano, R9 Fury, R9 FuryX, Pro Duo,</dt>
<dd>RX 460, RX 470, RX 480; FirePro S9300x2</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>AMD</td>
<td>AMDGPU</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>GFX9, -XNACK</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>AMD</td>
<td>AMDGPU</td>
<td>9</td>
<td>0</td>
<td>1</td>
<td>GFX9, +XNACK</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="amd-kernel-code">
<span id="id14"></span><h2>AMD Kernel Code<a class="headerlink" href="#amd-kernel-code" title="Permalink to this headline">¶</a></h2>
<p>AMD Kernel Code object is used by AMD GPU CP to set up the hardware to execute a kernel dispatch and consists of the meta data needed to initiate the execution of a kernel, including the entry point address of the machine code that implements</p>
</div>
<div class="section" id="amd-kernel-code-object-amd-kernel-code-t">
<span id="amd-kernel-code-object"></span><h2>AMD Kernel Code Object amd_kernel_code_t<a class="headerlink" href="#amd-kernel-code-object-amd-kernel-code-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="3%" />
<col width="14%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bits</th>
<th class="head">Size</th>
<th class="head">Field Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>31:0</td>
<td>4 bytes</td>
<td>amd_code_version_major</td>
<td>The AMD major version. Must be the value AMD_KERNEL_CODE_VERSION_MAJOR. Major versions are not backwards compatible.</td>
</tr>
<tr class="row-odd"><td>63:32</td>
<td>4 bytes</td>
<td>amd_code_version_minor</td>
<td>The AMD minor version. Must be the value AMD_CODE_VERSION_MINOR. Minor versions with the same major version must be backward compatible.</td>
</tr>
<tr class="row-even"><td>79:64</td>
<td>2 bytes</td>
<td>amd_machine_kind</td>
<td>Machine kind.</td>
</tr>
<tr class="row-odd"><td>95:80</td>
<td>2 bytes</td>
<td>amd_machine_version_major</td>
<td>Instruction set architecture: major</td>
</tr>
<tr class="row-even"><td>111:96</td>
<td>2 bytes</td>
<td>amd_machine_version_minor</td>
<td>Instruction set architecture: minor</td>
</tr>
<tr class="row-odd"><td>127:112</td>
<td>2 bytes</td>
<td>amd_machine_version_stepping</td>
<td>Instruction set architecture: stepping</td>
</tr>
<tr class="row-even"><td>191:128</td>
<td>8 bytes</td>
<td>kernel_code_entry_byte_offset</td>
<td>Byte offset (possibly negative) from start of amd_kernel_code_t object to kernel’s entry point instruction. The actual code for the kernel is required to be 256 byte aligned to match hardware requirements (SQ cache line is 16;
entry point config register only holds bits 47:8 of the address). The Finalizer should endeavor to allocate all kernel machine code in contiguous memory pages so that a device pre-fetcher will tend to only pre-fetch Kernel Code objects,
improving cache performance. The AMD HA Runtime Finalizer generates position independent code (PIC) to avoid using relocation records and give runtime more flexibility in copying code to discrete GPU device memory.</td>
</tr>
<tr class="row-odd"><td>255:192</td>
<td>8 bytes</td>
<td>kernel_code_prefetch_byte_offset</td>
<td>Range of bytes to consider prefetching expressed as a signed offset and unsigned size. The (possibly negative) offset is from the start of amd_kernel_code_t object.
Set both to 0 if no prefetch information is available.</td>
</tr>
<tr class="row-even"><td>319:256</td>
<td>8 bytes</td>
<td>kernel_code_prefetch_byte_size</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>383:320</td>
<td>8 bytes</td>
<td>max_scratch_backing_memory_byte_size</td>
<td>Number of bytes of scratch backing memory required for full occupancy of target chip. This takes into account the number of bytes of scratch per work-item, the wavefront size, the maximum number of wavefronts per CU, and the number of CUs.
This is an upper limit on scratch. If the grid being dispatched is small it may only need less than this. If the kernel uses no scratch, or the Finalizer has not computed this value, it must be 0.</td>
</tr>
<tr class="row-even"><td>415:384</td>
<td>4 bytes</td>
<td>compute_pgm_rsrc1</td>
<td>Compute Shader (CS) program settings 1 amd_compute_pgm_rsrc1</td>
</tr>
<tr class="row-odd"><td>447:416</td>
<td>4 bytes</td>
<td>compute_pgm_rsrc2</td>
<td>Compute Shader (CS) program settings 2 amd_compute_pgm_rsrc2</td>
</tr>
<tr class="row-even"><td>448</td>
<td>1 bit</td>
<td>enable_sgpr_private_segment_buffer</td>
<td>Enable the setup of Private Segment Buffer</td>
</tr>
<tr class="row-odd"><td>449</td>
<td>1 bit</td>
<td>enable_sgpr_dispatch_ptr</td>
<td>Enable the setup of Dispatch Ptr</td>
</tr>
<tr class="row-even"><td>450</td>
<td>1 bit</td>
<td>enable_sgpr_queue_ptr</td>
<td>Enable the setup of Queue Ptr</td>
</tr>
<tr class="row-odd"><td>451</td>
<td>1 bit</td>
<td>enable_sgpr_kernarg_segment_ptr</td>
<td>Enable the setup of Kernarg Segment Ptr</td>
</tr>
<tr class="row-even"><td>452</td>
<td>1 bit</td>
<td>enable_sgpr_dispatch_id</td>
<td>Enable the setup of Dispatch Id</td>
</tr>
<tr class="row-odd"><td>453</td>
<td>1 bit</td>
<td>enable_sgpr_flat_scratch_init</td>
<td>Enable the setup of Flat Scratch Init</td>
</tr>
<tr class="row-even"><td>454</td>
<td>1 bit</td>
<td>enable_sgpr_private_segment_size</td>
<td>Enable the setup of Private Segment Size</td>
</tr>
<tr class="row-odd"><td>455</td>
<td>1 bit</td>
<td>enable_sgpr_grid_workgroup_count_X</td>
<td>Enable the setup of Grid Work-Group Count X</td>
</tr>
<tr class="row-even"><td>456</td>
<td>1 bit</td>
<td>enable_sgpr_grid_workgroup_count_Y</td>
<td>Enable the setup of Grid Work-Group Count Y</td>
</tr>
<tr class="row-odd"><td>457</td>
<td>1 bit</td>
<td>enable_sgpr_grid_workgroup_count_Z</td>
<td>Enable the setup of Grid Work-Group Count Z</td>
</tr>
<tr class="row-even"><td>463:458</td>
<td>6 bits</td>
<td>&#160;</td>
<td>Reserved. Must be 0.</td>
</tr>
<tr class="row-odd"><td>464</td>
<td>1 bit</td>
<td>enable_ordered_append_gds</td>
<td>Control wave ID base counter for GDS ordered-append. Used to set COMPUTE_DISPATCH_INITIATOR.ORDERED_APPEND_ENBL.</td>
</tr>
<tr class="row-even"><td>466:465</td>
<td>2 bits</td>
<td>private_element_size</td>
<td>Interleave (swizzle) element size in bytes.</td>
</tr>
<tr class="row-odd"><td>467</td>
<td>1 bit</td>
<td>is_ptr64</td>
<td>1 if global memory addresses are 64 bits, otherwise 0. Must match SH_MEM_CONFIG.PTR32 (GFX7), SH_MEM_CONFIG.ADDRESS_MODE (GFX8+).</td>
</tr>
<tr class="row-even"><td>468</td>
<td>1 bit</td>
<td>is_dynamic_call_stack</td>
<td>Indicates if the generated machine code is using dynamic call stack.</td>
</tr>
<tr class="row-odd"><td>469</td>
<td>1 bit</td>
<td>is_debug_enabled</td>
<td>Indicates if the generated machine code includes code required by the debugger.</td>
</tr>
<tr class="row-even"><td>470</td>
<td>1 bit</td>
<td>is_xnack_enabled</td>
<td>Indicates if the generated machine code uses conservative XNACK register allocation.</td>
</tr>
<tr class="row-odd"><td>479:471</td>
<td>9 bits</td>
<td>reserved</td>
<td>Reserved. Must be 0.</td>
</tr>
<tr class="row-even"><td>511:480</td>
<td>4 bytes</td>
<td>workitem_private_segment_byte_size</td>
<td>The amount of memory required for the static combined private, spill and arg segments for a work-item in bytes.</td>
</tr>
<tr class="row-odd"><td>543:512</td>
<td>4 bytes</td>
<td>workgroup_group_segment_byte_size</td>
<td>The amount of group segment memory required by a work-group in bytes. This does not include any dynamically allocated group segment memory that may be added when the kernel is dispatched.</td>
</tr>
<tr class="row-even"><td>575:544</td>
<td>4 bytes</td>
<td>gds_segment_byte_size</td>
<td>Number of byte of GDS required by kernel dispatch. Must be 0 if not using GDS.</td>
</tr>
<tr class="row-odd"><td>639:576</td>
<td>8 bytes</td>
<td>kernarg_segment_byte_size</td>
<td>The size in bytes of the kernarg segment that holds the values of the arguments to the kernel. This could be used by CP to prefetch the kernarg segment pointed to by the kernel dispatch packet.</td>
</tr>
<tr class="row-even"><td>671:640</td>
<td>4 bytes</td>
<td>workgroup_fbarrier_count</td>
<td>Number of fbarrier’s used in the kernel and all functions it calls. If the implementation uses group memory to allocate the fbarriers then that amount must already be included in the workgroup_group_segment_byte_size total.</td>
</tr>
<tr class="row-odd"><td>687:672</td>
<td>2 bytes</td>
<td>wavefront_sgpr_count</td>
<td><dl class="first last docutils">
<dt>Number of scalar registers used by a wavefront. This includes the special SGPRs for VCC, Flat Scratch (Base, Size) and XNACK (for GFX8 (VI)+).</dt>
<dd>It does not include the 16 SGPR added if a trap handler is enabled. Must match compute_pgm_rsrc1.sgprs used to set COMPUTE_PGM_RSRC1.SGPRS.</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>703:688</td>
<td>2 bytes</td>
<td>workitem_vgpr_count</td>
<td>Number of vector registers used by each work-item. Must match compute_pgm_rsrc1.vgprs used to set COMPUTE_PGM_RSRC1.VGPRS.</td>
</tr>
<tr class="row-odd"><td>719:704</td>
<td>2 bytes</td>
<td>reserved_vgpr_first</td>
<td>If reserved_vgpr_count is 0 then must be 0. Otherwise, this is the first fixed VGPR number reserved.</td>
</tr>
<tr class="row-even"><td>735:720</td>
<td>2 bytes</td>
<td>reserved_vgpr_count</td>
<td>The number of consecutive VGPRs reserved by the client. If is_debug_supported then this count includes VGPRs reserved for debugger use.</td>
</tr>
<tr class="row-odd"><td>751:736</td>
<td>2 bytes</td>
<td>reserved_sgpr_first</td>
<td>If reserved_sgpr_count is 0 then must be 0. Otherwise, this is the first fixed SGPR number reserved.</td>
</tr>
<tr class="row-even"><td>767:752</td>
<td>2 bytes</td>
<td>reserved_sgpr_count</td>
<td><dl class="first last docutils">
<dt>The number of consecutive SGPRs reserved by the client.</dt>
<dd>If is_debug_supported then this count includes SGPRs reserved for debugger use.</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>783:768</td>
<td>2 bytes</td>
<td>debug_wavefront_private_segment_offset_sgpr</td>
<td>If is_debug_supported is 0 then must be 0. Otherwise, this is the fixed SGPR number used to hold the wave scratch offset for the entire kernel execution, or uint16_t(-1) if the register is not used or not known.</td>
</tr>
<tr class="row-even"><td>799:784</td>
<td>2 bytes</td>
<td>debug_private_segment_buffer_sgpr</td>
<td>If is_debug_supported is 0 then must be 0. Otherwise, this is the fixed SGPR number of the first of 4 SGPRs used to hold the scratch V# used for the entire kernel execution, or uint16_t(-1) if the registers are not used or not known.</td>
</tr>
<tr class="row-odd"><td>807:800</td>
<td>1 byte</td>
<td>kernarg_segment_alignment</td>
<td>The maximum byte alignment of variables used by the kernel in the specified memory segment. Expressed as a power of two as defined in Table 37. Must be at least HSA_POWERTWO_16.</td>
</tr>
<tr class="row-even"><td>815:808</td>
<td>1 byte</td>
<td>group_segment_alignment</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>823:816</td>
<td>1 byte</td>
<td>private_segment_alignment</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>831:824</td>
<td>1 byte</td>
<td>wavefront_size</td>
<td>Wavefront size expressed as a power of two. Must be a power of 2 in range 1..256 inclusive. Used to support runtime query that obtains wavefront size, which may be used by application to allocated dynamic group memory and set the dispatch work-group size.</td>
</tr>
<tr class="row-odd"><td>863:832</td>
<td>4 bytes</td>
<td>call_convention</td>
<td>Call convention used to produce the machine code for the kernel. This specifies the function call convention ABI used for indirect functions.
If the application specified that the Finalizer should select the call convention, then this value must be the value selected, not the -1 specified to the Finalizer. If the code object does not support indirect functions, then the value must be 0xffffffff.</td>
</tr>
<tr class="row-even"><td>960:864</td>
<td>12 bytes</td>
<td>&#160;</td>
<td>Reserved. Must be 0.</td>
</tr>
<tr class="row-odd"><td>1023:960</td>
<td>8 bytes</td>
<td>runtime_loader_kernel_symbol</td>
<td>A pointer to the loaded kernel symbol. This field must be 0 when amd_kernel_code_t is created. The HSA Runtime loader initializes this field once the code object is loaded to reference the loader symbol for the kernel.
This field is used to allow the debugger to locate the debug information for the kernel. The definition of the loaded kernel symbol is located in hsa/runtime/executable.hpp.</td>
</tr>
<tr class="row-even"><td>2047:1024</td>
<td>128 bytes</td>
<td>control_directive</td>
<td>Control directives for this kernel used in generating the machine code. The values are intended to reflect the constraints that the code actually requires to correctly execute, not the values that were actually specified at finalize time.
If the finalizer chooses to ignore a control directive, and not generate constrained code, then the control directive should not be marked as enabled.</td>
</tr>
<tr class="row-odd"><td>2048</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Total size 256 bytes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compute-shader-program-settings-1-amd-compute-pgm-rsrc1-t">
<span id="compute-shader-settings-1"></span><h2>Compute shader program settings 1 amd_compute_pgm_rsrc1_t<a class="headerlink" href="#compute-shader-program-settings-1-amd-compute-pgm-rsrc1-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="6%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bits</th>
<th class="head">Size</th>
<th class="head">Field Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>5:0</td>
<td>6 bits</td>
<td>granulated_workitem_vgpr_count</td>
<td><div class="first last line-block">
<div class="line">Granulated number of vector registers used by each work-item minus                                                                    | 1(i.e. if granulated number of vector registers is 2, then 1 is                                                                       | stored in this field). Granularity is device specific.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>9:6</td>
<td>4 bits</td>
<td>granulated_wavefront_sgpr_count</td>
<td><div class="first last line-block">
<div class="line">Granulated number of scalar registers used by a wavefront minus 1                                                                     | (i.e. if granulated number of scalar registers is 4, then 3 is                                                                        | stored in this field). Granularity is device specific. This                                                                   | includes the special SGPRs for VCC, Flat Scratch (Base, and Size)                                                                     | and XNACK (for GFX8 (VI)+). It does not include the 16 SGPR added                                                                     | if a trap handler is enabled.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>11:10</td>
<td>2 bits</td>
<td>priority</td>
<td>Drives spi_priority in spi_sq newWave cmd.</td>
</tr>
<tr class="row-odd"><td>13:12</td>
<td>2 bits</td>
<td>float_mode_round_32</td>
<td>Wavefront initial float round mode for single precision floats (32                                                                       bit).</td>
</tr>
<tr class="row-even"><td>15:14</td>
<td>2 bits</td>
<td>float_mode_round_16_64</td>
<td><div class="first last line-block">
<div class="line">Wavefront initial float round mode for double/half precision floats                                                                   | (64/16 bit).</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>17:16</td>
<td>2 bits</td>
<td>float_mode_denorm_32</td>
<td><div class="first last line-block">
<div class="line">Wavefront initial denorm mode for single precision floats (32 bit).</div>
</div>
</td>
</tr>
<tr class="row-even"><td>19:18</td>
<td>2 bits</td>
<td>float_mode_denorm_16_64</td>
<td><div class="first last line-block">
<div class="line">Wavefront initial denorm mode for double/half precision floats                                                                        | (64/16 bit).</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>20</td>
<td>1 bit</td>
<td>priv</td>
<td><div class="first last line-block">
<div class="line">Drives priv in spi_sq newWave cmd. This field is set to 0 by the                                                                      | Finalizer and must be filled in by CP.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>21</td>
<td>1 bit</td>
<td>enable_dx10_clamp</td>
<td><div class="first last line-block">
<div class="line">Wavefront starts execution with DX10 clamp mode enabled. Used by                                                                      | the vector ALU to force DX-10 style treatment of NaN’s (when set,                                                                     | clamp NaN to zero, otherwise pass NaN through). Used by CP to set                                                                     | up COMPUTE_PGM_RSRC1.DX10_CLAMP.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>22</td>
<td>1 bit</td>
<td>debug_mode</td>
<td><div class="first last line-block">
<div class="line">Drives debug in spi_sq newWave cmd. This field is set to 0 by the                                                                     | Finalizer and must be filled in by CP.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>23</td>
<td>1 bit</td>
<td>enable_ieee_mode</td>
<td><div class="first last line-block">
<div class="line">Wavefront starts execution with IEEE mode enabled. Floating point                                                                     | opcodes that support exception flag gathering will quiet and                                                                  | propagate signaling-NaN inputs per IEEE 754-2008. Min_dx10 and                                                                        | max_dx10 become IEEE 754-2008 compliant due to signaling-NaN                                                                  | propagation and quieting. Used by CP to set up                                                                        | COMPUTE_PGM_RSRC1.IEEE_MODE.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>1 bit</td>
<td>bulky</td>
<td><div class="first last line-block">
<div class="line">Only one such work-group is allowed to be active on any given                                                                 | Compute Unit. Only one such work-group is allowed to be active on                                                                     | any given CU. This field is set to 0 by the Finalizer and must be                                                                     | filled in by CP.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>25</td>
<td>1 bit</td>
<td>cdbg_user</td>
<td><div class="first last line-block">
<div class="line">This field is set to 0 by the Finalizer and must be filled in by CP.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>31:26</td>
<td>6 bits</td>
<td>reserved</td>
<td>Reserved. Must be 0.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Total size 4 bytes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compute-shader-program-settings-2-amd-compute-pgm-rsrc2-t">
<span id="compute-shader-settings-2"></span><h2>Compute shader program settings 2 amd_compute_pgm_rsrc2_t<a class="headerlink" href="#compute-shader-program-settings-2-amd-compute-pgm-rsrc2-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="6%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bits</th>
<th class="head">Size</th>
<th class="head">Field Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>1 bit</td>
<td>enable_sgpr_private_segment_wave_byte_offset</td>
<td>Enable the setup of the SGPR wave scratch offset system register (see                                                                   2.9.8). Used by CP to set up COMPUTE_PGM_RSRC2.SCRATCH_EN.</td>
</tr>
<tr class="row-odd"><td>5:1</td>
<td>5 bit</td>
<td>user_sgpr_count</td>
<td>The total number of SGPR user data registers requested. This number                                                                     must match the number of user data registers enabled.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>1 bit</td>
<td>enable_trap_handler</td>
<td>Code contains a TRAP instruction which requires a trap hander to be                                                                     enabled. Used by CP to set up COMPUTE_PGM_RSRC2.TRAP_PRESENT. Note                                                                      that CP shuld set COMPUTE_PGM_RSRC2.TRAP_PRESENT if either this field                                                                   is 1 or if amd_queue.enable_trap_handler is 1 for the queue executing                                                                   the kernel dispatch.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>1 bit</td>
<td>enable_sgpr_workgroup_id_x</td>
<td>Enable the setup of Work-Group Id X. Also used by CP to set up                                                                  COMPUTE_PGM_RSRC2.TGID_X_EN.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>1 bit</td>
<td>enable_sgpr_workgroup_id_y</td>
<td>Enable the setup of Work-Group Id Y. Also used by CP to set up                                                                  COMPUTE_PGM_RSRC2.TGID_Y_EN, TGID_Z_EN.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>1 bit</td>
<td>enable_sgpr_workgroup_id_z</td>
<td>Enable the setup of Work-Group Id Z. Also used by CP to set up                                                                  COMPUTE_PGM_RSRC2. TGID_Z_EN.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>1 bit</td>
<td>enable_sgpr_workgroup_info</td>
<td>Enable the setup of Work-Group Info.</td>
</tr>
<tr class="row-odd"><td>12:11</td>
<td>2 bit</td>
<td>enable_vgpr_workitem_id</td>
<td>Enable the setup of Work-Item Id X, Y, Z. Also used by CP to                                                                    set up COMPUTE_PGM_RSRC2.TIDIG_CMP_CNT.</td>
</tr>
<tr class="row-even"><td>13</td>
<td>1 bit</td>
<td>enable_exception_address_watch</td>
<td>Wavefront starts execution with specified exceptions enabled. Used by                                                                   CP to set up COMPUTE_PGM_RSRC2.EXCP_EN_MSB (composed from following                                                                     bits). Address Watch - TC (L1) has witnessed a thread access an                                                                 “address of interest”.</td>
</tr>
<tr class="row-odd"><td>14</td>
<td>1 bit</td>
<td>enable_exception_memory_violation</td>
<td>Memory Violation - a memory violation has occurred for this wave from                                                                   L1 or LDS (write-to-read-only-memory, mis-aligned atomic, LDS address                                                                   out of range, illegal address, etc.).</td>
</tr>
<tr class="row-even"><td>23:15</td>
<td>9bits</td>
<td>granulated_lds_size</td>
<td>Amount of group segment (LDS) to allocate for each work-group.                                                                  Granularity is device specific. CP should use the rounded value from                                                                    the dispatch packet, not this value, as the dispatch may contain                                                                        dynamically allocated group segment memory. This field is set to 0 by                                                                   the Finalizer and CP will write directly to                                                                     COMPUTE_PGM_RSRC2.LDS_SIZE.</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>1 bit</td>
<td><a href="#id22"><span class="problematic" id="id23">enable_exception_ieee_754_fp_invalid_</span></a></td>
<td>Enable IEEE 754 FP Invalid Operation exception at start of wavefront                    operation                                       execution. enable_exception flags are used by CP to set up                                                                      COMPUTE_PGM_RSRC2.EXCP_EN (set from bits 0..6), EXCP_EN_MSB (set from                                                                   bits 7..8).</td>
</tr>
<tr class="row-even"><td>25</td>
<td>1 bit</td>
<td>enable_exception_fp_denormal_source</td>
<td>Enable FP Denormal exception at start of wavefront execution.</td>
</tr>
<tr class="row-odd"><td>26</td>
<td>1 bit</td>
<td>enable_exception_ieee_754_fp_division_by_zero</td>
<td>Enable IEEE 754 FP Division by Zero exception at start of wavefront                                                                     execution.</td>
</tr>
<tr class="row-even"><td>27</td>
<td>1 bit</td>
<td>enable_exception_ieee_754_fp_overflow</td>
<td>Enable IEEE 754 FP FP Overflow exception at start of wavefront                                                                  execution.</td>
</tr>
<tr class="row-odd"><td>28</td>
<td>1 bit</td>
<td>enable_exception_ieee_754_fp_underflow</td>
<td>Enable IEEE 754 FP Underflow exception at start of wavefront                                                                    execution.</td>
</tr>
<tr class="row-even"><td>29</td>
<td>1 bit</td>
<td>enable_exception_ieee_754_fp_inexact</td>
<td>Enable IEEE 754 FP Inexact exception at start of wavefront execution.</td>
</tr>
<tr class="row-odd"><td>30</td>
<td>1 bit</td>
<td>enable_exception_int_divide_by_zero</td>
<td>Enable Integer Division by Zero (rcp_iflag_f32 instruction only)                                                                        exception at start of wavefront execution.</td>
</tr>
<tr class="row-even"><td>31</td>
<td>1 bit</td>
<td>&#160;</td>
<td>Reserved. Must be 0.</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Total size 4 bytes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="amd-machine-kind-amd-machine-kind-t">
<span id="amd-machine-kind"></span><h2>AMD Machine Kind amd_machine_kind_t<a class="headerlink" href="#amd-machine-kind-amd-machine-kind-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="10%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Enumeration Name</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>AMD_MACHINE_KIND_UNDEFINED</td>
<td>0</td>
<td>Machine kind is undefined.</td>
</tr>
<tr class="row-odd"><td>AMD_MACHINE_KIND_AMDGPU</td>
<td>1</td>
<td>Machine kind is AMD GPU. Corresponds to AMD GPU ISA architecture of AMDGPU.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="float-round-mode-amd-float-round-mode-t">
<span id="float-round-mode"></span><h2>Float Round Mode amd_float_round_mode_t<a class="headerlink" href="#float-round-mode-amd-float-round-mode-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="8%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Enumeration Name</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>AMD_FLOAT_ROUND_MODE_NEAR_EVEN</td>
<td>0</td>
<td>Round Ties To Even</td>
</tr>
<tr class="row-odd"><td>AMD_FLOAT_ROUND_MODE_PLUS_INFINITY</td>
<td>1</td>
<td>Round Toward +infinity</td>
</tr>
<tr class="row-even"><td>AMD_FLOAT_ROUND_MODE_MINUS_INFINITY</td>
<td>2</td>
<td>Round Toward -infinity</td>
</tr>
<tr class="row-odd"><td>AMD_FLOAT_ROUND_MODE_ZERO</td>
<td>3</td>
<td>Round Toward 0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="denorm-mode-amd-float-denorm-mode-t">
<span id="denorm-mode"></span><h2>Denorm Mode amd_float_denorm_mode_t<a class="headerlink" href="#denorm-mode-amd-float-denorm-mode-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="9%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Enumeration Name</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>AMD_FLOAT_DENORM_MODE_FLUSH_SRC_DST</td>
<td>0</td>
<td>Flush Source and Destination Denorms</td>
</tr>
<tr class="row-odd"><td>AMD_FLOAT_DENORM_MODE_FLUSH_DST</td>
<td>1</td>
<td>Flush Output Denorms</td>
</tr>
<tr class="row-even"><td>AMD_FLOAT_DENORM_MODE_FLUSH_SRC</td>
<td>2</td>
<td>Flush Source Denorms</td>
</tr>
<tr class="row-odd"><td>AMD_FLOAT_DENORM_MODE_FLUSH_NONE</td>
<td>3</td>
<td>No Flush</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pcie-gen3-atomic-operations">
<span id="pcie-gen3-atomic"></span><h2>PCIe Gen3 Atomic Operations<a class="headerlink" href="#pcie-gen3-atomic-operations" title="Permalink to this headline">¶</a></h2>
<p>PCI Express Gen3 defines 3 PCIe transactions, each of which carries out a specific Atomic Operation:</p>
<blockquote>
<div><ul class="simple">
<li>FetchAdd (Fetch and Add)</li>
<li>Swap (Unconditional Swap)</li>
<li>CAS (Compare and Swap)</li>
</ul>
</div></blockquote>
<p>For compute capabilities supporting PCIe Gen3 atomics, system scope atomic operations use the following sequences:</p>
<blockquote>
<div><ul class="simple">
<li>Atomic Load/Store: FLAT_LOAD_DWORD* / FLAT_STORE_DWORD* / TLP MRd / MWr</li>
<li>Atomic add: FLAT_ATOMIC_ADD / TLP FetchAdd</li>
<li>Atomic sub: FLAT_ATOMIC_ADD + negate/ TLP FetchAdd</li>
<li>Atomic swap: FLAT_ATOMIC_SWAP / TLP Swap</li>
<li>Atomic compare-and-swap: FLAT_ATOMIC_CMPSWAP / TLP CAS</li>
<li>Other Atomic RMW operations: (max, min, and, or, xor, wrapinc, wrapdec): CAS loop</li>
</ul>
</div></blockquote>
<p>PCIe Gen3 atomics are only supported on certain hardware configurations, for example, Haswell system.</p>
</div>
<div class="section" id="amd-queue">
<span id="id15"></span><h2>AMD Queue<a class="headerlink" href="#amd-queue" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="hsa-aql-queue-object-hsa-queue-t">
<span id="hsa-aql"></span><h2>HSA AQL Queue Object hsa_queue_t<a class="headerlink" href="#hsa-aql-queue-object-hsa-queue-t" title="Permalink to this headline">¶</a></h2>
<p>HSA Queue Object is defined in “HSA Platform System Architecture Specification”. AMD HSA Queue handle is a pointer to amd_queue_t.</p>
</div>
<div class="section" id="amd-aql-queue-object-amd-queue-t">
<span id="amd-aql"></span><h2>AMD AQL Queue Object amd_queue_t<a class="headerlink" href="#amd-aql-queue-object-amd-queue-t" title="Permalink to this headline">¶</a></h2>
<p>The AMD HSA Runtime implementation uses the AMD Queue object (amd_queue_t) to implement AQL queues. It begins with the HSA Queue object, and then has additional information contiguously afterwards that is AMD device specific. The AMD device specific information is accessible by the AMD HSA Runtime, CP and kernel machine code.</p>
<p>The AMD Queue object must be allocated on 64 byte alignment. This allows CP microcode to fetch fields using cache line addresses. The entire AMD Queue object must not span a 4GiB boundary. This allows CP to save a few instructions when calculating the base address of amd_queue_t from &amp;(amd_queue_t.read_dispatch_id) and amd_queue_t.read_dispatch_id_field_base_offset.</p>
<p>For GFX8 and earlier systems, only HSA Queue type SINGLE is supported.</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="8%" />
<col width="31%" />
<col width="55%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Bits</td>
<td>Size</td>
<td>Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td>319:0</td>
<td>40 bytes</td>
<td>hsa_queue</td>
<td>HSA Queue object</td>
</tr>
<tr class="row-odd"><td>447:320</td>
<td>16 bytes</td>
<td>&#160;</td>
<td><div class="first last line-block">
<div class="line">Unused. Allows hsa_queue_t to expand but still keeps</div>
<div class="line">write_dispatch_id, which is written by the producer</div>
<div class="line">often the host CPU), in the same cache line. Must be 0.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>511:448</td>
<td>8 bytes</td>
<td>write_dispatch_id</td>
<td><div class="first last line-block">
<div class="line">64-bit index of the next packet to be allocated by</div>
<div class="line">application or user-level runtime. Initialized to 0 at</div>
<div class="line">queue creation time.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>512</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Start of cache line for fields accessed by kernel machine code isa.</td>
</tr>
<tr class="row-even"><td>543:512</td>
<td>4 bytes</td>
<td>group_segment_aperture_base_hi</td>
<td><div class="first last line-block">
<div class="line">For HSA64, the most significant 32 bits of the 64 bit group</div>
<div class="line">segment flat address aperture base. This is the same value</div>
<div class="line">{SH_MEM_BASES:PRIVATE_BASE[15:13],For HSA32, the 32 bits of the 32</div>
<div class="line">bit group segment flat address aperture.This is the same value as</div>
<div class="line">{SH_MEM_BASES:SHARED_BASE[15:0], 16b0}.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>575:544</td>
<td>4 bytes</td>
<td>private_segment_aperture_base_hi</td>
<td><div class="first last line-block">
<div class="line">For HSA64, the most significant 32 bits of the 64 bit private</div>
<div class="line">segment flat address aperture base.This is the same value as</div>
<div class="line">{SH_MEM_BASES:PRIVATE_BASE[15:13], 28b0, 1b1}  For HSA32,</div>
<div class="line-block">
<div class="line">the 32 bits of the 32 bit private segment flat address aperture</div>
</div>
<div class="line">base This is the same value as {SH_MEM_BASES:PRIVATE_BASE[15:0],</div>
<div class="line-block">
<div class="line">16b0}.</div>
</div>
</div>
</td>
</tr>
<tr class="row-even"><td>607:576</td>
<td>4 bytes</td>
<td>max_cu_id</td>
<td><div class="first last line-block">
<div class="line">The number of compute units on the agent to which the queue is</div>
<div class="line">associated.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>639:608</td>
<td>4 bytes</td>
<td>max_wave_id</td>
<td><div class="first last line-block">
<div class="line">The number of wavefronts that can be executed on a single compute</div>
<div class="line">unit of the device to which the queue is associated.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>703:640</td>
<td>8 bytes</td>
<td>max_legacy_doorbell_dispatch_id_plus_1</td>
<td><div class="first last line-block">
<div class="line">For AMD_SIGNAL_KIND_LEGACY_DOORBELL maximum value of</div>
<div class="line">write_dispatch_id signaled for the queue. the This value is always</div>
<div class="line">64-bit and never decreases.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>735:704</td>
<td>4 bytes</td>
<td>legacy_doorbell_lock</td>
<td><div class="first last line-block">
<div class="line">For AMD_SIGNAL_KIND_LEGACY_DOORBELL, atomic variable used to</div>
<div class="line">protect critical section which updates the doorbell related fields</div>
<div class="line">Initialized to 0, and set to 1 to lock the critical section</div>
</div>
</td>
</tr>
<tr class="row-even"><td>1023:736</td>
<td>36 bytes</td>
<td>&#160;</td>
<td>Padding to next cache line. Unused and must be 0.</td>
</tr>
<tr class="row-odd"><td>1024</td>
<td>&#160;</td>
<td>&#160;</td>
<td><div class="first last line-block">
<div class="line">Start of cache line for fields accessed by the packet processor (CP</div>
<div class="line">micro code).</div>
</div>
</td>
</tr>
<tr class="row-even"><td>1087:
1024</td>
<td>8 bytes</td>
<td>read_dispatch_id</td>
<td><div class="first last line-block">
<div class="line">64-bit index of the next packet to be consumed by compute unit</div>
<div class="line">hardware. Initialized to 0 at queue creation time.Queue operations</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>1119:
1088</td>
<td>4 bytes</td>
<td>read_dispatch_id_field_base_byte_offset</td>
<td><div class="first last line-block">
<div class="line">Byte offset from the base of hsa_queue_t to the read_dispatch_id</div>
<div class="line">field.when amd_kernel_code_t.enable_sgpr_dispatch_ptr is set.</div>
<div class="line">This field must immediately follow read_dispatch_id.This allows the</div>
<div class="line">layout above the read_dispatch_id  field to change, and still be</div>
<div class="line">able to get the base of the hsa_queue_t, which is needed to return</div>
<div class="line">if amd_kernel_code_t.enable_sgpr_queue_ptr is requested. These</div>
<div class="line">fields are defined by HSA Foundation and so could change. CP only</div>
<div class="line">uses fields below read_dispatch_id which are defined by AMD.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>1536</td>
<td>&#160;</td>
<td>&#160;</td>
<td><div class="first last line-block">
<div class="line">Start of next cache line for fields not accessed under normal</div>
<div class="line">conditions by the packet processor (CP micro code). These are kept</div>
<div class="line">in a single cache line to minimize memory accesses performed by CP</div>
<div class="line">micro code.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>2048</td>
<td>&#160;</td>
<td>&#160;</td>
<td><div class="first last line-block">
<div class="line">Total size 256 bytes.</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="queue-operations">
<span id="id16"></span><h2>Queue-operations<a class="headerlink" href="#queue-operations" title="Permalink to this headline">¶</a></h2>
<p>A queue has an associated set of high-level operations defined in “HSA Runtime Specification” (API functions in host code) and “HSA Programmer Reference Manual Specification” (kernel code).</p>
<p>The following is informal description of AMD implementation of queue operations (all use memory scope system, memory order applies):</p>
<blockquote>
<div><ul class="simple">
<li>Load Queue Write Index: Atomic load of read_dispatch_id field</li>
<li>Store Queue Write Index: Atomic store of read_dispatch_id field</li>
<li>Load Queue Read Index: Atomic load of write_dispatch_id field</li>
<li>Store Queue Read Index: Atomic store of read_dispatch_id field</li>
<li>Add Queue Write Index: Atomic add of write_dispatch_id field</li>
<li>Compare-And-Swap Queue Write Index: Atomic CAS of write_dispatch_id field</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="signals">
<span id="id17"></span><h2>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="signals-overview">
<span id="id18"></span><h2>Signals overview<a class="headerlink" href="#signals-overview" title="Permalink to this headline">¶</a></h2>
<p>Signal handle is 8 bytes. AMD signal handle is a pointer to AMD Signal Object (amd_signal_t).</p>
<p>The following operations are defined on HSA Signals:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>Signal Load</dt>
<dd><ul class="first last">
<li>Read the of the current value of the signal</li>
<li>Optional acquire semantics on the signal value</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Signal Wait on a condition</dt>
<dd><ul class="first last">
<li>Blocks the thread until the requested condition on the signal value is observed</li>
<li>Condition: equals, not-equals, greater, greater-equals, lesser, lesser-equals</li>
<li>Optional acquire semantics on the signal value</li>
<li>Returns the value of the signal that caused it to wake</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Signal Store</dt>
<dd><ul class="first last">
<li>Optional release semantics on the signal value</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Signal Read-Modify-Write Atomics (add, sub, increment, decrement, min, max, and, or, xor, exch, cas)</dt>
<dd><ul class="first last">
<li>These happen immediately and atomically</li>
<li>Optional acquire-release semantics on the signal value</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="signal-kind-amd-signal-kind-t">
<span id="signal-kind"></span><h2>Signal kind amd_signal_kind_t<a class="headerlink" href="#signal-kind-amd-signal-kind-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="34%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>ID</td>
<td>Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td>0</td>
<td>AMD_SIGNAL_KIND_INVALID</td>
<td>An invalid signal.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>AMD_SIGNAL_KIND_USER</td>
<td>A regular signal</td>
</tr>
<tr class="row-even"><td>-1</td>
<td>AMD_SIGNAL_KIND_DOORBELL</td>
<td>Doorbell signal with hardware support</td>
</tr>
<tr class="row-odd"><td>-2</td>
<td>AMD_SIGNAL_KIND_LEGACY_DOORBELL</td>
<td>Doorbell signal with hardware support, legacy (GFX7/GFX8)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="signal-object-amd-signal-t">
<span id="signal-object"></span><h2>Signal object amd_signal_t<a class="headerlink" href="#signal-object-amd-signal-t" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="3%" />
<col width="12%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bits</th>
<th class="head">Size</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>63:0</td>
<td>8 bytes</td>
<td>kind</td>
<td>Signal kind</td>
</tr>
<tr class="row-odd"><td>127:64</td>
<td>8 bytes</td>
<td>value</td>
<td>For AMD_SIGNAL_KIND_USER: signal payload value. In small machine                                                                        model only the lower 32 bits is used, in large machine model all 64                                                                     bits are used.</td>
</tr>
<tr class="row-even"><td>127:64</td>
<td>8 bytes</td>
<td>legacy_hardware_doorbell_ptr</td>
<td>For AMD_SIGNAL_KIND_LEGACY_DOORBELL: pointer to the doorbell IOMMU                                                                      memory (write-only). Used for hardware notification in Signal Store.</td>
</tr>
<tr class="row-odd"><td>127:64</td>
<td>8 bytes</td>
<td>hardware_doorbell_ptr</td>
<td>For AMD_SIGNAL_KIND_DOORBELL: pointer to the doorbell IOMMU                                                                     memory (write-only). Used for hardware notification in Signal Store.</td>
</tr>
<tr class="row-even"><td>191:128</td>
<td>8 bytes</td>
<td>event_mailbox_ptr</td>
<td>For AMD_SIGNAL_KIND_USER: mailbox address for event notification in                                                                     Signal operations.</td>
</tr>
<tr class="row-odd"><td>223:192</td>
<td>4 bytes</td>
<td>event_id</td>
<td>For AMD_SIGNAL_KIND_USER: event id for event notification in Signal                                                                     operations.</td>
</tr>
<tr class="row-even"><td>255:224</td>
<td>4 bytes</td>
<td>&#160;</td>
<td>Padding. Must be 0.</td>
</tr>
<tr class="row-odd"><td>319:256</td>
<td>8 bytes</td>
<td>start_ts</td>
<td>Start of the AQL packet timestamp, when profiled.</td>
</tr>
<tr class="row-even"><td>383:320</td>
<td>8 bytes</td>
<td>end_ts</td>
<td>End of the AQL packet timestamp, when profiled.</td>
</tr>
<tr class="row-odd"><td>448:384</td>
<td>8 bytes</td>
<td>queue_ptr</td>
<td>For AMD_SIGNAL_KIND_*DOORBELL: the address of the associated                                                                    amd_queue_t, otherwise reserved and must be 0.</td>
</tr>
<tr class="row-even"><td>511:448</td>
<td>8 bytes</td>
<td>&#160;</td>
<td>Padding to 64 byte size. Must be 0.</td>
</tr>
<tr class="row-odd"><td>512</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Total size 64 bytes</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="signal-kernel-machine-code">
<span id="id19"></span><h2>Signal kernel machine code<a class="headerlink" href="#signal-kernel-machine-code" title="Permalink to this headline">¶</a></h2>
<p>As signal kind is determined by kind field of amd_signal_t, instruction sequence for signal operation must branch on signal kind.</p>
<p>The following is informal description of signal operations:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>For AMD_SIGNAL_KIND_USER kind:</dt>
<dd><ul class="first last">
<li>Signal Load uses atomic load from value field of corresponding amd_signal_t (memory order applies, memory scope system).</li>
<li><dl class="first docutils">
<dt>Signal Wait</dt>
<dd><ul class="first last">
<li>Uses poll loop on signal value.</li>
<li>s_sleep ISA instruction provides hint to the SQ to not to schedule the wave for a specified time.</li>
<li>s_memtime/s_memrealtime instruction is used to measure time (as signal wait is required to time out in reasonable time                  interval even if condition is not met).</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Signal Store/Signal Atomic uses the following sequence:</dt>
<dd><ul class="first last">
<li>Corresponding atomic operation on signal value (memory scope system, memory order applies).</li>
<li>Load mailbox address from event_mailbox_ptr field.</li>
<li><dl class="first docutils">
<dt>If mailbox address is not zero:</dt>
<dd><ul class="first last">
<li>load event id from event_id field.</li>
<li>atomic store of event id to mailbox address (memory scope system, memory order release).</li>
<li>s_sendmsg with argument equal to lower 8 bits of event_id.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For AMD_SIGNAL_KIND_LEGACY_DOORBELL:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Signal Store uses the following sequence:</dt>
<dd><ul class="first last">
<li>Load queue address from queue_ptr field</li>
<li><dl class="first docutils">
<dt>Acquire spinlock protecting the legacy doorbell of the queue.</dt>
<dd><ul class="first last">
<li>Load address of the spinlock from legacy_doorbell_lock field of amd_queue_t.</li>
<li>Compare-and-swap atomic loop, previous value 0, value to set 1 (memory order acquire, memory scope system).</li>
<li>s_sleep ISA instruction provides hint to the SQ to not to schedule the wave for a specified time.</li>
</ul>
</dd>
</dl>
</li>
<li>Use value+1 as next packet index and initial value for legacy dispatch id. GFX7/GFX8 hardware expects packet index to                   point beyond the last packet to be processed.</li>
<li>Atomic store of next packet index (value+1) to max_legacy_doorbell_dispatch_id_plus_1 field (memory order relaxed,              memory scope system).</li>
<li><dl class="first docutils">
<dt>For small machine model:</dt>
<dd><ul class="first last">
<li>legacy_dispatch_id = min(write_dispatch_id, read_dispatch_id + hsa_queue.size)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For GFX7:</dt>
<dd><ul class="first last">
<li>Load queue size from hsa_queue.size field of amd_queue_t.</li>
<li>Wrap packet index to a point within the ring buffer (ring buffer size is twice the size of the HSA queue).</li>
<li>Convert legacy_dispatch_id to DWORD count by multiplying by 64/4 = 16.</li>
<li>legacy_dispatch_id = (legacy_dispatch_id &amp; ((hsa_queue.size &lt;&lt; 1)-1)) &lt;&lt; 4;</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Store legacy dispatch id to the hardware MMIO doorbell.</dt>
<dd><ul class="first last">
<li>Address of the doorbell is in legacy_hardware_doorbell_ptr field of amd_signal_t.</li>
</ul>
</dd>
</dl>
</li>
<li>Release spinlock protecting the legacy doorbell of the queue. Atomic store of value 0.</li>
</ul>
</dd>
</dl>
</li>
<li>Signal Load/Signal Wait/Signal Read-Modify-Write Atomics are not supported. Instruction sequence for these operations and               this signal kind is empty.</li>
</ul>
</dd>
</dl>
</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>For AMD_SIGNAL_KIND_DOORBELL:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Signal Store uses the following sequence:</dt>
<dd><ul class="first last">
<li>Atomic store of value to the hardware MMIO doorbell.</li>
</ul>
</dd>
</dl>
</li>
<li>Signal Load/Signal Wait/Signal Read-Modify-Write Atomics are not supported. Instruction sequence for these operations and               this signal kind is empty.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="debugtrap">
<span id="id20"></span><h2>Debugtrap<a class="headerlink" href="#debugtrap" title="Permalink to this headline">¶</a></h2>
<p>Debugtrap halts execution of the wavefront and generates debug exception. For more information, refer to “HSA Programmer Reference Manual Specification”. debugtrap accepts 32-bit unsigned value as an argument.</p>
<p>The following is a description of debugtrap sequence:</p>
<blockquote>
<div><ul class="simple">
<li>v0 contains 32-bit argument of debugtrap</li>
<li>s[0:1] contains Queue Ptr for the dispatch</li>
<li>s_trap 0x1</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="references">
<span id="id21"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://www.hsafoundation.com/standards/">HSA Standards and Specifications</a></li>
<li><a class="reference external" href="www.hsafoundation.com/?ddownload=4944">HSA Platform System Architecture Specification 1.0</a></li>
<li><a class="reference external" href="www.hsafoundation.com/?ddownload=4945">HSA Programmer Reference Manual Specification 1.01</a></li>
<li><a class="reference external" href="www.hsafoundation.com/?ddownload=4946">HSA Runtime Specification 1.0</a></li>
<li><dl class="first docutils">
<dt>AMD ISA Documents</dt>
<dd><ul class="first last">
<li><a class="reference external" href="https://github.com/tpn/pdfs/blob/master/AMD%20-%20GCN3%20Instruction%20Set%20Architecture%20-%20Graphics%20Core%20Next%20Architecture%2C%20Generation%203%20(Revision%201.0%2C%20March%202015).pdf">AMD GCN3 Instruction Set Architecture (2015)</a>.</li>
<li><a class="reference external" href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/07/AMD_Southern_Islands_Instruction_Set_Architecture1.pdf">AMD_Southern_Islands_Instruction_Set_Architecture</a></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/RadeonOpenCompute/ROCR-Runtime">ROCR Runtime sources</a></dt>
<dd><ul class="first last">
<li><a class="reference external" href="https://github.com/RadeonOpenCompute/ROCR-Runtime/blob/master/src/inc/amd_hsa_kernel_code.h">amd_hsa_kernel_code.h</a></li>
<li><a class="reference external" href="https://github.com/RadeonOpenCompute/ROCR-Runtime/blob/master/src/inc/amd_hsa_queue.h">amd_hsa_queue.h</a></li>
<li><a class="reference external" href="https://github.com/RadeonOpenCompute/ROCR-Runtime/blob/master/src/inc/amd_hsa_signal.h">amd_hsa_signal.h</a></li>
<li><a class="reference external" href="https://github.com/RadeonOpenCompute/ROCR-Runtime/blob/master/src/inc/amd_hsa_common.h">amd_hsa_common.h</a></li>
</ul>
</dd>
</dl>
</li>
<li><a class="reference external" href="https://pcisig.com/specifications/pciexpress/specifications/ECN_Atomic_Ops_080417.pdf">PCI Express Atomic Operations</a></li>
</ul>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Thomas Edvalson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>