

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>“Vega” Instruction Set Architecture &mdash; ReadTheDocs-Breathe 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ReadTheDocs-Breathe
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../ROCm.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Current_Release_Notes/Current-Release-Notes.html">Current Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Installation_Guide/Installation-Guide.html">ROCm Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Programming_Guides/Programming-Guides.html">Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_GPU_Tunning_Guides/ROCm-GPU-Tunning-Guides.html">ROCm GPU Tuning Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="GCN-ISA-Manuals.html">GCN ISA Manuals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_API_References/ROCm-API-References.html">ROCm API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Tools/ROCm-Tools.html">ROCm Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Libraries/ROCm_Libraries.html">ROCm Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Compiler_SDK/ROCm-Compiler-SDK.html">ROCm Compiler SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_System_Managment/ROCm-System-Managment.html">ROCm System Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Virtualization_Containers/ROCm-Virtualization-&amp;-Containers.html">ROCm Virtualization &amp; Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Remote_Device_Programming/Remote-Device-Programming.html">Remote Device Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Deep_learning/Deep-learning.html">Deep Learning on ROCm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Other_Solutions/Other-Solutions.html">System Level Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorial/Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Glossary/ROCm-Glossary.html">ROCm Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ReadTheDocs-Breathe</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>“Vega” Instruction Set Architecture</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/GCN_ISA_Manuals/testdocbook.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vega-instruction-set-architecture">
<span id="testdocbook"></span><h1>“Vega” Instruction Set Architecture<a class="headerlink" href="#vega-instruction-set-architecture" title="Permalink to this headline">¶</a></h1>
<div class="section" id="preface">
<h2>Preface<a class="headerlink" href="#preface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="about-this-document">
<h3>About This Document<a class="headerlink" href="#about-this-document" title="Permalink to this headline">¶</a></h3>
<p>This document describes the environment, organization and program state of AMD GCN “VEGA” Generation devices. It details the instruction set and the microcode formats native to this family of processors that are accessible to programmers and compilers.</p>
<p>The document specifies the instructions (include the format of each type of instruction) and the relevant program state (including how the program state interacts with the instructions). Some instruction fields are mutually dependent; not all possible settings for all fields are legal. This document specifies the valid combinations.</p>
<p>The main purposes of this document are to:</p>
<ol class="arabic simple">
<li>Specify the language constructs and behavior, including the organization of each type of instruction in both text syntax and binary format.</li>
<li>Provide a reference of instruction operation that compiler writers can use to maximize performance of the processor.</li>
</ol>
</div>
<div class="section" id="audience">
<h3>Audience<a class="headerlink" href="#audience" title="Permalink to this headline">¶</a></h3>
<p>This document is intended for programmers writing application and system software, including operating systems, compilers, loaders, linkers,device drivers, and system utilities. It assumes that programmers are writing compute-intensive parallel applications (streaming applications) and assumes an understanding of requisite programming practices.</p>
</div>
<div class="section" id="organization">
<h3>Organization<a class="headerlink" href="#organization" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">This document begins with an overview of the AMD GCN processor’s hardware and programming environment (Chapter 1).</div>
<div class="line">Chapter 2 describes the organization of GCN programs.</div>
<div class="line">Chapter 3 describes the program state that is maintained.</div>
<div class="line">Chapter 4 describes the program flow.</div>
<div class="line">Chapter 5 describes the scalar ALU operations.</div>
<div class="line">Chapter 6 describes the vector ALU operations.</div>
<div class="line">Chapter 7 describes the scalar memory operations.</div>
<div class="line">Chapter 8 describes the vector memory operations.</div>
<div class="line">Chapter 9 provides information about the flat memory instructions.</div>
<div class="line">Chapter 10 describes the data share operations.</div>
<div class="line">Chapter 11 describes exporting the parameters of pixel color and vertex shaders.</div>
<div class="line">Chapter 12 describes instruction details, first by the microcode format to which they belong, then in alphabetic order.</div>
<div class="line">Finally, Chapter 13 provides a detailed specification of each microcode format.</div>
</div>
</div>
<div class="section" id="conventions">
<h3>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h3>
<p>The following conventions are used in this document:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mono-spaced font</td>
<td>A filename, file path or code.</td>
</tr>
<tr class="row-even"><td>*</td>
<td>Any number of alphanumeric characters in the name
of a code format, parameter, or instruction.</td>
</tr>
<tr class="row-odd"><td>&lt; &gt;</td>
<td>Angle brackets denote streams.</td>
</tr>
<tr class="row-even"><td>[1,2)</td>
<td>A range that includes the left-most value (in this
case, 1), but excludes the right-most value (in
this case, 2).</td>
</tr>
<tr class="row-odd"><td>[1,2]</td>
<td>A range that includes both the left-most and
right-most values.</td>
</tr>
<tr class="row-even"><td>{x | y}</td>
<td>One of the multiple options listed. In this case,
X or Y.</td>
</tr>
<tr class="row-odd"><td>0.0</td>
<td>A single-precision (32-bit) floating-point value.</td>
</tr>
<tr class="row-even"><td>1011b</td>
<td>A binary value, in this example a 4-bit value.</td>
</tr>
<tr class="row-odd"><td>7:4</td>
<td>A bit range, from bit 7 to bit 4, inclusive. The
high-order bit is shown first.</td>
</tr>
<tr class="row-even"><td><em>italicized word or
phrase</em></td>
<td>The first use of a term or concept basic to the
understanding of stream computing.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="related-documents">
<h3>Related Documents<a class="headerlink" href="#related-documents" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Intermediate Language (IL) Reference Manual. Published by AMD.</li>
<li>AMD Accelerated Parallel Processing OpenCL Programming Guide.
Published by AMD.</li>
<li>The OpenCL Specification. Published by Khronos Group. Aaftab Munshi,
editor.</li>
<li>OpenGL Programming Guide, at <a class="reference external" href="http://www.glprogramming.com/red/">http://www.glprogramming.com/red/</a></li>
<li>Microsoft DirectX Reference Website, here at <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee663274(v=vs.85)">DirectX</a></li>
<li>GPGPU: <a class="reference external" href="http://www.gpgpu.org">http://www.gpgpu.org</a></li>
</ul>
</div>
<div class="section" id="differences-between-vega-and-previous-devices">
<h3>Differences Between VEGA and Previous Devices<a class="headerlink" href="#differences-between-vega-and-previous-devices" title="Permalink to this headline">¶</a></h3>
<p>Summary of kernel instruction changes in Vega GPUs:</p>
<ul>
<li><p class="first">New packed 16-bit math instructions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_PK_MAD_I16</span>       <span class="n">V_PK_MUL_LO_U16</span>    <span class="n">V_PK_ADD_I16</span>       <span class="n">V_PK_SUB_I16</span>
<span class="n">V_PK_LSHLREV_B16</span>   <span class="n">V_PK_LSHRREV_B16</span>   <span class="n">V_PK_ASHRREV_I16</span>   <span class="n">V_PK_MAX_I16</span>
<span class="n">V_PK_MIN_I16</span>       <span class="n">V_PK_MAD_U16</span>       <span class="n">V_PK_ADD_U16</span>       <span class="n">V_PK_SUB_U16</span>
<span class="n">V_PK_MAX_U16</span>       <span class="n">V_PK_MIN_U16</span>       <span class="n">V_PK_FMA_F16</span>       <span class="n">V_PK_ADD_F16</span>
<span class="n">V_PK_MUL_F16</span>       <span class="n">V_PK_MIN_F16</span>       <span class="n">V_PK_MAX_F16</span>       <span class="n">V_MAD_MIX_F32</span>
<span class="n">V_MAD_MIXLO_F16</span>    <span class="n">V_MAD_MIXHI_F16</span>    <span class="n">S_PACK_</span><span class="p">{</span><span class="n">LL</span><span class="p">,</span><span class="n">LH</span><span class="p">,</span><span class="n">HH</span><span class="p">}</span><span class="n">_B16_B32</span>
</pre></div>
</div>
</li>
<li><p class="first">TMA and TBA registers are stored one per VM-ID, not per draw or
dispatch.</p>
</li>
<li><p class="first">Added Image operations support 16-bit address and data.</p>
</li>
<li><p class="first">Added Global and Scratch memory read/write operations.</p>
<ul class="simple">
<li>Also added Scratch load/store to scalar memory.</li>
</ul>
</li>
<li><p class="first">Added Scalar memory atomic instructions.</p>
</li>
<li><p class="first">MIMG Microcode format: removed the R128 bit.</p>
</li>
<li><p class="first">FLAT Microcode format: added an offset field.</p>
</li>
<li><p class="first">Removed V_MOVEREL instructions.</p>
</li>
<li><p class="first">Added control over arithmetic overflow for FP16 VALU operations.</p>
</li>
<li><p class="first">Modified bit packing of surface descriptors and samplers:</p>
<ul class="simple">
<li>T#: removed heap, elem_size, last_array, interlaced,
uservm_mode bits.</li>
<li>V#: removed mtype.</li>
<li>S#: removed astc_hdr field.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="contact-information">
<h3>Contact Information<a class="headerlink" href="#contact-information" title="Permalink to this headline">¶</a></h3>
<p>For information concerning AMD Accelerated Parallel Processing developing, please see: <a class="reference external" href="http://developer.amd.com/">http://developer.amd.com/</a> .</p>
<p>For information about developing with AMD Accelerated Parallel Processing, please see: <a class="reference external" href="http://developer.amd.com/amd-accelerated-parallel-processing-app-sdk/">http://developer.amd.com/amd-accelerated-parallel-processing-app-sdk/</a> .</p>
<p>We also have a growing community of AMD Accelerated Parallel Processing users. Come visit us at the AMD Accelerated Parallel Processing Developer Forum ( <a class="reference external" href="http://developer.amd.com/openclforum">http://developer.amd.com/openclforum</a> ) to find out what applications other users are trying on their AMD Accelerated Parallel Processing products.</p>
</div>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>AMD GCN processors implement a parallel micro-architecture that provides an excellent platform not only for computer graphics applications but also for general-purpose data parallel applications. Any data-intensive application that requires high bandwidth or is computationally intensive is a candidate for running on an AMD GCN processor.</p>
<p>The figure below shows a block diagram of the AMD GCN Vega Generation series processors</p>
<div class="figure">
<img alt="../_images/fig_1_1_vega.png" src="../_images/fig_1_1_vega.png" />
</div>
<p>AMD GCN VEGA Generation Series Block Diagram</p>
<p>The GCN device includes a data-parallel processor (DPP) array, a command processor, a memory controller, and other logic (not shown). The GCN command processor reads commands that the host has written to memory-mapped GCN registers in the system-memory address space. The command processor sends hardware-generated interrupts to the host when the command is completed. The GCN memory controller has direct access to all GCN device memory and the host-specified areas of system memory. To satisfy read and write requests, the memory controller performs the functions of a direct-memory access (DMA) controller, including computing memory-address offsets based on the format of the requested data in memory. In the GCN environment, a complete application includes two parts:
-  a program running on the host processor, and</p>
<ul class="simple">
<li>programs, called kernels, running on the GCN processor.</li>
</ul>
<p>The GCN programs are controlled by host commands that</p>
<ul class="simple">
<li>set GCN internal base-address and other configuration registers,</li>
<li>specify the data domain on which the GCN GPU is to operate,</li>
<li>invalidate and flush caches on the GCN GPU, and</li>
<li>cause the GCN GPU to begin execution of a program.</li>
</ul>
<p>The GCN driver program runs on the host.</p>
<p>The DPP array is the heart of the GCN processor. The array is organized as a set of compute unit pipelines, each independent from the others, that operate in parallel on streams of floating-point or integer data.The compute unit pipelines can process data or, through the memory controller, transfer data to, or from, memory. Computation in a compute unit pipeline can be made conditional. Outputs written to memory can also be made conditional.</p>
<p>When it receives a request, the compute unit pipeline loads instructions and data from memory, begins execution, and continues until the end of the kernel. As kernels are running, the GCN hardware automatically fetches instructions from memory into on-chip caches; GCN software plays no role in this. GCN kernels can load data from off-chip memory into on-chip general-purpose registers (GPRs) and caches.</p>
<p>The AMD GCN devices can detect floating point exceptions and can generate interrupts. In particular, they detect IEEE floating-point
exceptions in hardware; these can be recorded for post-execution analysis. The software interrupts shown in the previous figure from the command processor to the host represent hardware-generated interrupts for signaling command-completion and related management functions.</p>
<p>The GCN processor hides memory latency by keeping track of potentially hundreds of work-items in different stages of execution, and by
overlapping compute operations with memory-access operations.</p>
<p>The figure below shows the dataflow for a GCN application. For general-purpose applications, only one processing block performs all
computation.</p>
<div class="figure" id="id14">
<img alt="GCN VEGA Generation Dataflow" src="../_images/fig_1_2.png" />
<p class="caption"><span class="caption-text">GCN VEGA Generation Dataflow</span></p>
</div>
<div class="section" id="terminology">
<h3>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Term</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GCN Processor</td>
<td>The Graphics Core Next shader processor is a
scalar and vector ALU capable of running complex
programs on behalf of a wavefront.</td>
</tr>
<tr class="row-odd"><td>Dispatch</td>
<td>A dispatch launches a 1D, 2D, or 3D grid of work
to the GCN processor array.</td>
</tr>
<tr class="row-even"><td>Workgroup</td>
<td>A workgroup is a collection of wavefronts that
have the ability to synchronize with each other
quickly; they also can share data through the
Local Data Share.</td>
</tr>
<tr class="row-odd"><td>Wavefront</td>
<td>A collection of 64 work-items that execute in
parallel on a single GCN processor.</td>
</tr>
<tr class="row-even"><td>Work-item</td>
<td>A single element of work: one element from the
dispatch grid, or in graphics a pixel or vertex.</td>
</tr>
<tr class="row-odd"><td>Literal Constant</td>
<td>A 32-bit integer or float constant that is placed
in the instruction stream.</td>
</tr>
<tr class="row-even"><td>Scalar ALU (SALU)</td>
<td>The scalar ALU operates on one value per wavefront
and manages all control flow.</td>
</tr>
<tr class="row-odd"><td>Vector ALU (VALU)</td>
<td>The vector ALU maintains Vector GPRs that are
unique for each work item and execute arithmetic
operations uniquely on each work-item.</td>
</tr>
<tr class="row-even"><td>Microcode format</td>
<td>The microcode format describes the bit patterns
used to encode instructions. Each instruction is
either 32 or 64 bits.</td>
</tr>
<tr class="row-odd"><td>Instruction</td>
<td>An instruction is the basic unit of the kernel.
Instructions include: vector ALU, scalar ALU,
memory transfer, and control flow operations.</td>
</tr>
<tr class="row-even"><td>Quad</td>
<td>A quad is a 2x2 group of screen-aligned pixels.
This is relevant for sampling texture maps.</td>
</tr>
<tr class="row-odd"><td>Texture Sampler</td>
<td>A texture sampler is a 128-bit entity that
describes how the vector memory system reads and
samples (filters) a texture map.</td>
</tr>
<tr class="row-even"><td>Texture Resource</td>
<td>A texture resource describes a block of memory:
address, data format, stride, etc.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Basic Terms Uses</strong></div></blockquote>
</div>
</div>
<div class="section" id="program-organization">
<h2>Program Organization<a class="headerlink" href="#program-organization" title="Permalink to this headline">¶</a></h2>
<p>GCN kernels are programs executed by the GCN processor. Conceptually, the kernel is executed independently on every work-item, but in reality the GCN processor groups 64 work-items into a wavefront, which executes the kernel on all 64 work-items in one pass.</p>
<p>The GCN processor consists of:</p>
<ul class="simple">
<li>A scalar ALU, which operates on one value per wavefront (common to all work items).</li>
<li>A vector ALU, which operates on unique values per work-item.</li>
<li>Local data storage, which allows work-items within a workgroup to communicate and share data.</li>
<li>Scalar memory, which can transfer data between SGPRs and memory through a cache.</li>
<li>Vector memory, which can transfer data between VGPRs and memory,including sampling texture maps.</li>
</ul>
<p>All kernel control flow is handled using scalar ALU instructions. This includes if/else, branches and looping. Scalar ALU (SALU) and memory instructions work on an entire wavefront and operate on up to two SGPRs,as well as literal constants.</p>
<p>Vector memory and ALU instructions operate on all work-items in the wavefront at one time. In order to support branching and conditional execute, every wavefront has an EXECute mask that determines which work-items are active at that moment, and which are dormant. Active work-items execute the vector instruction, and dormant ones treat the instruction as a NOP. The EXEC mask can be changed at any time by Scalar ALU instructions.</p>
<p>Vector ALU instructions can take up to three arguments, which can come from VGPRs, SGPRs, or literal constants that are part of the instruction stream. They operate on all work-items enabled by the EXEC mask. Vector compare and add with- carryout return a bit-per-work-item mask back to the SGPRs to indicate, per work-item, which had a “true” result from the compare or generated a carry-out.</p>
<p>Vector memory instructions transfer data between VGPRs and memory. Each work-item supplies its own memory address and supplies or receives unique data. These instructions are also subject to the EXEC mask.</p>
<div class="section" id="compute-shaders">
<h3>Compute Shaders<a class="headerlink" href="#compute-shaders" title="Permalink to this headline">¶</a></h3>
<p>Compute kernels (shaders) are generic programs that can run on the GCN processor, taking data from memory, processing it, and writing results back to memory. Compute kernels are created by a dispatch, which causes the GCN processors to run the kernel over all of the work-items in a 1D, 2D, or 3D grid of data. The GCN processor walks through this grid and generates wavefronts, which then run the compute kernel. Each work-item is initialized with its unique address (index) within the grid. Based on this index, the work-item computes the address of the data it is required to work on and what to do with the results.</p>
</div>
<div class="section" id="data-sharing">
<h3>Data Sharing<a class="headerlink" href="#data-sharing" title="Permalink to this headline">¶</a></h3>
<p>The AMD GCN stream processors can share data between different work-items. Data sharing can significantly boost performance. The figure below shows the memory hierarchy that is available to each work-item.</p>
<div class="figure" id="id15">
<img alt="Shared Memory Hierarchy" src="../_images/fig_2_1_vega.png" />
<p class="caption"><span class="caption-text">Shared Memory Hierarchy</span></p>
</div>
<div class="section" id="local-data-share-lds">
<h4>Local Data Share (LDS)<a class="headerlink" href="#local-data-share-lds" title="Permalink to this headline">¶</a></h4>
<p>Each compute unit has a 64 kB memory space that enables low-latency communication between work-items within a work-group, or the work-items within a wavefront; this is the local data share (LDS). This memory is configured with 32 banks, each with 512 entries of 4 bytes. The AMD GCN processors use a 64 kB local data share (LDS) memory for each compute unit; this enables 64 kB of low-latency bandwidth to the processing elements. The shared memory contains 32 integer atomic units to enable fast, unordered atomic operations. This memory can be used as a software cache for predictable re-use of data, a data exchange machine for the work-items of a work-group, or as a cooperative way to enable efficient access to off-chip memory.</p>
</div>
<div class="section" id="global-data-share-gds">
<h4>Global Data Share (GDS)<a class="headerlink" href="#global-data-share-gds" title="Permalink to this headline">¶</a></h4>
<p>The AMD GCN devices use a 64 kB global data share (GDS) memory that can be used by wavefronts of a kernel on all compute units. This memory provides 128 bytes per cycle of memory access to all the processing elements. The GDS is configured with 32 banks, each with 512 entries of 4 bytes each. It provides full access to any location for any processor. The shared memory contains 32 integer atomic units to enable fast, unordered atomic operations. This memory can be used as a software cache to store important control data for compute kernels, reduction operations, or a small global shared surface. Data can be preloaded from memory prior to kernel launch and written to memory after kernel completion. The GDS block contains support logic for unordered append/consume and domain launch ordered append/consume operations to buffers in memory. These dedicated circuits enable fast compaction of data or the creation of complex data structures in memory.</p>
</div>
</div>
<div class="section" id="device-memory">
<h3>Device Memory<a class="headerlink" href="#device-memory" title="Permalink to this headline">¶</a></h3>
<p>The AMD GCN devices offer several methods for access to off-chip memory from the processing elements (PE) within each compute unit. On the primary read path, the device consists of multiple channels of L2 read-only cache that provides data to an L1 cache for each compute unit. Special cache-less load instructions can force data to be retrieved from device memory during an execution of a load clause. Load requests that overlap within the clause are cached with respect to each other. The output cache is formed by two levels of cache: the first for write-combining cache (collect scatter and store operations and combine them to provide good access patterns to memory); the second is a read/write cache with atomic units that lets each processing element complete unordered atomic accesses that return the initial value. Each processing element provides the destination address on which the atomic operation acts, the data to be used in the atomic operation, and a return address for the read/write atomic unit to store the pre-op value in memory. Each store or atomic operation can be set up to return an acknowledgment to the requesting PE upon write confirmation of the return value (pre-atomic op value at destination) being stored to device memory.</p>
<p>This acknowledgment has two purposes:</p>
<ul class="simple">
<li>enabling a PE to recover the pre-op value from an atomic operation by performing a cache-less load from its return address after     receipt of the write confirmation acknowledgment, and</li>
<li>enabling the system to maintain a relaxed consistency model.</li>
</ul>
<p>Each scatter write from a given PE to a given memory channel always maintains order. The acknowledgment enables one processing element to implement a fence to maintain serial consistency by ensuring all writes have been posted to memory prior to completing a subsequent write. In this manner, the system can maintain a relaxed consistency model between all parallel work-items operating on the system.</p>
</div>
</div>
<div class="section" id="kernel-state">
<h2>Kernel State<a class="headerlink" href="#kernel-state" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes the kernel states visible to the shader program.</p>
<div class="section" id="state-overview">
<h3>State Overview<a class="headerlink" href="#state-overview" title="Permalink to this headline">¶</a></h3>
<p>The table below shows all of the hardware states readable or writable by
a shader program.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="28%" />
<col width="10%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Abbrev.</th>
<th class="head">Name</th>
<th class="head">Size
(bits)</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PC</td>
<td>Program Counter</td>
<td>48</td>
<td>Points to the memory address of
the next shader instruction to
execute.</td>
</tr>
<tr class="row-odd"><td>V0-V255</td>
<td>VGPR</td>
<td>32</td>
<td>Vector general-purpose register.</td>
</tr>
<tr class="row-even"><td>S0-S103</td>
<td>SGPR</td>
<td>32</td>
<td>Vector general-purpose register.</td>
</tr>
<tr class="row-odd"><td>LDS</td>
<td>Local Data Share</td>
<td>64kB</td>
<td>Local data share is a scratch RAM
with built-in arithmetic
capabilities that allow data to
be shared between threads in a
workgroup.</td>
</tr>
<tr class="row-even"><td>EXEC</td>
<td>Execute Mask</td>
<td>64</td>
<td>A bit mask with one bit per
thread, which is applied to
vector instructions and controls
that threads execute and that
ignore the instruction.</td>
</tr>
<tr class="row-odd"><td>EXECZ</td>
<td>EXEC is zero</td>
<td>1</td>
<td>A single bit flag indicating that
the EXEC mask is all zeros.</td>
</tr>
<tr class="row-even"><td>VCC</td>
<td>Vector Condition
Code</td>
<td>64</td>
<td>A bit mask with one bit per
thread; it holds the result of a
vector compare operation.</td>
</tr>
<tr class="row-odd"><td>VCCZ</td>
<td>VCC is zero</td>
<td>1</td>
<td>A single bit-flag indicating that
the VCC mask is all zeros.</td>
</tr>
<tr class="row-even"><td>SCC</td>
<td>Scalar Condition
Code</td>
<td>1</td>
<td>Result from a scalar ALU
comparison instruction.</td>
</tr>
<tr class="row-odd"><td>FLAT_SCRATC
H</td>
<td>Flat scratch address</td>
<td>64</td>
<td>The base address of scratch
memory.</td>
</tr>
<tr class="row-even"><td>XNACK_MASK</td>
<td>Address translation
failure.</td>
<td>64</td>
<td>Bit mask of threads that have
failed their address translation.</td>
</tr>
<tr class="row-odd"><td>STATUS</td>
<td>Status</td>
<td>32</td>
<td>Read-only shader status bits.</td>
</tr>
<tr class="row-even"><td>MODE</td>
<td>Mode</td>
<td>32</td>
<td>Writable shader mode bits.</td>
</tr>
<tr class="row-odd"><td>M0</td>
<td>Memory Reg</td>
<td>32</td>
<td>A temporary register that has
various uses, including GPR
indexing and bounds checking.</td>
</tr>
<tr class="row-even"><td>TRAPSTS</td>
<td>Trap Status</td>
<td>32</td>
<td>Holds information about
exceptions and pending traps.</td>
</tr>
<tr class="row-odd"><td>TBA</td>
<td>Trap Base Address</td>
<td>64</td>
<td>Holds the pointer to the current
trap handler program.</td>
</tr>
<tr class="row-even"><td>TMA</td>
<td>Trap Memory Address</td>
<td>64</td>
<td>Temporary register for shader
operations. For example, can hold
a pointer to memory used by the
trap handler.</td>
</tr>
<tr class="row-odd"><td>TTMP0-TTMP15</td>
<td>Trap Temporary SGPRs</td>
<td>32</td>
<td>16 SGPRs available only to the
Trap Handler for temporary
storage.</td>
</tr>
<tr class="row-even"><td>VMCNT</td>
<td>Vector memory
instruction count</td>
<td>6</td>
<td>Counts the number of VMEM
instructions issued but not yet
completed.</td>
</tr>
<tr class="row-odd"><td>EXPCNT</td>
<td>Export Count</td>
<td>3</td>
<td>Counts the number of Export and
GDS instructions issued but not
yet completed. Also counts VMEM
writes that have not yet sent
their write-data to the TC.</td>
</tr>
<tr class="row-even"><td>LGKMCNT</td>
<td>LDS, GDS, Constant
and Message count</td>
<td>4</td>
<td>Counts the number of LDS, GDS,
constant-fetch (scalar memory
read), and message instructions
issued but not yet completed.</td>
</tr>
</tbody>
</table>
<p><strong>Table : Readable and Writable Hardware States</strong></p>
</div>
<div class="section" id="program-counter-pc">
<h3>Program Counter (PC)<a class="headerlink" href="#program-counter-pc" title="Permalink to this headline">¶</a></h3>
<p>The program counter (PC) is a byte address pointing to the next instruction to execute. When a wavefront is created, the PC is
initialized to the first instruction in the program.</p>
<p>The PC interacts with three instructions: S_GET_PC, S_SET_PC,S_SWAP_PC. These transfer the PC to, and from, an even-aligned SGPR
pair.</p>
<p>Branches jump to (PC_of_the_instruction_after_the_branch +offset). The shader program cannot directly read from, or write to, the PC. Branches, GET_PC and SWAP_PC, are PC-relative to the next instruction, not the current one. S_TRAP saves the PC of the S_TRAP instruction itself.</p>
</div>
<div class="section" id="execute-mask">
<h3>EXECute Mask<a class="headerlink" href="#execute-mask" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">The Execute mask (64-bit) determines which threads in the vector are
executed:</div>
<div class="line"><strong>1 = execute, 0 = do not execute.</strong></div>
</div>
<p>EXEC can be read from, and written to, through scalar instructions; it also can be written as a result of a vector-ALU compare. This mask affects vector-ALU, vector-memory, LDS, and export instructions. It does not affect scalar execution or branches.</p>
<p>A helper bit (EXECZ) can be used as a condition for branches to skip code when EXEC is zero.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This GPU does no optimization when EXEC = 0. The shader hardware executes every instruction, wasting instruction issue bandwidth. Use CBRANCH or VSKIP to rapidly skip over code when it is likely that the EXEC mask is zero.</p>
</div>
</div>
<div class="section" id="status-registers">
<h3>Status registers<a class="headerlink" href="#status-registers" title="Permalink to this headline">¶</a></h3>
<p>Status register fields can be read, but not written to, by the shader.These bits are initialized at wavefront-creation time. The table below lists and briefly describes the status register fields.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="12%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bit
Positio
n</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SCC</td>
<td>1</td>
<td>Scalar condition code. Used as a carry-out bit.
For a comparison instruction, this bit
indicates failure or success. For logical
operations, this is 1 if the result was
non-zero.</td>
</tr>
<tr class="row-odd"><td>SPI_PRIO</td>
<td>2:1</td>
<td>Wavefront priority set by the shader processor
interpolator (SPI) when the wavefront is
created. See the S_SETPRIO instruction (page
12-49) for details. 0 is lowest, 3 is highest
priority.</td>
</tr>
<tr class="row-even"><td>WAVE_PRIO</td>
<td>4:3</td>
<td>Wavefront priority set by the shader program.
See the S_SETPRIO instruction (page 12-49) for
details.</td>
</tr>
<tr class="row-odd"><td>PRIV</td>
<td>5</td>
<td>Privileged mode. Can only be active when in the
trap handler. Gives write access to the TTMP,
TMA, and TBA registers.</td>
</tr>
<tr class="row-even"><td>TRAP_EN</td>
<td>6</td>
<td>Indicates that a trap handler is present. When
set to zero, traps are not taken.</td>
</tr>
<tr class="row-odd"><td>TTRACE_EN</td>
<td>7</td>
<td>Indicates whether thread trace is enabled for
this wavefront. If zero, also ignore any
shader-generated (instruction) thread-trace
data.</td>
</tr>
<tr class="row-even"><td>EXPORT_RDY</td>
<td>8</td>
<td>This status bit indicates if export buffer
space has been allocated. The shader stalls any
export instruction until this bit becomes 1. It
is set to 1 when export buffer space has been
allocated. Before a Pixel or Vertex shader can
export, the hardware checks the state of this
bit. If the bit is 1, export can be issued. If
the bit is zero, the wavefront sleeps until
space becomes available in the export buffer.
Then, this bit is set to 1, and the wavefront
resumes.</td>
</tr>
<tr class="row-odd"><td>EXECZ</td>
<td>9</td>
<td>Exec mask is zero.</td>
</tr>
<tr class="row-even"><td>VCCZ</td>
<td>10</td>
<td>Vector condition code is zero.</td>
</tr>
<tr class="row-odd"><td>IN_TG</td>
<td>11</td>
<td>Wavefront is a member of a work-group of more
than one wavefront.</td>
</tr>
<tr class="row-even"><td>IN_BARRIER</td>
<td>12</td>
<td>Wavefront is waiting at a barrier.</td>
</tr>
<tr class="row-odd"><td>HALT</td>
<td>13</td>
<td>Wavefront is halted or scheduled to halt. HALT
can be set by the host through
wavefront-control messages, or by the shader.
This bit is ignored while in the trap handler
(PRIV = 1); it also is ignored if a
host-initiated trap is received (request to
enter the trap handler).</td>
</tr>
<tr class="row-even"><td>TRAP</td>
<td>14</td>
<td>Wavefront is flagged to enter the trap handler
as soon as possible.</td>
</tr>
<tr class="row-odd"><td>TTRACE_CU_EN</td>
<td>15</td>
<td>Enables/disables thread trace for this compute
unit (CU). This bit allows more than one CU to
be outputting USERDATA (shader initiated writes
to the thread-trace buffer). Note that
wavefront data is only traced from one CU per
shader array. Wavefront user data (instruction
based) can be output if this bit is zero.</td>
</tr>
<tr class="row-even"><td>VALID</td>
<td>16</td>
<td>Wavefront is active (has been created and not
yet ended).</td>
</tr>
<tr class="row-odd"><td>ECC_ERR</td>
<td>17</td>
<td>An ECC error has occurred.</td>
</tr>
<tr class="row-even"><td>SKIP_EXPORT</td>
<td>18</td>
<td>For Vertex Shaders only. 1 = this shader is not
allocated export buffer space; all export
instructions are ignored (treated as NOPs).
Formerly called VS_NO_ALLOC. Used for
stream-out of multiple streams (multiple passes
over the same VS), and for DS running in the VS
stage for wavefronts that produced no
primitives.</td>
</tr>
<tr class="row-odd"><td>PERF_EN</td>
<td>19</td>
<td>Performance counters are enabled for this
wavefront.</td>
</tr>
<tr class="row-even"><td>COND_DBG_USER</td>
<td>20</td>
<td>Conditional debug indicator for user mode</td>
</tr>
<tr class="row-odd"><td>COND_DBG_SYS</td>
<td>21</td>
<td>Conditional debug indicator for system mode.</td>
</tr>
<tr class="row-even"><td>ALLOW_REPLAY</td>
<td>22</td>
<td>Indicates that ATC replay is enabled.</td>
</tr>
<tr class="row-odd"><td>MUST_EXPORT</td>
<td>27</td>
<td>This wavefront is required to perform an export
with Done=1 before terminating.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Status Register Fields</strong></div></blockquote>
</div>
<div class="section" id="mode-register">
<h3>Mode register<a class="headerlink" href="#mode-register" title="Permalink to this headline">¶</a></h3>
<p>Mode register fields can be read from, and written to, by the shader
through scalar instructions. The table below lists and briefly describes
the mode register fields.</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bit
Positio
n</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FP_ROUND</td>
<td>3:0</td>
<td><div class="first last line-block">
<div class="line">[1:0] Single precision round mode. [3:2]
Double precision round mode.</div>
<div class="line">Round Modes: 0=nearest even, 1= +infinity, 2=
-infinity, 3= toward zero.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>FP_DENORM</td>
<td>7:4</td>
<td><div class="first last line-block">
<div class="line">[1:0] Single denormal mode. [3:2] Double
denormal mode. Denorm modes:</div>
<div class="line">0 = flush input and output denorms.</div>
<div class="line">1 = allow input denorms, flush output denorms.</div>
<div class="line">2 = flush input denorms, allow output denorms.</div>
<div class="line">3 = allow input and output denorms.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>DX10_CLAMP</td>
<td>8</td>
<td>Used by the vector ALU to force DX10-style
treatment of NaNs: when set, clamp NaN to zero;
otherwise, pass NaN through.</td>
</tr>
<tr class="row-odd"><td>IEEE</td>
<td>9</td>
<td>Floating point opcodes that support exception
flag gathering quiet and propagate signaling NaN
inputs per IEEE 754-2008. Min_dx10 and
max_dx10 become IEEE 754-2008 compliant due to
signaling NaN propagation and quieting.</td>
</tr>
<tr class="row-even"><td>LOD_CLAMPED</td>
<td>10</td>
<td>Sticky bit indicating that one or more texture
accesses had their LOD clamped.</td>
</tr>
<tr class="row-odd"><td>DEBUG</td>
<td>11</td>
<td>Forces the wavefront to jump to the exception
handler after each instruction is executed (but
not after ENDPGM). Only works if TRAP_EN = 1.</td>
</tr>
<tr class="row-even"><td>EXCP_EN</td>
<td>18:12</td>
<td><div class="first last line-block">
<div class="line">Enable mask for exceptions. Enabled means if
the exception occurs and TRAP_EN==1, a trap
is taken.</div>
<div class="line">[12] : invalid.</div>
<div class="line">[13] : inputDenormal.</div>
<div class="line">[14] : float_div0.</div>
<div class="line">[15] : overflow.</div>
<div class="line">[16] : underflow.</div>
<div class="line">[17] : inexact.</div>
<div class="line">[18] : int_div0.</div>
<div class="line">[19] : address watch</div>
<div class="line">[20] : memory violation</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>FP16_OVFL</td>
<td>23</td>
<td>If set, an overflowed FP16 result is clamped to
+/- MAX_FP16, regardless of round mode, while
still preserving true INF values.</td>
</tr>
<tr class="row-even"><td>POPS_PACKER0</td>
<td>24</td>
<td>1 = this wave is associated with packer 0. User
shader must set this to !PackerID from the POPS
initialized SGPR (load_collision_waveID), or
zero if not using POPS.</td>
</tr>
<tr class="row-odd"><td>POPS_PACKER1</td>
<td>25</td>
<td>1 = this wave is associated with packer 1. User
shader must set this to PackerID from the POPS
initialized SGPR (load_collision_waveID), or
zero if not using POPS.</td>
</tr>
<tr class="row-even"><td>DISABLE_PERF</td>
<td>26</td>
<td>1 = disable performance counting for this wave</td>
</tr>
<tr class="row-odd"><td>GPR_IDX_EN</td>
<td>27</td>
<td>GPR index enable.</td>
</tr>
<tr class="row-even"><td>VSKIP</td>
<td>28</td>
<td>0 = normal operation. 1 = skip (do not execute)
any vector instructions: valu, vmem, export,
lds, gds. “Skipping” instructions occurs at
high-speed (10 wavefronts per clock cycle can
skip one instruction). This is much faster than
issuing and discarding instructions.</td>
</tr>
<tr class="row-odd"><td>CSP</td>
<td>31:29</td>
<td>Conditional branch stack pointer.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Mode Register Fields</strong></div></blockquote>
</div>
<div class="section" id="gprs-and-lds">
<h3>GPRs and LDS<a class="headerlink" href="#gprs-and-lds" title="Permalink to this headline">¶</a></h3>
<p>This section describes how GPR and LDS space is allocated to a wavefront, as well as how out-of-range and misaligned accesses are
handled.</p>
<div class="section" id="out-of-range-behavior">
<h4>Out-of-Range behavior<a class="headerlink" href="#out-of-range-behavior" title="Permalink to this headline">¶</a></h4>
<p>This section defines the behavior when a source or destination GPR or memory address is outside the legal range for a wavefront.</p>
<p>Out-of-range can occur through GPR-indexing or bad programming. It is illegal to index from one register type into another (for example: SGPRs into trap registers or inline constants). It is also illegal to index within inline constants.</p>
<p>The following describe the out-of-range behavior for various storage types.</p>
<ul class="simple">
<li>SGPRs<ul>
<li>Source or destination out-of-range = (sgpr &lt; 0 || (sgpr &gt;=
sgpr_size)).</li>
<li>Source out-of-range: returns the value of SGPR0 (not the value 0).</li>
<li>Destination out-of-range: instruction writes no SGPR result.</li>
</ul>
</li>
<li>VGPRs<ul>
<li>Similar to SGPRs. It is illegal to index from SGPRs into VGPRs, or
vice versa.</li>
<li>Out-of-range = (vgpr &lt; 0 || (vgpr &gt;= vgpr_size))</li>
<li>If a source VGPR is out of range, VGPR0 is used.</li>
<li>If a destination VGPR is out-of-range, the instruction is ignored
(treated as an NOP).</li>
</ul>
</li>
<li>LDS<ul>
<li>If the LDS-ADDRESS is out-of-range (addr &lt; 0 or &gt; (MIN(lds_size,
m0)):<ul>
<li>Writes out-of-range are discarded; it is undefined if SIZE is
not a multiple of write-data-size.</li>
<li>Reads return the value zero.</li>
</ul>
</li>
<li>If any source-VGPR is out-of-range, use the VGPR0 value is used.</li>
<li>If the dest-VGPR is out of range, nullify the instruction (issue
with exec=0)</li>
</ul>
</li>
<li>Memory, LDS, and GDS: Reads and atomics with returns.<ul>
<li>If any source VGPR or SGPR is out-of-range, the data value is
undefined.</li>
<li>If any destination VGPR is out-of-range, the operation is
nullified by issuing the instruction as if the EXEC mask were
cleared to 0.<ul>
<li>This out-of-range check must check all VGPRs that can be
returned (for example: VDST to VDST+3 for a
BUFFER_LOAD_DWORDx4).</li>
<li>This check must also include the extra PRT (partially resident
texture) VGPR and nullify the fetch if this VGPR is
out-of-range, no matter whether the texture system actually
returns this value or not.</li>
<li>Atomic operations with out-of-range destination VGPRs are
nullified: issued, but with exec mask of zero.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Instructions with multiple destinations (for example: V_ADDC): if any destination is out-of-range, no results are written.</p>
</div>
<div class="section" id="sgpr-allocation-and-storage">
<h4>SGPR Allocation and storage<a class="headerlink" href="#sgpr-allocation-and-storage" title="Permalink to this headline">¶</a></h4>
<p>A wavefront can be allocated 16 to 102 SGPRs, in units of 16 GPRs (Dwords). These are logically viewed as SGPRs 0-101. The VCC is
physically stored as part of the wavefront’s SGPRs in the highest numbered two SGPRs (SGPR 106 and 107; the source/destination VCC is an alias for those two SGPRs). When a trap handler is present, 16 additional SGPRs are reserved after VCC to hold the trap addresses, as well as saved-PC and trap-handler temps. These all are privileged (cannot be written to unless privilege is set). Note that if a wavefront allocates 16 SGPRs, 2 SGPRs are normally used as VCC, the remaining 14 are available to the shader. Shader hardware does not prevent use of all 16 SGPRs.</p>
</div>
<div class="section" id="sgpr-alignment">
<h4>SGPR Alignment<a class="headerlink" href="#sgpr-alignment" title="Permalink to this headline">¶</a></h4>
<p>Even-aligned SGPRs are required in the following cases.</p>
<ul class="simple">
<li>When 64-bit data is used. This is required for moves to/from 64-bit
registers, including the PC.</li>
<li>When scalar memory reads that the address-base comes from an
SGPR-pair (either in SGPR).</li>
</ul>
<p>Quad-alignment is required for the data-GPR when a scalar memory read returns four or more Dwords. When a 64-bit quantity is stored in SGPRs, the LSBs are in SGPR[n], and the MSBs are in SGPR[n+1].</p>
</div>
<div class="section" id="vgpr-allocation-and-alignment">
<h4>VGPR Allocation and Alignment<a class="headerlink" href="#vgpr-allocation-and-alignment" title="Permalink to this headline">¶</a></h4>
<p>VGPRs are allocated in groups of four Dwords. Operations using pairs of VGPRs (for example: double-floats) have no alignment restrictions. Physically, allocations of VGPRs can wrap around the VGPR memory pool.</p>
</div>
<div class="section" id="lds-allocation-and-clamping">
<h4>LDS Allocation and Clamping<a class="headerlink" href="#lds-allocation-and-clamping" title="Permalink to this headline">¶</a></h4>
<p>LDS is allocated per work-group or per-wavefront when work-groups are not in use. LDS space is allocated to a work-group or wavefront in contiguous blocks of 128 Dwords on 128-Dword alignment. LDS allocations do not wrap around the LDS storage. All accesses to LDS are restricted to the space allocated to that wavefront/work-group.</p>
<p>Clamping of LDS reads and writes is controlled by two size registers, which contain values for the size of the LDS space allocated by SPI to this wavefront or work-group, and a possibly smaller value specified in the LDS instruction (size is held in M0). The LDS operations use the smaller of these two sizes to determine how to clamp the read/write addresses.</p>
</div>
</div>
<div class="section" id="m-memory-descriptor">
<h3>M# Memory Descriptor<a class="headerlink" href="#m-memory-descriptor" title="Permalink to this headline">¶</a></h3>
<p>There is one 32-bit M# (M0) register per wavefront, which can be used
for:</p>
<ul class="simple">
<li>Local Data Share (LDS)<ul>
<li>Interpolation: holds { 1’b0, new_prim_mask[15:1],
parameter_offset[15:0] } // in bytes</li>
<li>LDS direct-read offset and data type: { 13’b0, DataType[2:0],
LDS_address[15:0] } // addr in bytes</li>
<li>LDS addressing for Memory/Vfetch → LDS: {16’h0, lds_offset[15:0]}
// in bytes</li>
</ul>
</li>
<li>Global Data Share (GDS)<ul>
<li>{ base[15:0] , size[15:0] } // base and size are in bytes</li>
</ul>
</li>
<li>Indirect GPR addressing for both vector and scalar instructions. M0
is an unsigned index.</li>
<li>Send-message value. EMIT/CUT use M0 and EXEC as the send-message
data.</li>
</ul>
</div>
<div class="section" id="scc-scalar-condition-code">
<h3>SCC: Scalar Condition code<a class="headerlink" href="#scc-scalar-condition-code" title="Permalink to this headline">¶</a></h3>
<p>Most scalar ALU instructions set the Scalar Condition Code (SCC) bit,indicating the result of the operation.</p>
<div class="informalexample"><div class="line-block">
<div class="line">Compare operations: 1 = true</div>
<div class="line">Arithmetic operations: 1 = carry out</div>
<div class="line">Bit/logical operations: 1 = result was not zero</div>
<div class="line">Move: does not alter SCC</div>
</div>
</div><p>The SCC can be used as the carry-in for extended-precision integer arithmetic, as well as the selector for conditional moves and branches.</p>
</div>
<div class="section" id="vector-compares-vcc-and-vccz">
<h3>Vector Compares: VCC and VCCZ<a class="headerlink" href="#vector-compares-vcc-and-vccz" title="Permalink to this headline">¶</a></h3>
<p>Vector ALU comparisons always set the Vector Condition Code (VCC) register (1=pass, 0=fail). Also, vector compares have the option of
setting EXEC to the VCC value.</p>
<p>There is also a VCC summary bit (vccz) that is set to 1 when the VCC result is zero. This is useful for early-exit branch tests. VCC is also set for selected integer ALU operations (carry-out).</p>
<p>Vector compares have the option of writing the result to VCC (32-bit instruction encoding) or to any SGPR (64-bit instruction encoding). VCCZ is updated every time VCC is updated: vector compares and scalar writes to VCC.</p>
<p>The EXEC mask determines which threads execute an instruction. The VCC indicates which executing threads passed the conditional test, or which threads generated a carry-out from an integer add or subtract.</p>
<div class="informalexample"><p>V_CMP_* ⇒ VCC[n] = EXEC[n] &amp; (test passed for thread[n])</p>
</div><p>VCC is always fully written; there are no partial mask updates.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">VCC physically resides in the SGPR register file, so when an instruction sources VCC, that counts against the limit on the total number of SGPRs that can be sourced for a given instruction. VCC physically resides in the highest two user SGPRs.</p>
</div>
<p><strong>Shader Hazard with VCC</strong> The user/compiler must prevent a scalar-ALU
write to the SGPR holding VCC, immediately followed by a conditional
branch using VCCZ. The hardware cannot detect this, and inserts the one
required wait state (hardware does detect it when the SALU writes to
VCC, it only fails to do this when the SALU instruction references the
SGPRs that happen to hold VCC).</p>
</div>
<div class="section" id="trap-and-exception-registers">
<h3>Trap and Exception registers<a class="headerlink" href="#trap-and-exception-registers" title="Permalink to this headline">¶</a></h3>
<p>Each type of exception can be enabled or disabled independently by setting, or clearing, bits in the TRAPSTS register’s EXCP_EN field.This section describes the registers which control and report kernel exceptions.</p>
<p>All Trap temporary SGPRs (TTMP*) are privileged for writes - they can be written only when in the trap handler (status.priv = 1). When not privileged, writes to these are ignored. TMA and TBA are read-only; they can be accessed through S_GETREG_B32.</p>
<p>When a trap is taken (either user initiated, exception or host initiated), the shader hardware generates an S_TRAP instruction. This
loads trap information into a pair of SGPRS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">TTMP1</span><span class="p">,</span> <span class="n">TTMP0</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="s1">&#39;h0, pc_rewind[3:0], HT[0],trapID[7:0], PC[47:0]}.</span>
</pre></div>
</div>
<p>HT is set to one for host initiated traps, and zero for user traps
(s_trap) or exceptions. TRAP_ID is zero for exceptions, or the
user/host trapID for those traps. When the trap handler is entered, the
PC of the faulting instruction will be: (PC - PC_rewind*4).</p>
<p><strong>STATUS . TRAP_EN</strong> - This bit indicates to the shader whether or not
a trap handler is present. When one is not present, traps are not taken,
no matter whether they’re floating point, user-, or host-initiated
traps. When the trap handler is present, the wavefront uses an extra 16
SGPRs for trap processing. If trap_en == 0, all traps and exceptions
are ignored, and s_trap is converted by hardware to NOP.</p>
<p><strong>MODE . EXCP_EN[8:0]</strong> - Floating point exception enables. Defines
which exceptions and events cause a trap.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bit</th>
<th class="head">Exception</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Invalid</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>Input Denormal</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Divide by zero</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Overflow</td>
</tr>
<tr class="row-even"><td>4</td>
<td>Underflow</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>Inexact</td>
</tr>
<tr class="row-even"><td>6</td>
<td>Integer divide by zero</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>Address Watch - TC (L1) has witnessed a thread access to
an ‘address of interest’</td>
</tr>
</tbody>
</table>
<div class="section" id="trap-status-register">
<h4>Trap Status register<a class="headerlink" href="#trap-status-register" title="Permalink to this headline">¶</a></h4>
<p>The trap status register records previously seen traps or exceptions. It
can be read and written by the kernel.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="12%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bits</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EXCP</td>
<td>8:0</td>
<td><div class="first last line-block">
<div class="line">Status bits of which exceptions have occurred.
These bits are sticky and accumulate results
until the shader program clears them. These bits
are accumulated regardless of the setting of
EXCP_EN. These can be read or written without
shader privilege. Bit Exception 0 invalid</div>
<div class="line">1 Input Denormal</div>
<div class="line">2 Divide by zero</div>
<div class="line">3 overflow</div>
<div class="line">4 underflow</div>
<div class="line">5 inexact</div>
<div class="line">6 integer divide by zero</div>
<div class="line">7 address watch</div>
<div class="line">8 memory violation</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>SAVECTX</td>
<td>10</td>
<td>A bit set by the host command indicating that this
wave must jump to its trap handler and save its
context. This bit must be cleared by the trap
handler using S_SETREG. Note - a shader can set
this bit to 1 to cause a save-context trap, and
due to hardware latency the shader may execute up
to 2 additional instructions before taking the
trap.</td>
</tr>
<tr class="row-even"><td>ILLEGAL_INST</td>
<td>11</td>
<td>An illegal instruction has been detected.</td>
</tr>
<tr class="row-odd"><td>ADDR_WATCH1-3</td>
<td>14:12</td>
<td>Indicates that address watch 1, 2, or 3 has been
hit. Bit 12 is address watch 1; bit 13 is 2; bit
14 is 3.</td>
</tr>
<tr class="row-even"><td>EXCP_CYCLE</td>
<td>21:16</td>
<td><div class="first last line-block">
<div class="line">When a float exception occurs, this tells the
trap handler on which cycle the exception
occurred on. 0-3 for normal float operations,
0-7 for double float add, and 0-15 for double
float muladd or transcendentals. This register
records the cycle number of the first occurrence
of an enabled (unmasked) exception.
EXCP_CYCLE[1:0] Phase: threads 0-15 are in
phase 0, 48-63 in phase 3.</div>
<div class="line">EXCP_CYCLE[3:2] Multi-slot pass.</div>
<div class="line">EXCP_CYCLE[5:4] Hybrid pass: used for machines
running at lower rates.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>DP_RATE</td>
<td>31:29</td>
<td>Determines how the shader interprets the
TRAP_STS.cycle. Different Vector Shader
Processors (VSP) process instructions at different
rates.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Exception Field Bits</strong></div></blockquote>
</div>
</div>
<div class="section" id="memory-violations">
<h3>Memory Violations<a class="headerlink" href="#memory-violations" title="Permalink to this headline">¶</a></h3>
<p>A Memory Violation is reported from:</p>
<ul class="simple">
<li>LDS alignment error.</li>
<li>Memory read/write/atomic alignment error.</li>
<li>Flat access where the address is invalid (does not fall in any
aperture).</li>
<li>Write to a read-only surface.</li>
<li>GDS alignment or address range error.</li>
<li>GWS operation aborted (semaphore or barrier not executed).</li>
</ul>
<p>Memory violations are not reported for instruction or scalar-data accesses.</p>
<p>Memory Buffer to LDS does NOT return a memory violation if the LDS address is out of range, but masks off EXEC bits of threads that would go out of range.</p>
<p>When a memory access is in violation, the appropriate memory (LDS or TC) returns MEM_VIOL to the wave. This is stored in the wave’s
TRAPSTS.mem_viol bit. This bit is sticky, so once set to 1, it remains at 1 until the user clears it.</p>
<p>There is a corresponding exception enable bit (EXCP_EN.mem_viol). If this bit is set when the memory returns with a violation, the wave jumps to the trap handler.</p>
<p>Memory violations are not precise. The violation is reported when the LDS or TC processes the address; during this time, the wave may have processed many more instructions. When a mem_viol is reported, the Program Counter saved is that of the next instruction to execute; it has no relationship the faulting instruction.</p>
</div>
</div>
<div class="section" id="program-flow-control">
<h2>Program Flow Control<a class="headerlink" href="#program-flow-control" title="Permalink to this headline">¶</a></h2>
<p>All program flow control is programmed using scalar ALU instructions. This includes loops, branches, subroutine calls, and traps. The program uses SGPRs to store branch conditions and loop counters. Constants can be fetched from the scalar constant cache directly into SGPRs.</p>
<div class="section" id="program-control">
<h3>Program Control<a class="headerlink" href="#program-control" title="Permalink to this headline">¶</a></h3>
<p>The instructions in the table below control the priority and termination of a shader program, as well as provide support for trap handlers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instructions</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_ENDPGM</td>
<td>Terminates the wavefront. It can
appear anywhere in the kernel and
can appear multiple times.</td>
</tr>
<tr class="row-odd"><td>S_ENDPGM_SAVED</td>
<td>Terminates the wavefront due to
context save. It can appear anywhere
in the kernel and can appear
multiple times.</td>
</tr>
<tr class="row-even"><td>S_NOP</td>
<td>Does nothing; it can be repeated in
hardware up to eight times.</td>
</tr>
<tr class="row-odd"><td>S_TRAP</td>
<td>Jumps to the trap handler.</td>
</tr>
<tr class="row-even"><td>S_RFE</td>
<td>Returns from the trap handler</td>
</tr>
<tr class="row-odd"><td>S_SETPRIO</td>
<td>Modifies the priority of this
wavefront: 0=lowest, 3 = highest.</td>
</tr>
<tr class="row-even"><td>S_SLEEP</td>
<td>Causes the wavefront to sleep for 64
- 960 clock cycles.</td>
</tr>
<tr class="row-odd"><td>S_SENDMSG</td>
<td>Sends a message (typically an
interrupt) to the host CPU.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Control Instructions</strong></div></blockquote>
</div>
<div class="section" id="branching">
<h3>Branching<a class="headerlink" href="#branching" title="Permalink to this headline">¶</a></h3>
<p>Branching is done using one of the following scalar ALU instructions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instructions</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_BRANCH</td>
<td>Unconditional branch.</td>
</tr>
<tr class="row-odd"><td>S_CBRANCH_&lt;test&gt;</td>
<td>Conditional branch. Branch only if
&lt;test&gt; is true. Tests are VCCZ,
VCCNZ, EXECZ, EXECNZ, SCCZ, and
SCCNZ.</td>
</tr>
<tr class="row-even"><td>S_CBRANCH_CDBGSYS</td>
<td>Conditional branch, taken if the
COND_DBG_SYS status bit is set.</td>
</tr>
<tr class="row-odd"><td>S_CBRANCH_CDBGUSER</td>
<td>Conditional branch, taken if the
COND_DBG_USER status bit is set.</td>
</tr>
<tr class="row-even"><td>S_CBRANCH_CDBGSYS_AND_USER</td>
<td>Conditional branch, taken only if
both COND_DBG_SYS and
COND_DBG_USER are set.</td>
</tr>
<tr class="row-odd"><td>S_SETPC</td>
<td>Directly set the PC from an SGPR
pair.</td>
</tr>
<tr class="row-even"><td>S_SWAPPC</td>
<td>Swap the current PC with an address
in an SGPR pair.</td>
</tr>
<tr class="row-odd"><td>S_GETPC</td>
<td>Retrieve the current PC value (does
not cause a branch).</td>
</tr>
<tr class="row-even"><td>S_CBRANCH_FORK and
S_CBRANCH_JOIN</td>
<td>Conditional branch for complex
branching.</td>
</tr>
<tr class="row-odd"><td>S_SETVSKIP</td>
<td>Set a bit that causes all vector
instructions to be ignored. Useful
alternative to branching.</td>
</tr>
<tr class="row-even"><td>S_CALL_B64</td>
<td>Jump to a subroutine, and save
return address. SGPR_pair = PC+4;
PC = PC+4+SIMM16*4.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Branch Instructions</strong></div></blockquote>
<p>For conditional branches, the branch condition can be determined by either scalar or vector operations. A scalar compare operation sets the Scalar Condition Code (SCC), which then can be used as a conditional branch condition. Vector compare operations set the VCC mask, and VCCZ or VCCNZ then can be used to determine branching.</p>
</div>
<div class="section" id="workgroups">
<h3>Workgroups<a class="headerlink" href="#workgroups" title="Permalink to this headline">¶</a></h3>
<p>Work-groups are collections of wavefronts running on the same compute unit which can synchronize and share data. Up to 16 wavefronts (1024 work-items) can be combined into a work-group. When multiple wavefronts are in a workgroup, the S_BARRIER instruction can be used to force each wavefront to wait until all other wavefronts reach the same instruction; then, all wavefronts continue. Any wavefront can terminate early using S_ENDPGM, and the barrier is considered satisfied when the remaining
live waves reach their barrier instruction.</p>
</div>
<div class="section" id="data-dependency-resolution">
<h3>Data Dependency Resolution<a class="headerlink" href="#data-dependency-resolution" title="Permalink to this headline">¶</a></h3>
<p>Shader hardware resolves most data dependencies, but a few cases must be explicitly handled by the shader program. In these cases, the program must insert S_WAITCNT instructions to ensure that previous operations have completed before continuing.</p>
<p>The shader has three counters that track the progress of issued instructions. S_WAITCNT waits for the values of these counters to be
at, or below, specified values before continuing.</p>
<p>These allow the shader writer to schedule long-latency instructions,execute unrelated work, and specify when results of long-latency
operations are needed.</p>
<p>Instructions of a given type return in order, but instructions of different types can complete out-of-order. For example, both GDS and LDS instructions use LGKM_cnt, but they can return out-of-order.</p>
<ul>
<li><div class="first line-block">
<div class="line">VM_CNT: Vector memory count.</div>
<div class="line">Determines when memory reads have returned data to VGPRs, or memory
writes have completed.</div>
</div>
<ul class="simple">
<li>Incremented every time a vector-memory read or write (MIMG, MUBUF,
or MTBUF format) instruction is issued.</li>
<li>Decremented for reads when the data has been written back to the
VGPRs, and for writes when the data has been written to the L2
cache. Ordering: Memory reads and writes return in the order they
were issued, including mixing reads and writes.</li>
</ul>
</li>
<li><p class="first">LGKM_CNT: (LDS, GDS, (K)constant, (M)essage) Determines when one of
these low-latency instructions have completed.</p>
<ul>
<li><p class="first">Incremented by 1 for every LDS or GDS instruction issued, as well
as by Dword-count for scalar-memory reads. For example, s_memtime
counts the same as an s_load_dwordx2.</p>
</li>
<li><p class="first">Decremented by 1 for LDS/GDS reads or atomic-with-return when the
data has been returned to VGPRs.</p>
</li>
<li><p class="first">Incremented by 1 for each S_SENDMSG issued. Decremented by 1 when
message is sent out.</p>
</li>
<li><p class="first">Decremented by 1 for LDS/GDS writes when the data has been written
to LDS/GDS.</p>
</li>
<li><div class="first line-block">
<div class="line">Decremented by 1 for each Dword returned from the data-cache
(SMEM).</div>
<div class="line"><strong>Ordering:</strong></div>
</div>
<ul class="simple">
<li>Instructions of different types are returned out-of-order.</li>
<li>Instructions of the same type are returned in the order they
were issued, except scalar-memory-reads, which can return
out-of-order (in which case only S_WAITCNT 0 is the only
legitimate value).</li>
</ul>
</li>
</ul>
</li>
<li><div class="first line-block">
<div class="line">EXP_CNT: VGPR-export count.</div>
<div class="line">Determines when data has been read out of the VGPR and sent to GDS,
at which time it is safe to overwrite the contents of that VGPR.</div>
</div>
<ul class="simple">
<li>Incremented when an Export/GDS instruction is issued from the
wavefront buffer.</li>
<li>Decremented for exports/GDS when the last cycle of the export
instruction is granted and executed (VGPRs read out). Ordering<ul>
<li>Exports are kept in order only within each export type
(color/null, position, parameter cache).</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="manually-inserted-wait-states-nops">
<h3>Manually Inserted Wait States (NOPs)<a class="headerlink" href="#manually-inserted-wait-states-nops" title="Permalink to this headline">¶</a></h3>
<p>The hardware does not check for the following dependencies; they must be resolved by inserting NOPs or independent instructions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="28%" />
<col width="9%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">First Instruction</th>
<th class="head">Second Instruction</th>
<th class="head">Wait</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_SETREG &lt;*&gt;</td>
<td>S_GETREG &lt;same reg&gt;</td>
<td>2</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>S_SETREG &lt;*&gt;</td>
<td>S_SETREG &lt;same reg&gt;</td>
<td>2</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SET_VSKIP</td>
<td>S_GETREG MODE</td>
<td>2</td>
<td>Reads VSKIP from
MODE.</td>
</tr>
<tr class="row-odd"><td>S_SETREG MODE.vskip</td>
<td>any vector op</td>
<td>2</td>
<td>Requires two nops or
non-vector
instructions.</td>
</tr>
<tr class="row-even"><td>VALU that sets VCC or
EXEC</td>
<td>VALU that uses EXECZ
or VCCZ as a data
source</td>
<td>5</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>VALU writes SGPR/VCC
(readlane, cmp, add/sub,
div_scale)</td>
<td>V_{READ,WRITE}LANE
using that SGPR/VCC
as the lane select</td>
<td>4</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>VALU writes VCC
(including v_div_scale)</td>
<td>V_DIV_FMAS</td>
<td>4</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><blockquote class="first">
<div>FLAT_STORE_X3
FLAT_STORE_X4
FLAT_ATOMIC_{F}CMPSWA</div></blockquote>
<dl class="docutils">
<dt>P_X2</dt>
<dd>BUFFER_STORE_DWORD_X</dd>
</dl>
<p>3</p>
<blockquote>
<div>BUFFER_STORE_DWORD_X</div></blockquote>
<dl class="last docutils">
<dt>4</dt>
<dd>BUFFER_STORE_FORMAT_</dd>
<dt>XYZ</dt>
<dd>BUFFER_STORE_FORMAT_</dd>
<dt>XYZW</dt>
<dd>BUFFER_ATOMIC_{F}CMPS</dd>
<dt>WAP_X2</dt>
<dd>IMAGE_STORE_* &gt; 64
bits
IMAGE_ATOMIC_{F}CMPSW</dd>
<dt>AP</dt>
<dd>&gt; + 64bits</dd>
</dl>
</td>
<td>Write VGPRs holding
writedata from those
instructions.</td>
<td>1</td>
<td><p class="first">BUFFER_STORE_*
operations that use
an SGPR for “offset”
do not require any
wait states.</p>
<p class="last">IMAGE_STORE_* and
IMAGE_{F}CMPSWAP*
ops with more than
two DMASK bits set
require this one
wait state. Ops that
use a 256-bit T# do
not need a wait
state.</p>
</td>
</tr>
<tr class="row-even"><td>VALU writes SGPR</td>
<td>VMEM reads that SGPR</td>
<td>5</td>
<td>Hardware assumes
that there is no
dependency here. If
the VALU writes the
SGPR that is used by
a VMEM, the user
must add five wait
states.</td>
</tr>
<tr class="row-odd"><td>SALU writes M0</td>
<td>GDS, S_SENDMSG or
S_TTRACE_DATA</td>
<td>1</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>VALU writes VGPR</td>
<td>VALU DPP reads that
VGPR</td>
<td>2</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>VALU writes EXEC</td>
<td>VALU DPP op</td>
<td>5</td>
<td>ALU does not forward
EXEC to DPP.</td>
</tr>
<tr class="row-even"><td>Mixed use of VCC: alias
vs
SGPR#
v_readlane,
v_readfirstlane
v_cmp
v_add*<em>i/u
v_sub*_i/u
v_div_scale</em>*
(writes vcc)</td>
<td>VALU which reads VCC
as a constant (not
as a carry-in which
is 0 wait states).</td>
<td>1</td>
<td>VCC can be accessed
by name or by the
logical SGPR which
holds VCC. The data
dependency check
logic does not
understand that
these are the same
register and do not
prevent races.</td>
</tr>
<tr class="row-odd"><td>S_SETREG TRAPSTS</td>
<td>RFE, RFE_restore</td>
<td>1</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SALU writes M0</td>
<td>LDS “add-TID”
instruction,
buffer_store_LDS_
dword,
scratch or global
with LDS = 1,
VINTERP or
LDS_direct</td>
<td>1</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>SALU writes M0</td>
<td>S_MOVEREL</td>
<td>1</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Required Software-inserted Wait States</strong></div></blockquote>
</div>
<div class="section" id="arbitrary-divergent-control-flow">
<h3>Arbitrary Divergent Control Flow<a class="headerlink" href="#arbitrary-divergent-control-flow" title="Permalink to this headline">¶</a></h3>
<p>In the GCN architecture, conditional branches are handled in one of the
following ways.</p>
<ol class="arabic simple">
<li>S_CBRANCH This case is used for simple control flow, where the decision to take a branch is based on a previous compare operation.
This is the most common method for conditional branching.</li>
<li>S_CBRANCH_I/G_FORK and S_CBRANCH_JOIN This method, intended for complex, irreducible control flow graphs, is described in the    rest of this section. The performance of this method is lower than that for S_CBRANCH on simple flow control; use it only when        necessary.</li>
</ol>
<p>Conditional Branch (CBR) graphs are grouped into self-contained code blocks, denoted by FORK at the entrance point, and JOIN and the exit point. The shader compiler must add these instructions into the code.This method uses a six-deep stack and requires three SGPRs for each fork/join block. Fork/Join blocks can be hierarchically nested to any depth (subject to SGPR requirements); they also can coexist with other conditional flow control or computed jumps.</p>
<div class="figure" id="id16">
<img alt="Example of Complex Control Flow Graph" src="../_images/fig_3_1_fork_join.png" />
<p class="caption"><span class="caption-text">Example of Complex Control Flow Graph</span></p>
</div>
<p>The register requirements per wavefront are:</p>
<ul class="simple">
<li>CSP [2:0] - control stack pointer.</li>
<li>Six stack entries of 128-bits each, stored in SGPRS: { exec[63:0],
PC[47:2] }</li>
</ul>
<p>This method compares how many of the 64 threads go down the PASS path instead of the FAIL path; then, it selects the path with the fewer number of threads first. This means at most 50% of the threads are active, and this limits the necessary stack depth to Log264 = 6.</p>
<p>The following pseudo-code shows the details of CBRANCH Fork and Join operations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S_CBRANCH_G_FORK</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span>
    <span class="o">//</span> <span class="n">arg1</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">sgpr</span><span class="o">-</span><span class="n">pair</span> <span class="n">which</span> <span class="n">holds</span> <span class="mi">64</span><span class="n">bit</span> <span class="p">(</span><span class="mi">48</span><span class="n">bit</span><span class="p">)</span> <span class="n">target</span> <span class="n">address</span>

<span class="n">S_CBRANCH_I_FORK</span> <span class="n">arg0</span><span class="p">,</span> <span class="c1">#target_addr_offset[17:2]</span>
    <span class="o">//</span> <span class="n">target_addr_offset</span><span class="p">:</span> <span class="mi">16</span><span class="n">b</span> <span class="n">signed</span> <span class="n">immediate</span> <span class="n">offset</span>

<span class="o">//</span> <span class="n">PC</span><span class="p">:</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">code</span> <span class="ow">is</span> <span class="n">pointing</span> <span class="n">to</span> <span class="n">the</span> <span class="n">cbranch_</span><span class="o">*</span><span class="n">_fork</span> <span class="n">instruction</span>
<span class="n">mask_pass</span> <span class="o">=</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">exec</span>
<span class="n">mask_fail</span> <span class="o">=</span> <span class="o">~</span><span class="n">SGPR</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">exec</span>

<span class="k">if</span> <span class="p">(</span><span class="n">mask_pass</span> <span class="o">==</span> <span class="n">exec</span><span class="p">)</span>
    <span class="n">I_FORK</span> <span class="p">:</span> <span class="n">PC</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">target_addr_offset</span>
    <span class="n">G_FORK</span><span class="p">:</span> <span class="n">PC</span> <span class="o">=</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mask_fail</span> <span class="o">==</span> <span class="n">exec</span><span class="p">)</span>
    <span class="n">PC</span> <span class="o">+=</span> <span class="mi">4</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bitcount</span><span class="p">(</span><span class="n">mask_fail</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bitcount</span><span class="p">(</span><span class="n">mask_pass</span><span class="p">))</span>
    <span class="n">exec</span> <span class="o">=</span> <span class="n">mask_fail</span>
    <span class="n">I_FORK</span> <span class="p">:</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">CSP</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">pc</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">target_addr_offset</span><span class="p">),</span> <span class="n">mask_pass</span> <span class="p">}</span>
    <span class="n">G_FORK</span><span class="p">:</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">CSP</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">arg1</span><span class="p">],</span> <span class="n">mask_pass</span> <span class="p">}</span>
    <span class="n">CSP</span><span class="o">++</span>
    <span class="n">PC</span> <span class="o">+=</span> <span class="mi">4</span>
<span class="k">else</span>
    <span class="n">exec</span> <span class="o">=</span> <span class="n">mask_pass</span>
    <span class="n">SGPR</span><span class="p">[</span><span class="n">CSP</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">pc</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span> <span class="n">mask_fail</span> <span class="p">}</span>
    <span class="n">CSP</span><span class="o">++</span>
    <span class="n">I_FORK</span> <span class="p">:</span> <span class="n">PC</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">target_addr_offset</span>
    <span class="n">G_FORK</span><span class="p">:</span> <span class="n">PC</span> <span class="o">=</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>

<span class="n">S_CBRANCH_JOIN</span> <span class="n">arg0</span>
<span class="k">if</span> <span class="p">(</span><span class="n">CSP</span> <span class="o">==</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">arg0</span><span class="p">])</span> <span class="o">//</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="n">holds</span> <span class="n">the</span> <span class="n">CSP</span> <span class="n">value</span> <span class="n">when</span> <span class="n">the</span> <span class="n">FORK</span> <span class="n">started</span>
    <span class="n">PC</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">//</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">the</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">time</span> <span class="n">to</span> <span class="n">JOIN</span><span class="p">:</span> <span class="k">continue</span> <span class="k">with</span> <span class="n">pgm</span>
<span class="k">else</span>
    <span class="n">CSP</span> <span class="o">--</span> <span class="o">//</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">the</span> <span class="mi">1</span><span class="n">st</span> <span class="n">time</span> <span class="n">to</span> <span class="n">JOIN</span><span class="p">:</span> <span class="n">jump</span> <span class="n">to</span> <span class="n">other</span> <span class="n">FORK</span> <span class="n">path</span>
    <span class="p">{</span><span class="n">PC</span><span class="p">,</span> <span class="n">EXEC</span><span class="p">}</span> <span class="o">=</span> <span class="n">SGPR</span><span class="p">[</span><span class="n">CSP</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="o">//</span> <span class="n">read</span> <span class="mi">128</span><span class="o">-</span><span class="n">bits</span> <span class="kn">from</span> <span class="mi">4</span> <span class="n">consecutive</span> <span class="n">SGPRs</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="scalar-alu-operations">
<h2>Scalar ALU Operations<a class="headerlink" href="#scalar-alu-operations" title="Permalink to this headline">¶</a></h2>
<p>Scalar ALU (SALU) instructions operate on a single value per wavefront.These operations consist of 32-bit integer arithmetic and 32- or 64-bit bit-wise operations. The SALU also can perform operations directly on the Program Counter, allowing the program to create a call stack in SGPRs. Many operations also set the Scalar Condition Code bit (SCC) to indicate the result of a comparison, a carry-out, or whether the instruction result was zero.</p>
<div class="section" id="salu-instruction-formats">
<h3>SALU Instruction Formats<a class="headerlink" href="#salu-instruction-formats" title="Permalink to this headline">¶</a></h3>
<p>SALU instructions are encoded in one of five microcode formats, shown
below:</p>
<p><img alt="microcode sop1" src="../_images/microcode_sop1.png" /></p>
<p><img alt="microcode sop2" src="../_images/microcode_sop2.png" /></p>
<p><img alt="microcode sopk" src="../_images/microcode_sopk.png" /></p>
<p><img alt="microcode sopc" src="../_images/microcode_sopc.png" /></p>
<p><img alt="microcode sopp" src="../_images/microcode_sopp.png" /></p>
<p>Each of these instruction formats uses some of these fields:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OP</td>
<td>Opcode: instruction to be executed.</td>
</tr>
<tr class="row-odd"><td>SDST</td>
<td>Destination SGPR.</td>
</tr>
<tr class="row-even"><td>SSRC0</td>
<td>First source operand.</td>
</tr>
<tr class="row-odd"><td>SSRC1</td>
<td>Second source operand.</td>
</tr>
<tr class="row-even"><td>SIMM16</td>
<td>Signed immediate 16-bit integer constant.</td>
</tr>
</tbody>
</table>
<p>The lists of similar instructions sometimes use a condensed form using curly braces { } to express a list of possible names. For example, S_AND_{B32, B64} defines two legal instructions: S_AND_B32 and S_AND_B64.</p>
</div>
<div class="section" id="scalar-alu-operands">
<h3>Scalar ALU Operands<a class="headerlink" href="#scalar-alu-operands" title="Permalink to this headline">¶</a></h3>
<p>Valid operands of SALU instructions are:</p>
<ul class="simple">
<li>SGPRs, including trap temporary SGPRs.</li>
<li>Mode register.</li>
<li>Status register (read-only).</li>
<li>M0 register.</li>
<li>TrapSts register.</li>
<li>EXEC mask.</li>
<li>VCC mask.</li>
<li>SCC.</li>
<li>PC.</li>
<li>Inline constants: integers from -16 to 64, and a some floating point
values.</li>
<li>VCCZ, EXECZ, and SCC.</li>
<li>Hardware registers.</li>
<li>32-bit literal constant.</li>
</ul>
<p>In the table below, 0-127 can be used as scalar sources or destinations;
128-255 can only be used as sources.</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="20%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code scalar Dest (0-7 bits)</th>
<th class="head">Meaning</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0-101</td>
<td>SGPR 0 to 101</td>
<td>Scalar GPRs</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>FLAT_SCR</td>
<td>Holds the low_LO Dword of the flatscratch memory descriptor</td>
</tr>
<tr class="row-even"><td>103</td>
<td>FLAT_SCR</td>
<td>Holds the high_HI Dword of the flatscratch memory descriptor</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>XNACK_MA</td>
<td>Holds the lowSK_LO Dword of the XNACK mask</td>
</tr>
<tr class="row-even"><td>105</td>
<td>XNACK_MA</td>
<td>Holds the high SK_HI Dword of the XNACK mask</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>VCC_LO</td>
<td>Holds the low Dword of the vector condition code</td>
</tr>
<tr class="row-even"><td>107</td>
<td>VCC_HI</td>
<td>Holds the high Dword of the vector condition code</td>
</tr>
<tr class="row-odd"><td>108-123</td>
<td>TTMP0 to   Trap temps</td>
<td>TTMP15 (privileged)</td>
</tr>
<tr class="row-even"><td>124</td>
<td>M0</td>
<td>Holds the low Dword of the flatscratch memory descriptor</td>
</tr>
<tr class="row-odd"><td>125</td>
<td>reserved</td>
<td>reserved</td>
</tr>
<tr class="row-even"><td>126</td>
<td>EXEC_LO</td>
<td>Execute mask, low Dword</td>
</tr>
<tr class="row-odd"><td>127</td>
<td>EXEC_HI</td>
<td>Execute mask, high Dword</td>
</tr>
<tr class="row-even"><td>128</td>
<td>0</td>
<td>zero</td>
</tr>
<tr class="row-odd"><td>129-192</td>
<td>int 1 to 64</td>
<td>Positive integer values.</td>
</tr>
<tr class="row-even"><td>193-208</td>
<td>int 1 to 16</td>
<td>Negative integer values.</td>
</tr>
<tr class="row-odd"><td>209-234</td>
<td>reserved</td>
<td>Unused.</td>
</tr>
<tr class="row-even"><td>235</td>
<td>SHARED_BASE</td>
<td>Memory Aperture definition.</td>
</tr>
<tr class="row-odd"><td>236</td>
<td>SHARED_LIMIT</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>237</td>
<td>PRIVATE_BASE</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>238</td>
<td>PRIVATE_LIMIT</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>239</td>
<td>POPS_EXITING_WAV</td>
<td>Primitive Ordered Pixel Shading E_IDwave ID.</td>
</tr>
<tr class="row-odd"><td>240</td>
<td>0.5</td>
<td>single or double floats</td>
</tr>
<tr class="row-even"><td>241</td>
<td>0.5</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>242</td>
<td>1.0</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>243</td>
<td>1.0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>244</td>
<td>2.0</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>245</td>
<td>2.0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>246</td>
<td>4.0</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>247</td>
<td>4.0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>248</td>
<td>1.0 / (2 * PI)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>249-250</td>
<td>reserved</td>
<td>unused</td>
</tr>
<tr class="row-odd"><td>251</td>
<td>VCCZ</td>
<td>{ zeros, VCCZ }</td>
</tr>
<tr class="row-even"><td>252</td>
<td>EXECZ</td>
<td>{ zeros, EXECZ}</td>
</tr>
<tr class="row-odd"><td>253</td>
<td>SCC</td>
<td>{ zeros, SCC }</td>
</tr>
<tr class="row-even"><td>254</td>
<td>reserved</td>
<td>unused</td>
</tr>
<tr class="row-odd"><td>255</td>
<td>Literal</td>
<td>constant 32bit constant from instruction stream.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Scalar Operands</strong></div></blockquote>
<p>The SALU cannot use VGPRs or LDS. SALU instructions can use a 32-bit literal constant. This constant is part of the instruction stream and is available to all SALU microcode formats except SOPP and SOPK. Literal constants are used by setting the source instruction field to “literal” (255), and then the following instruction dword is used as the source value.</p>
<p>If any source SGPR is out-of-range, the value of SGPR0 is used instead.</p>
<p>If the destination SGPR is out-of-range, no SGPR is written with the result. However, SCC and possibly EXEC (if saveexec) will still be written.</p>
<p>If an instruction uses 64-bit data in SGPRs, the SGPR pair must be aligned to an even boundary. For example, it is legal to use SGPRs 2 and 3 or 8 and 9 (but not 11 and 12) to represent 64-bit data.</p>
</div>
<div class="section" id="scalar-condition-code-scc">
<h3>Scalar Condition Code (SCC)<a class="headerlink" href="#scalar-condition-code-scc" title="Permalink to this headline">¶</a></h3>
<p>The scalar condition code (SCC) is written as a result of executing most SALU instructions.</p>
<p>The SCC is set by many instructions:</p>
<ul class="simple">
<li>Compare operations: 1 = true.</li>
<li>Arithmetic operations: 1 = carry out.<ul>
<li>SCC = overflow for signed add and subtract operations. For add, overflow = both operands are of the same sign, and the MSB (sign
bit) of the result is different than the sign of the operands. For subtract (AB), overflow = A and B have opposite signs and the
resulting sign is not the same as the sign of A.</li>
</ul>
</li>
<li>Bit/logical operations: 1 = result was not zero.</li>
</ul>
</div>
<div class="section" id="integer-arithmetic-instructions">
<h3>Integer Arithmetic Instructions<a class="headerlink" href="#integer-arithmetic-instructions" title="Permalink to this headline">¶</a></h3>
<p>This section describes the arithmetic operations supplied by the SALU.
The table below shows the scalar integer arithmetic instructions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="15%" />
<col width="15%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Encoding</th>
<th class="head">Sets SCC?</th>
<th class="head">Operation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_ADD_I32</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 + S1, SCC = overflow.</td>
</tr>
<tr class="row-odd"><td>S_ADD_U32</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 + S1, SCC = carry out.</td>
</tr>
<tr class="row-even"><td>S_ADDC_U32</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 + S1 + SCC = overflow.</td>
</tr>
<tr class="row-odd"><td>S_SUB_I32</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 - S1, SCC = overflow.</td>
</tr>
<tr class="row-even"><td>S_SUB_U32</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 - S1, SCC = carry out.</td>
</tr>
<tr class="row-odd"><td>S_SUBB_U32</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 - S1 - SCC = carry out.</td>
</tr>
<tr class="row-even"><td>S_ABSDIFF_I32</td>
<td>SOP2</td>
<td>y</td>
<td>D = abs (s1 - s2), SCC = result
not zero.</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">S_MIN_I32</div>
<div class="line">S_MIN_U32</div>
</div>
</td>
<td>SOP2</td>
<td>y</td>
<td>D = (S0 &lt; S1) ? S0 : S1. SCC = 1
if S0 was min.</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">S_MAX_I32</div>
<div class="line">S_MAX_U32</div>
</div>
</td>
<td>SOP2</td>
<td>y</td>
<td>D = (S0 &gt; S1) ? S0 : S1. SCC = 1
if S0 was max.</td>
</tr>
<tr class="row-odd"><td>S_MUL_I32</td>
<td>SOP2</td>
<td>n</td>
<td>D = S0 * S1. Low 32 bits of
result.</td>
</tr>
<tr class="row-even"><td>S_ADDK_I32</td>
<td>SOPK</td>
<td>y</td>
<td>D = D + simm16, SCC = overflow.
Sign extended version of simm16.</td>
</tr>
<tr class="row-odd"><td>S_MULK_I32</td>
<td>SOPK</td>
<td>n</td>
<td>D = D * simm16. Return low
32bits. Sign extended version of
simm16.</td>
</tr>
<tr class="row-even"><td>S_ABS_I32</td>
<td>SOP1</td>
<td>y</td>
<td>D.i = abs (S0.i). SCC=result not
zero.</td>
</tr>
<tr class="row-odd"><td>S_SEXT_I32_I8</td>
<td>SOP1</td>
<td>n</td>
<td>D = { 24{S0[7]}, S0[7:0] }.</td>
</tr>
<tr class="row-even"><td>S_SEXT_I32_I16</td>
<td>SOP1</td>
<td>n</td>
<td>D = { 16{S0[15]}, S0[15:0] }.</td>
</tr>
</tbody>
</table>
<p>Table: Integer Arithmetic Instructions</p>
</div>
<div class="section" id="conditional-instructions">
<h3>Conditional Instructions<a class="headerlink" href="#conditional-instructions" title="Permalink to this headline">¶</a></h3>
<p>Conditional instructions use the SCC flag to determine whether to
perform the operation, or (for CSELECT) which source operand to use.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="25%" />
<col width="25%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Encoding</th>
<th class="head">Sets SCC?</th>
<th class="head">Operation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_CSELECT_{B32,
B64}</td>
<td>SOP2</td>
<td>n</td>
<td>D = SCC ? S0 : S1.</td>
</tr>
<tr class="row-odd"><td>S_CMOVK_I
32</td>
<td>SOPK</td>
<td>n</td>
<td>if (SCC) D =
signext(simm16).</td>
</tr>
<tr class="row-even"><td>S_CMOV_{B
32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>if (SCC) D = S0, else
NOP.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Conditional Instructions</strong></div></blockquote>
</div>
<div class="section" id="comparison-instructions">
<h3>Comparison Instructions<a class="headerlink" href="#comparison-instructions" title="Permalink to this headline">¶</a></h3>
<p>These instructions compare two values and set the SCC to 1 if the
comparison yielded a TRUE result.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="13%" />
<col width="13%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Encoding</th>
<th class="head">Sets
SCC?</th>
<th class="head">Operation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_CMP_EQ_U64,
S_CMP_NE_U64</td>
<td>SOPC</td>
<td>y</td>
<td>Compare two 64-bit source values.
SCC = S0 &lt;cond&gt; S1.</td>
</tr>
<tr class="row-odd"><td>S_CMP_{EQ,NE,GT,GE
,LE,LT}_{I32,U32}</td>
<td>SOPC</td>
<td>y</td>
<td>Compare two source values. SCC =
S0 &lt;cond&gt; S1.</td>
</tr>
<tr class="row-even"><td>S_CMPK_{EQ,NE,GT,G
E,LE,LT}_{I32,U32}</td>
<td>SOPK</td>
<td>y</td>
<td>Compare Dest SGPR to a constant.
SCC = DST &lt;cond&gt; simm16. simm16 is
zero-extended (U32) or
sign-extended (I32).</td>
</tr>
<tr class="row-odd"><td>S_BITCMP0_{B32,B64
}</td>
<td>SOPC</td>
<td>y</td>
<td>Test for “is a bit zero”. SCC =
!S0[S1].</td>
</tr>
<tr class="row-even"><td>S_BITCMP1_{B32,B64
}</td>
<td>SOPC</td>
<td>y</td>
<td>Test for “is a bit one”. SCC =
S0[S1].</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Conditional Instructions</strong></div></blockquote>
</div>
<div class="section" id="bit-wise-instructions">
<h3>Bit-Wise Instructions<a class="headerlink" href="#bit-wise-instructions" title="Permalink to this headline">¶</a></h3>
<p>Bit-wise instructions operate on 32- or 64-bit data without interpreting
it has having a type. For bit-wise operations if noted in the table
below, SCC is set if the result is nonzero.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="12%" />
<col width="10%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Encodin
g</th>
<th class="head">Sets
SCC?</th>
<th class="head">Operation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_MOV_{B32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>D = S0</td>
</tr>
<tr class="row-odd"><td>S_MOVK_I32</td>
<td>SOPK</td>
<td>n</td>
<td>D = signext(simm16)</td>
</tr>
<tr class="row-even"><td>{S_AND,S_OR,S_XOR}_{B
32,B64}</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 &amp; S1, S0 OR S1, S0 XOR S1</td>
</tr>
<tr class="row-odd"><td>{S_ANDN2,S_ORN2}_{B32,
B64}</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 &amp; ~S1, S0 OR ~S1, S0 XOR
~S1,</td>
</tr>
<tr class="row-even"><td>{S_NAND,S_NOR,S_XNOR}_{B32,B64}</td>
<td>SOP2</td>
<td>y</td>
<td>D = ~(S0 &amp; S1), ~(S0 OR S1),
~(S0 XOR S1)</td>
</tr>
<tr class="row-odd"><td>S_LSHL_{B32,B64}</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 &lt;&lt; S1[4:0], [5:0] for
B64.</td>
</tr>
<tr class="row-even"><td>S_LSHR_{B32,B64}</td>
<td>SOP2</td>
<td>y</td>
<td>D = S0 &gt;&gt; S1[4:0], [5:0] for
B64.</td>
</tr>
<tr class="row-odd"><td>S_ASHR_{I32,I64}</td>
<td>SOP2</td>
<td>y</td>
<td>D = sext(S0 &gt;&gt; S1[4:0]) ([5:0]
for I64).</td>
</tr>
<tr class="row-even"><td>S_BFM_{B32,B64}</td>
<td>SOP2</td>
<td>n</td>
<td>Bit field mask. D = ((1 &lt;&lt;
S0[4:0]) - 1) &lt;&lt; S1[4:0].</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">S_BFE_U32,
S_BFE_U64</div>
<div class="line">S_BFE_I32,
S_BFE_I64</div>
<div class="line">(signed/unsigned)</div>
</div>
</td>
<td>SOP2</td>
<td>n</td>
<td><div class="first last line-block">
<div class="line">Bit Field Extract, then
sign-extend result for I32/64
instructions.</div>
<div class="line">S0 = data,</div>
<div class="line">S1[5:0] = offset, S1[22:16]=
width.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>S_NOT_{B32,B64}</td>
<td>SOP1</td>
<td>y</td>
<td>D = ~S0.</td>
</tr>
<tr class="row-odd"><td>S_WQM_{B32,B64}</td>
<td>SOP1</td>
<td>y</td>
<td>D = wholeQuadMode(S0). If any
bit in a group of four is set to
1, set the resulting group of
four bits all to 1.</td>
</tr>
<tr class="row-even"><td>S_QUADMASK_{B32,B64}</td>
<td>SOP1</td>
<td>y</td>
<td>D[0] = OR(S0[3:0]),
D[1]=OR(S0[7:4]), etc.</td>
</tr>
<tr class="row-odd"><td>S_BREV_{B32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>D = S0[0:31] are reverse bits.</td>
</tr>
<tr class="row-even"><td>S_BCNT0_I32_{B32,B64}</td>
<td>SOP1</td>
<td>y</td>
<td>D = CountZeroBits(S0).</td>
</tr>
<tr class="row-odd"><td>S_BCNT1_I32_{B32,B64}</td>
<td>SOP1</td>
<td>y</td>
<td>D = CountOneBits(S0).</td>
</tr>
<tr class="row-even"><td>S_FF0_I32_{B32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>D = Bit position of first zero
in S0 starting from LSB. -1 if
not found.</td>
</tr>
<tr class="row-odd"><td>S_FF1_I32_{B32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>D = Bit position of first one in
S0 starting from LSB. -1 if not
found.</td>
</tr>
<tr class="row-even"><td>S_FLBIT_I32_{B32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>Find last bit. D = the number of
zeros before the first one
starting from the MSB. Returns
-1 if none.</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">S_FLBIT_I32</div>
<div class="line">S_FLBIT_I32_I64</div>
</div>
</td>
<td>SOP1</td>
<td>n</td>
<td><div class="first last line-block">
<div class="line">Count how many bits in a row
(from MSB to LSB) are the same
as the sign bit. Return -1 if
the input is zero or all 1’s
(-1). 32-bit pseudo-code:</div>
<div class="line">if (S0 == 0 || S0 == -1) D =
-1</div>
<div class="line">else</div>
<div class="line">D = 0</div>
<div class="line">for (I = 31 .. 0)</div>
<div class="line">if (S0[I] == S0[31])</div>
<div class="line">D++</div>
<div class="line">else break</div>
<div class="line">This opcode behaves the same
as V_FFBH_I32.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>S_BITSET0_{B32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>D[S0[4:0], [5:0] for B64] = 0</td>
</tr>
<tr class="row-odd"><td>S_BITSET1_{B32,B64}</td>
<td>SOP1</td>
<td>n</td>
<td>D[S0[4:0], [5:0] for B64] = 1</td>
</tr>
<tr class="row-even"><td>S_{and,or,xor,andn2,orn2
,nand,
nor,xnor}_SAVEEXEC_B64</td>
<td>SOP1</td>
<td>y</td>
<td><div class="first last line-block">
<div class="line">Save the EXEC mask, then apply
a bit-wise operation to it.</div>
<div class="line">D = EXEC</div>
<div class="line">EXEC = S0 &lt;op&gt; EXEC</div>
<div class="line">SCC = (exec != 0)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>S_{ANDN{1,2}_WREXEC_B6
4</td>
<td>SOP1</td>
<td>y</td>
<td><div class="first last line-block">
<div class="line">N1: EXEC, D = ~S0 &amp; EXEC</div>
<div class="line">N2: EXEC, D = S0 &amp; ~EXEC</div>
<div class="line">Both D and EXEC get the same
result. SCC = (result != 0).</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">S_MOVRELS_{B32,B64}</div>
<div class="line">S_MOVRELD_{B32,B64}</div>
</div>
</td>
<td>SOP1</td>
<td>n</td>
<td><div class="first last line-block">
<div class="line">Move a value into an SGPR
relative to the value in M0.</div>
<div class="line">MOVERELS: D = SGPR[S0+M0]</div>
<div class="line">MOVERELD: SGPR[D+M0] = S0</div>
<div class="line">Index must be even for 64. M0
is an unsigned index.</div>
</div>
</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Bit-Wise Instructions</strong></div></blockquote>
</div>
<div class="section" id="special-instructions">
<h3>Special Instructions<a class="headerlink" href="#special-instructions" title="Permalink to this headline">¶</a></h3>
<p>These instructions access hardware internal registers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="12%" />
<col width="10%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Encodin
g</th>
<th class="head">Sets
SCC?</th>
<th class="head">Operation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_GETREG_B32</td>
<td>SOPK*</td>
<td>n</td>
<td>Read a hardware register into the LSBs
of D.</td>
</tr>
<tr class="row-odd"><td>S_SETREG_B32</td>
<td>SOPK*</td>
<td>n</td>
<td>Write the LSBs of D into a hardware
register. (Note that D is a source
SGPR.) Must add an S_NOP between two
consecutive S_SETREG to the same
register.</td>
</tr>
<tr class="row-even"><td>S_SETREG_IMM32_B32</td>
<td>SOPK*</td>
<td>n</td>
<td>S_SETREG where 32-bit data comes from a
literal constant (so this is a 64-bit
instruction format).</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Hardware Internal Registers</strong></div></blockquote>
<p>The hardware register is specified in the DEST field of the instruction,using the values in the table above. Some bits of the DEST specify which register to read/write, but additional bits specify which bits in the
special register to read/write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SIMM16</span> <span class="o">=</span> <span class="p">{</span><span class="n">size</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">hwRegId</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">0</span><span class="p">]};</span> <span class="n">offset</span> <span class="ow">is</span> <span class="mf">0.</span><span class="o">.</span><span class="mi">31</span><span class="p">,</span> <span class="n">size</span> <span class="ow">is</span> <span class="mf">1.</span><span class="o">.</span><span class="mf">32.</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="30%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Register</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>reserved</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>MODE</td>
<td>R/W.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>STATUS</td>
<td>Read only.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>TRAPSTS</td>
<td>R/W.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>HW_ID</td>
<td>Read only. Debug only.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>GPR_ALLOC</td>
<td>Read only. {sgpr_size,
sgpr_base, vgpr_size,
vgpr_base }.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>LDS_ALLOC</td>
<td>Read only. {lds_size,
lds_base}.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>IB_STS</td>
<td>Read only. {valu_cnt,
lgkm_cnt, exp_cnt,
vm_cnt}.</td>
</tr>
<tr class="row-even"><td>8 - 15</td>
<td>&#160;</td>
<td>reserved.</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>TBA_LO</td>
<td>Trap base address register
[31:0].</td>
</tr>
<tr class="row-even"><td>17</td>
<td>TBA_HI</td>
<td>Trap base address register
[47:32].</td>
</tr>
<tr class="row-odd"><td>18</td>
<td>TMA_LO</td>
<td>Trap memory address register
[31:0].</td>
</tr>
<tr class="row-even"><td>19</td>
<td>TMA_HI</td>
<td>Trap memory address register
[47:32].</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : Hardware Register Values</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="30%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Register</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VM_CNT</td>
<td><div class="first last line-block">
<div class="line">23:22,</div>
<div class="line">3:0</div>
</div>
</td>
<td>Number of VMEM instructions
issued but not yet returned.</td>
</tr>
<tr class="row-odd"><td>EXP_CNT</td>
<td>6:4</td>
<td>Number of Exports issued but
have not yet read their data
from VGPRs.</td>
</tr>
<tr class="row-even"><td>LGKM_CNT</td>
<td>11:8</td>
<td>LDS, GDS, Constant-memory
and Message instructions
issued-but-not-completed
count.</td>
</tr>
<tr class="row-odd"><td>VALU_CNT</td>
<td>14:12</td>
<td>Number of VALU instructions
outstanding for this
wavefront.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table : IB_STS</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="30%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Register</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VGPR_BASE</td>
<td>5:0</td>
<td>Physical address of first
VGPR assigned to this
wavefront, as [7:2]</td>
</tr>
<tr class="row-odd"><td>VGPR_SIZE</td>
<td>13:8</td>
<td>Number of VGPRs assigned to
this wavefront, as [7:2].
0=4 VGPRs, 1=8 VGPRs, etc.</td>
</tr>
<tr class="row-even"><td>SGPR_BASE</td>
<td>21:16</td>
<td>Physical address of first
SGPR assigned to this
wavefront, as [7:3].</td>
</tr>
<tr class="row-odd"><td>SGPR_SIZE</td>
<td>27:24</td>
<td>Number of SGPRs assigned to
this wave, as [7:3]. 0=8
SGPRs, 1=16 SGPRs, etc.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><strong>Table  : GPR_ALLOC</strong></div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="30%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Register</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>LDS_BASE</td>
<td>7:0</td>
<td>Physical address of first
LDS location assigned to
this wavefront, in units of
64 Dwords.</td>
</tr>
<tr class="row-odd"><td>LDS_SIZE</td>
<td>20:12</td>
<td>Amount of LDS space assigned
to this wavefront, in units
of 64 Dwords.</td>
</tr>
</tbody>
</table>
<p><strong>Table : LDS_ALLOC</strong></p>
</div>
</div>
<div class="section" id="vector-alu-operations">
<h2>Vector ALU Operations<a class="headerlink" href="#vector-alu-operations" title="Permalink to this headline">¶</a></h2>
<p>Vector ALU instructions (VALU) perform an arithmetic or logical operation on data for each of 64 threads and write results back to
VGPRs, SGPRs or the EXEC mask.</p>
<p>Parameter interpolation is a mixed VALU and LDS instruction, and is described in the Data Share chapter.</p>
<div class="section" id="microcode-encodings">
<h3>Microcode Encodings<a class="headerlink" href="#microcode-encodings" title="Permalink to this headline">¶</a></h3>
<p>Most VALU instructions are available in two encodings: VOP3 which uses 64-bits of instruction and has the full range of capabilities, and one of three 32-bit encodings that offer a restricted set of capabilities. A few instructions are only available in the VOP3 encoding. The only instructions that cannot use the VOP3 format are the parameter interpolation instructions.</p>
<p>When an instruction is available in two microcode formats, it is up to the user to decide which to use. It is recommended to use the 32-bit encoding whenever possible.</p>
<p>The microcode encodings are shown below.</p>
<p>VOP2 is for instructions with two inputs and a single vector destination. Instructions that have a carry-out implicitly write the
carry-out to the VCC register.</p>
<p><img alt="microcode vop2" src="../_images/microcode_vop2.png" /></p>
<p>VOP1 is for instructions with no inputs or a single input and one destination.</p>
<p><img alt="microcode vop1" src="../_images/microcode_vop1.png" /></p>
<p>VOPC is for comparison instructions.</p>
<p><img alt="microcode vopc" src="../_images/microcode_vopc.png" /></p>
<p>VINTRP is for parameter interpolation instructions.</p>
<p><img alt="microcode vintrp" src="../_images/microcode_vintrp.png" /></p>
<p>VOP3 is for instructions with up to three inputs, input modifiers
(negate and absolute value), and output modifiers. There are two forms
of VOP3: one which uses a scalar destination field (used only for
div_scale, integer add and subtract); this is designated VOP3b. All
other instructions use the common form, designated VOP3a.</p>
<p><img alt="microcode vop3a" src="../_images/microcode_vop3a.png" /></p>
<p><img alt="microcode vop3b" src="../_images/microcode_vop3b.png" /></p>
<p>Any of the 32-bit microcode formats may use a 32-bit literal constant,
but not VOP3.</p>
<p>VOP3P is for instructions that use “packed math”: They perform the operation on a pair of input values that are packed into the high and low 16-bits of each operand; the two 16-bit results are written to a single VGPR as two packed values.</p>
<p><img alt="microcode vop3p" src="../_images/microcode_vop3p.png" /></p>
</div>
<div class="section" id="operands">
<h3>Operands<a class="headerlink" href="#operands" title="Permalink to this headline">¶</a></h3>
<p>All VALU instructions take at least one input operand (except V_NOP and V_CLREXCP). The data-size of the operands is explicitly defined in the name of the instruction. For example, V_MAD_F32 operates on 32-bit floating point data.</p>
<div class="section" id="instruction-inputs">
<h4>Instruction Inputs<a class="headerlink" href="#instruction-inputs" title="Permalink to this headline">¶</a></h4>
<p>VALU instructions can use any of the following sources for input,
subject to restrictions listed below:</p>
<ul class="simple">
<li>VGPRs.</li>
<li>SGPRs.</li>
<li>Inline constants - constant selected by a specific VSRC value.</li>
<li>Literal constant - 32-bit value in the instruction stream. When a
literal constant is used with a 64bit instruction, the literal is
expanded to 64 bits by: padding the LSBs with zeros for floats,
padding the MSBs with zeros for unsigned ints, and by sign-extending
signed ints.</li>
<li>LDS direct data read.</li>
<li>M0.</li>
<li>EXEC mask.</li>
</ul>
<p><strong>Limitations</strong></p>
<ul>
<li><p class="first">At most one SGPR can be read per instruction, but the value can be
used for more than one operand.</p>
</li>
<li><p class="first">At most one literal constant can be used, and only when an SGPR or M0
is not used as a source.</p>
</li>
<li><p class="first">Only SRC0 can use LDS_DIRECT (see Chapter 10, “Data Share
Operations”).</p>
<dl class="docutils">
<dt>Special Cases for Constants</dt>
<dd><div class="first last line-block">
<div class="line">VALU “ADDC”, “SUBB” and CNDMASK all implicitly use an</div>
<div class="line">SGPR value (VCC), so these instructions cannot use an
additional SGPR or literal constant.</div>
</div>
</dd>
</dl>
</li>
</ul>
<p>Instructions using the VOP3 form and also using floating-point inputs
have the option of applying absolute value (ABS field) or negate (NEG
field) to any of the input operands.</p>
<div class="section" id="literal-expansion-to-64-bits">
<h5>Literal Expansion to 64 bits<a class="headerlink" href="#literal-expansion-to-64-bits" title="Permalink to this headline">¶</a></h5>
<p>Literal constants are 32-bits, but they can be used as sources which
normally require 64-bit data:</p>
<ul class="simple">
<li>64 bit float: the lower 32-bit are padded with zero.</li>
<li>64-bit unsigned integer: zero extended to 64 bits</li>
<li>64-bit signed integer: sign extended to 64 bits</li>
</ul>
</div>
</div>
<div class="section" id="instruction-outputs">
<h4>Instruction Outputs<a class="headerlink" href="#instruction-outputs" title="Permalink to this headline">¶</a></h4>
<p>VALU instructions typically write their results to VGPRs specified in
the VDST field of the microcode word. A thread only writes a result if
the associated bit in the EXEC mask is set to 1.</p>
<p>All V_CMPX instructions write the result of their comparison (one bit
per thread) to both an SGPR (or VCC) and the EXEC mask.</p>
<p>Instructions producing a carry-out (integer add and subtract) write
their result to VCC when used in the VOP2 form, and to an arbitrary
SGPR-pair when used in the VOP3 form.</p>
<p>When the VOP3 form is used, instructions with a floating-point result
can apply an output modifier (OMOD field) that multiplies the result by:
0.5, 1.0, 2.0 or 4.0. Optionally, the result can be clamped (CLAMP
field) to the range [0.0, +1.0].</p>
<p>In the table below, all codes can be used when the vector source is nine
bits; codes 0 to 255 can be the scalar source if it is eight bits; codes
0 to 127 can be the scalar source if it is seven bits; and codes 256 to
511 can be the vector source or destination.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="26%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bit Position</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0-101</td>
<td>SGPR</td>
<td>0 .. 101</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>FLATSCR_LO</td>
<td>Flat Scratch[31:0].</td>
</tr>
<tr class="row-even"><td>103</td>
<td>FLATSCR_HI</td>
<td>Flat Scratch[63:32].</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>XNACK_MASK_LO</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>105</td>
<td>XNACK_MASK_HI</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>VCC_LO</td>
<td>vcc[31:0].</td>
</tr>
<tr class="row-even"><td>107</td>
<td>VCC_HI</td>
<td>vcc[63:32].</td>
</tr>
<tr class="row-odd"><td>108-123</td>
<td>TTMP0 to TTMP 15</td>
<td>Trap handler temps (privileged).</td>
</tr>
<tr class="row-even"><td>124</td>
<td>M0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>125</td>
<td>reserved</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>126</td>
<td>EXEC_LO</td>
<td>exec[31:0].</td>
</tr>
<tr class="row-odd"><td>127</td>
<td>EXEC_HI</td>
<td>exec[63:32].</td>
</tr>
<tr class="row-even"><td>128</td>
<td>0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>129-192</td>
<td>int 1.. 64</td>
<td>Integer inline constants.</td>
</tr>
<tr class="row-even"><td>193-208</td>
<td>int -1 .. -16</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>209-234</td>
<td>reserved</td>
<td>Unused.</td>
</tr>
<tr class="row-even"><td>235</td>
<td>SHARED_BASE</td>
<td>Memory Aperture definition.</td>
</tr>
<tr class="row-odd"><td>236</td>
<td>SHARED_LIMIT</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>237</td>
<td>PRIVATE_BASE</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>238</td>
<td>PRIVATE_LIMIT</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>239</td>
<td>POPS_EXITING_WAV
E_ID</td>
<td>Primitive Ordered Pixel Shading wave ID.</td>
</tr>
<tr class="row-odd"><td>240</td>
<td>0.5</td>
<td><div class="first last line-block">
<div class="line">Single, double, or half-precision inline
floats.</div>
<div class="line">1/(2*PI) is 0.15915494.</div>
<div class="line">The exact value used is:</div>
<div class="line">half: 0x3118</div>
<div class="line">single: 0x3e22f983</div>
<div class="line">double: 0x3fc45f306dc9c882</div>
</div>
</td>
</tr>
<tr class="row-even"><td>241</td>
<td>-0.5</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>242</td>
<td>1.0</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>243</td>
<td>-1.0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>244</td>
<td>2.0</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>245</td>
<td>-2.0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>246</td>
<td>4.0</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>247</td>
<td>-4.0</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>248</td>
<td>1/(2*PI)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>249</td>
<td>SDWA</td>
<td>250</td>
</tr>
<tr class="row-odd"><td>DPP</td>
<td>251</td>
<td>VCCZ</td>
</tr>
<tr class="row-even"><td>{ zeros,
VCCZ }</td>
<td>252</td>
<td>EXECZ</td>
</tr>
<tr class="row-odd"><td>{ zeros,
EXECZ }</td>
<td>253</td>
<td>SCC</td>
</tr>
<tr class="row-even"><td>{ zeros,
SCC }</td>
<td>254</td>
<td>LDS direct</td>
</tr>
<tr class="row-odd"><td>Use LDS
direct
read to
supply
32-bit
value
Vector-al
u
instructi
ons
only.</td>
<td>255</td>
<td>Literal</td>
</tr>
<tr class="row-even"><td>constant
32-bit
constant
from
instructi
on
stream.</td>
<td>256-511</td>
<td>VGPR</td>
</tr>
</tbody>
</table>
<p>Table: Instruction Operands</p>
</div>
<div class="section" id="out-of-range-gprs">
<h4>Out-of-Range GPRs<a class="headerlink" href="#out-of-range-gprs" title="Permalink to this headline">¶</a></h4>
<p>When a source VGPR is out-of-range, the instruction uses as input the
value from VGPR0.</p>
<p>When the destination GPR is out-of-range, the instruction executes but
does not write the results.</p>
</div>
</div>
<div class="section" id="instructions">
<h3>Instructions<a class="headerlink" href="#instructions" title="Permalink to this headline">¶</a></h3>
<p>The table below lists the complete VALU instruction set by microcode
encoding.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="21%" />
<col width="21%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">VOP3</th>
<th class="head">VOP3 - 1-2
operand
opcodes</th>
<th class="head">VOP2</th>
<th class="head">VOP1</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>V_MAD_LEGACY
_F32</td>
<td>V_ADD_F64</td>
<td>V_ADD_{
F16,F32,
U16,U32}</td>
<td>V_NOP</td>
</tr>
<tr class="row-odd"><td>V_MAD_{
F16,I16,U16,F3
2}</td>
<td>V_MUL_F64</td>
<td>V_SUB_{
F16,F32,U16,
U32}</td>
<td>V_MOV_B32</td>
</tr>
<tr class="row-even"><td>V_MAD_LEGACY
_{F16,U16,I16
}</td>
<td>V_MIN_F64</td>
<td>V_SUBREV_{
F16,F32,
U16,U32}</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>V_MAD_I32_I
24</td>
<td>V_MAX_F64</td>
<td>V_ADD_CO_U3
2</td>
<td>V_READFIRSTLANE_B32</td>
</tr>
<tr class="row-even"><td>V_MAD_U32_U
24</td>
<td>V_LDEXP_F64</td>
<td>V_SUB_CO_U3
2</td>
<td>V_CVT_F32_{I32,U32,F16,F6
4
}</td>
</tr>
<tr class="row-odd"><td>V_CUBEID_F32</td>
<td>V_MUL_LO_U3
2</td>
<td>V_SUBREV_CO_U32</td>
<td>V_CVT_{I32,U32,F16,
F64}_F32</td>
</tr>
<tr class="row-even"><td>V_CUBESC_F32</td>
<td>V_MUL_HI_{I
32,U32}</td>
<td>V_ADDC_U32</td>
<td>V_CVT_{I32,U32}_F64</td>
</tr>
<tr class="row-odd"><td>V_CUBETC_F32</td>
<td>V_LSHLREV_B6
4</td>
<td>V_SUBB_U32</td>
<td>V_CVT_F64_{I32,U32}</td>
</tr>
<tr class="row-even"><td>V_CUBEMA_F32</td>
<td>V_LSHRREV_B6
4</td>
<td>V_SUBBREV_U3
2</td>
<td>V_CVT_F32_UBYTE{0,1,2,3}</td>
</tr>
<tr class="row-odd"><td>V_BFE_{U32 ,
I32 }</td>
<td>V_ASHRREV_I6
4</td>
<td>V_MUL_LEGACY
_F32</td>
<td>V_CVT_F16_{U16, I16}</td>
</tr>
<tr class="row-even"><td>V_FMA_{ F16,
F32 , F64}</td>
<td>V_LDEXP_F32</td>
<td>V_MUL_{F16,
F32}</td>
<td>V_CVT_RPI_I32_F32</td>
</tr>
<tr class="row-odd"><td>V_FMA_LEGACY
_F16</td>
<td>V_READLANE_B
32</td>
<td>V_MUL_I32_I
24</td>
<td>V_CVT_FLR_I32_F32</td>
</tr>
<tr class="row-even"><td>V_BFI_B32</td>
<td>V_WRITELANE_
B32</td>
<td>V_MUL_HI_I3
2_I24</td>
<td>V_CVT_OFF_F32_I4</td>
</tr>
<tr class="row-odd"><td>V_LERP_U8</td>
<td>V_BCNT_U32_
B32</td>
<td>V_MUL_U32_U
24</td>
<td>V_FRACT_{ F16,F32,F64}</td>
</tr>
<tr class="row-even"><td>V_ALIGNBIT_B
32</td>
<td>V_MBCNT_LO_
U32_B32</td>
<td>V_MUL_HI_U3
2_U24</td>
<td>V_TRUNC_{ F16,F32, F64}</td>
</tr>
<tr class="row-odd"><td>V_ALIGNBYTE_
B32</td>
<td>V_MBCNT_HI_
U32_B32</td>
<td>V_MIN_{
F16,U16,
I16,F32,I32,U3
2}</td>
<td>V_CEIL_{ F16,F32, F64}</td>
</tr>
<tr class="row-even"><td>V_MIN3_{F32,
I32,U32}</td>
<td>V_CVT_PKACCU
M_U8_F32</td>
<td>V_MAX_{
F16,U16,
I16,F32,I32,U3
2}</td>
<td>V_RNDNE_{ F16,F32, F64}</td>
</tr>
<tr class="row-odd"><td>V_MAX3_{F32,
I32,U32}</td>
<td>V_CVT_PKNORM
_I16_F32</td>
<td>V_LSHRREV_{
B16,B32}</td>
<td>V_FLOOR_{ F16,F32, F64}</td>
</tr>
<tr class="row-even"><td>V_MED3_{F32,
I32,U32}</td>
<td>V_CVT_PKNORM
_U16_F32</td>
<td>V_ASHRREV_{I
16,I32}</td>
<td>V_EXP_{ F16,F32}</td>
</tr>
<tr class="row-odd"><td>V_SAD_{U8,
HI_U8, U16,
U32}</td>
<td>V_CVT_PKRTZ_F16_F32</td>
<td>V_LSHLREV_{
B16,B32}</td>
<td>V_LOG_ {F16,F32}</td>
</tr>
<tr class="row-even"><td>V_CVT_PK_U8
_F32</td>
<td>V_CVT_PK_U1
6_U32</td>
<td>V_AND_B32</td>
<td>V_RCP_{ F16,F32,F64}</td>
</tr>
<tr class="row-odd"><td>V_DIV_FIXUP_{
F16,F32,F64}</td>
<td>V_CVT_PK_I1
6_I32</td>
<td>V_OR_B32</td>
<td>V_RCP_IFLAG_F32</td>
</tr>
<tr class="row-even"><td>V_DIV_FIXUP_LEGACY_F16</td>
<td>V_MAC_LEGACY
_F32</td>
<td>V_XOR_B32</td>
<td>V_RSQ_{ F16,F32, F64}</td>
</tr>
<tr class="row-odd"><td>V_DIV_SCALE_{F32,F64}</td>
<td>V_BFM_B32</td>
<td>V_MAC_{
F16,F32}</td>
<td>V_SQRT_{ F16,F32,F64}</td>
</tr>
<tr class="row-even"><td>V_DIV_FMAS_
{F32,F64}</td>
<td>V_INTERP_P1_F32</td>
<td>V_MADMK_{
F16,F32}</td>
<td>V_SIN_ {F16,F32}</td>
</tr>
<tr class="row-odd"><td>V_MSAD_U8</td>
<td>V_INTERP_P2_F32</td>
<td>V_MADAK_{
F16,F32}</td>
<td>V_COS_ {F16,F32}</td>
</tr>
<tr class="row-even"><td>V_QSAD_PK_U
16_U8</td>
<td>V_INTERP_MOV
_F32</td>
<td>V_CNDMASK_B3
2</td>
<td>V_NOT_B32</td>
</tr>
<tr class="row-odd"><td>V_MQSAD_PK_
U16_U8</td>
<td>V_INTERP_P1L
L_F16</td>
<td>V_LDEXP_F16</td>
<td>V_BFREV_B32</td>
</tr>
<tr class="row-even"><td>V_MQSAD_PK_
U32_U8</td>
<td>V_INTERP_P1L
V_F16</td>
<td>MUL_LO_U16</td>
<td>V_FFBH_{U32, I32}</td>
</tr>
<tr class="row-odd"><td>V_TRIG_PREOP
_F64</td>
<td>V_INTERP_P2_F16</td>
<td>&#160;</td>
<td>V_FFBL_B32</td>
</tr>
<tr class="row-even"><td>V_MAD_{U64_
U32,
I64_I32}</td>
<td>V_INTERP_P2_LEGACY_F16</td>
<td>&#160;</td>
<td>V_FREXP_EXP_I32_F64</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>V_CVT_PKNORM
_I16_F16</td>
<td>&#160;</td>
<td>V_FREXP_MANT_{
F16,F32,64}</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>V_CVT_PKNORM
_U16_F16</td>
<td>&#160;</td>
<td>V_FREXP_EXP_I32_F32</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>V_MAD_U32_U
16</td>
<td>&#160;</td>
<td>V_FREXP_EXP_I16_F16</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>V_MAD_I32_I
16</td>
<td>&#160;</td>
<td>V_CLREXCP</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>V_XAD_U32</td>
<td>&#160;</td>
<td>V_MOV_FED_B32</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>V_MIN3_{F16,
I16,U16}</td>
<td>&#160;</td>
<td>V_CVT_NORM_I16_F16</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>V_MAX3_{F16,
I16,U16}</td>
<td>&#160;</td>
<td>V_CVT_NORM_U16_F16</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>V_MED3_{F16,
I16,U16}</td>
<td>&#160;</td>
<td>V_SAT_PK_U8_I16</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>V_CVT_PKNORM
_{I16_F16,
U16_F16}</td>
<td>&#160;</td>
<td>V_WRITELANE_REGWR</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>V_READLANE_R
EGRD_B32</td>
<td>&#160;</td>
<td>V_SWAP_B32</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>V_PACK_B32_
F16</td>
<td>&#160;</td>
<td>V_SCREEN_PARTITION_4SE_B
32</td>
</tr>
</tbody>
</table>
<p>Table: VALU Instruction Set</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">The next table lists the compare instructions.</div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Op</th>
<th class="head">Formats</th>
<th class="head">Functions</th>
<th class="head">Result</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>V_CMP</td>
<td>I16, I32, I64,
U16, U32, U64</td>
<td>F, LT, EQ, LE, GT, LG, GE, T</td>
<td>Write VCC..</td>
</tr>
<tr class="row-odd"><td>V_CMPX</td>
<td>Write VCC and
exec.</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>V_CMP</td>
<td>F16, F32, F64</td>
<td><div class="first line-block">
<div class="line">F, LT, EQ,LE, GT, LG, GE,
T, GE, T,</div>
</div>
<div class="line-block">
<div class="line">O, U, NGE,
NLG, NGT,
NLE, NEQ,
NLT</div>
<div class="line">(o = total order, u =
unordered,</div>
</div>
<div class="last line-block">
<div class="line">N = NaN or
normal
compare)</div>
</div>
</td>
<td>Write VCC.</td>
</tr>
<tr class="row-odd"><td>V_CMPX</td>
<td>Write VCC and
exec.</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>V_CMP_CLASS</td>
<td>F16, F32, F64</td>
<td><div class="first line-block">
<div class="line">Test for one of: signaling
-NaN quiet-NaN,</div>
</div>
<dl class="last docutils">
<dt><a href="#id1"><span class="problematic" id="id2">|</span></a>positive or negative :</dt>
<dd>infinity,normal,subnormal,
zero</dd>
</dl>
</td>
<td>Write VCC.</td>
</tr>
<tr class="row-odd"><td>V_CMPX_CLASS</td>
<td>Write VCC and
exec.</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Table: VALU Instruction Set</p>
</div>
<div class="section" id="denormalized-and-rounding-modes">
<h3>Denormalized and Rounding Modes<a class="headerlink" href="#denormalized-and-rounding-modes" title="Permalink to this headline">¶</a></h3>
<p>The shader program has explicit control over the rounding mode applied
and the handling of denormalized inputs and results. The MODE register
is set using the S_SETREG instruction; it has separate bits for
controlling the behavior of single and double-precision floating-point
numbers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bit
Position</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FP_ROUND</td>
<td>3:0</td>
<td><div class="first last line-block">
<div class="line">[1:0] Single-precision round mode.</div>
<div class="line">[3:2] Double-precision round mode.</div>
<div class="line">Round Modes: 0=nearest even; 1= +infinity; 2=
-infinity, 3= toward zero.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>FP_DENORM</td>
<td>7:4</td>
<td><div class="first last line-block">
<div class="line">[5:4] Single-precision denormal mode.</div>
<div class="line">[7:6] Double-precision denormal mode.</div>
<div class="line">Denormal modes:</div>
<div class="line">0 = Flush input and output denorms.</div>
<div class="line">1 = Allow input denorms, flush output denorms.</div>
<div class="line">2 = Flush input denorms, allow output denorms.</div>
<div class="line">3 = Allow input and output denorms.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table: Round and Denormal Modes</p>
</div>
<div class="section" id="alu-clamp-bit-usage">
<h3>ALU Clamp Bit Usage<a class="headerlink" href="#alu-clamp-bit-usage" title="Permalink to this headline">¶</a></h3>
<p>In GCN Vega Generation, the meaning of the “Clamp” bit in the VALU
instructions has changed. For V_CMP instructions, setting the clamp bit
to 1 indicates that the compare signals if a floating point exception
occurs. For integer operations, it clamps the result to the largest and
smallest representable value. For floating point operations, it clamps
the result to the range: [0.0, 1.0].</p>
</div>
<div class="section" id="vgpr-indexing">
<h3>VGPR Indexing<a class="headerlink" href="#vgpr-indexing" title="Permalink to this headline">¶</a></h3>
<p>VGPR Indexing allows a value stored in the M0 register to act as an
index into the VGPRs either for the source or destination registers in
VALU instructions.</p>
<div class="section" id="indexing-instructions">
<h4>Indexing Instructions<a class="headerlink" href="#indexing-instructions" title="Permalink to this headline">¶</a></h4>
<p>The table below describes the instructions which enable, disable and
control VGPR indexing.</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="13%" />
<col width="10%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Encoding</th>
<th class="head">Sets
SCC?</th>
<th class="head">Operation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>S_SET_GPR_IDX_
OFF</td>
<td>SOPP</td>
<td>N</td>
<td>Disable VGPR indexing mode. Sets:
mode.gpr_idx_en = 0.</td>
</tr>
<tr class="row-odd"><td>S_SET_GPR_IDX_
ON</td>
<td>SOPC</td>
<td>N</td>
<td><div class="first last line-block">
<div class="line">Enable VGPR indexing, and set the
index value and mode from an SGPR.
mode.gpr_idx_en = 1</div>
<div class="line">M0[7:0] = S0.u[7:0]</div>
<div class="line">M0[15:12] = SIMM4</div>
</div>
</td>
</tr>
<tr class="row-even"><td>S_SET_GPR_IDX_
IDX</td>
<td>SOP1</td>
<td>N</td>
<td><div class="first last line-block">
<div class="line">Set the VGPR index value:</div>
<div class="line">M0[7:0] = S0.u[7:0]</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>S_SET_GPR_IDX_
MODE</td>
<td>SOPP</td>
<td>N</td>
<td><div class="first last line-block">
<div class="line">Change the VGPR indexing mode,
which is stored in</div>
<div class="line">M0[15:12].</div>
<div class="line">M0[15:12] = SIMM4</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table: VGPR Indexing Instructions</p>
<p>Indexing is enabled and disabled by a bit in the MODE register:
gpr_idx_en. When enabled, two fields from M0 are used to determine the
index value and what it applies to:</p>
<ul class="simple">
<li>M0[7:0] holds the unsigned index value, added to selected source or
destination VGPR addresses.</li>
<li>M0[15:12] holds a four-bit mask indicating to which source or
destination the index is applied.<ul>
<li>M0[15] = dest_enable.</li>
<li>M0[14] = src2_enable.</li>
<li>M0[13] = src1_enable.</li>
<li>M0[12] = src0_enable.</li>
</ul>
</li>
</ul>
<p>Indexing only works on VGPR source and destinations, not on inline
constants or SGPRs. It is illegal for the index attempt to address VGPRs
that are out of range.</p>
</div>
<div class="section" id="special-cases">
<h4>Special Cases<a class="headerlink" href="#special-cases" title="Permalink to this headline">¶</a></h4>
<p>This section describes how VGPR indexing is applied to instructions that
use source and destination registers in unusual ways. The table below
shows which M0 bits control indexing of the sources and destination
registers for these special instructions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Microcode
Encodes</th>
<th class="head">VALU Receives</th>
<th class="head">M0[15]
(dst)</th>
<th class="head">M0[15]
(s2)</th>
<th class="head">M0[15]
(s1)</th>
<th class="head">M0[12]
(s0)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>v_readlane</td>
<td>sdst = src0,
SS1</td>
<td>&#160;</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>src0</td>
</tr>
<tr class="row-odd"><td>v_readfirstlan
e</td>
<td>sdst =
func(src0)</td>
<td>&#160;</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>src0</td>
</tr>
<tr class="row-even"><td>v_writelane</td>
<td>dst = func(ss0,
ss1)</td>
<td>&#160;</td>
<td>dst</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr class="row-odd"><td>v_mac_*</td>
<td>dst = src0 *
src1 + dst</td>
<td>mad: dst, src0,
src1, src2</td>
<td>dst,
s2</td>
<td>x</td>
<td>src1</td>
<td>src0</td>
</tr>
<tr class="row-even"><td>v_madak</td>
<td>dst = src0 *
src1 + imm</td>
<td>mad: dst, src0,
src1, src2</td>
<td>dst</td>
<td>x</td>
<td>src1</td>
<td>src0</td>
</tr>
<tr class="row-odd"><td>v_madmk</td>
<td>dst = S0 * imm
+ src1</td>
<td>mad: dst, src0,
src1, src2</td>
<td>dst</td>
<td>src2</td>
<td>x</td>
<td>src0</td>
</tr>
<tr class="row-even"><td>v_*sh*_rev</td>
<td>dst = S1 &lt;&lt; S0</td>
<td>&lt;shift&gt; (src1,
src0)</td>
<td>dst</td>
<td>x</td>
<td>src1</td>
<td>src0</td>
</tr>
<tr class="row-odd"><td>v_cvt_pkaccum</td>
<td>uses dst as
src2</td>
<td>&#160;</td>
<td>dst,
s2</td>
<td>x</td>
<td>src1</td>
<td>src0</td>
</tr>
<tr class="row-even"><td>SDWA (dest
preserve,
sub-Dword mask)</td>
<td>uses dst as
src2 for
read-mod-write</td>
<td>&#160;</td>
<td>&#160;</td>
<td>dst,
s2</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">where:</div>
<div class="line">src= vector source</div>
<div class="line">SS = scalar source</div>
<div class="line">dst = vector destination</div>
<div class="line">sdst = scalar destination</div>
</div>
</div>
</div>
<div class="section" id="packed-math">
<h3>Packed Math<a class="headerlink" href="#packed-math" title="Permalink to this headline">¶</a></h3>
<p>Vega adds support for <strong>packed math</strong>, which performs operations on two
16-bit values within a Dword as if they were separate threads. For
example, a packed add of V0=V1+V2 is really two separate adds: adding
the low 16 bits of each Dword and storing the result in the low 16 bit s
of V0, and adding the high halves.</p>
<p>Packed math uses the instructions below and the microcode format
“VOP3P”. This format adds op_sel and neg fields for both the low and
high operands, and removes ABS and OMOD.</p>
<p>Packed Math Opcodes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>V_PK_MAD_I16</td>
<td>V_PK_MUL_LO_U1
6</td>
<td>V_PK_ADD_I16</td>
<td>V_PK_SUB_I16</td>
</tr>
<tr class="row-even"><td>V_PK_LSHLREV_B1
6</td>
<td>V_PK_LSHRREV_B1
6</td>
<td>V_PK_ASHRREV_I1
6</td>
<td>V_PK_MAX_I16</td>
</tr>
<tr class="row-odd"><td>V_PK_MIN_I16</td>
<td>V_PK_MAD_U16</td>
<td>V_PK_ADD_U16</td>
<td>V_PK_SUB_U16</td>
</tr>
<tr class="row-even"><td>V_PK_MAX_U16</td>
<td>V_PK_MIN_U16</td>
<td>V_PK_FMA_F16</td>
<td>V_PK_ADD_F16</td>
</tr>
<tr class="row-odd"><td>V_PK_MUL_F16</td>
<td>V_PK_MIN_F16</td>
<td>V_PK_MAX_F16</td>
<td>V_MAD_MIX_F32</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">V_MAD_MIX_* are not packed math, but perform a single MAD operation on a mixture of 16- and 32-bit inputs. They are listed here because they use the VOP3P encoding.</p>
</div>
</div>
</div>
<div class="section" id="scalar-memory-operations">
<h2>Scalar Memory Operations<a class="headerlink" href="#scalar-memory-operations" title="Permalink to this headline">¶</a></h2>
<p>Scalar Memory Read (SMEM) instructions allow a shader program to load
data from memory into SGPRs through the Scalar Data Cache, or write data
from SGPRs to memory through the Scalar Data Cache. Instructions can
read from 1 to 16 Dwords, or write 1 to 4 Dwords at a time. Data is read
directly into SGPRs without any format conversion.</p>
<p>The scalar unit reads and writes consecutive Dwords between memory and
the SGPRs. This is intended primarily for loading ALU constants and for
indirect T#/S# lookup. No data formatting is supported, nor is byte or
short data.</p>
<div class="section" id="microcode-encoding">
<h3>Microcode Encoding<a class="headerlink" href="#microcode-encoding" title="Permalink to this headline">¶</a></h3>
<p>Scalar memory read, write and atomic instructions are encoded using the
SMEM microcode format.</p>
<p><img alt="microcode smem" src="../_images/microcode_smem.png" /></p>
<p>The fields are described in the table below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OP</td>
<td>8</td>
<td>Opcode.</td>
</tr>
<tr class="row-odd"><td>IMM</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">Determines how the
OFFSET field is
interpreted.</div>
<div class="line">IMM=1 : Offset is a
20-bit unsigned byte
offset to the address.</div>
<div class="line">IMM=0 : Offset[6:0]
specifies an SGPR or
M0 which provides an
unsigned byte offset.
STORE and ATOMIC
instructions cannot
use an SGPR: only imm
or M0.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>GLC</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">Globally Coherent.</div>
<div class="line">For loads, controls L1
cache policy:
0=hit_lru,
1=miss_evict.</div>
<div class="line">For stores, controls
L1 cache bypass:
0=write-combine,
1=write-thru.</div>
<div class="line">For atomics, “1”
indicates that the
atomic returns the
pre-op value.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>SDATA</td>
<td>7</td>
<td><div class="first last line-block">
<div class="line">SGPRs to return read
data to, or to source
write-data from.</div>
<div class="line">Reads of two Dwords
must have an even
SDST-sgpr.</div>
<div class="line">Reads of four or more
Dwords must have their
DST-gpr aligned to a
multiple of 4.</div>
<div class="line">SDATA must be: SGPR or
VCC. Not: exec or m0.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>SBASE</td>
<td>6</td>
<td>SGPR-pair (SBASE has an
implied LSB of zero)
which provides a base
address, or for BUFFER
instructions, a set of 4
SGPRs (4-sgpr aligned)
which hold the resource
constant. For BUFFER
instructions, the only
resource fields used
are: base, stride,
num_records.</td>
</tr>
<tr class="row-odd"><td>OFFSET</td>
<td>20</td>
<td>An unsigned byte offset,
or the address of an
SGPR holding the offset.
Writes and atomics: M0
or immediate only, not
SGPR.</td>
</tr>
<tr class="row-even"><td>NV</td>
<td>1</td>
<td>Non-volatile.</td>
</tr>
<tr class="row-odd"><td>SOE</td>
<td>1</td>
<td>Scalar Offset Enable.</td>
</tr>
</tbody>
</table>
<p>Table: SMEM Encoding Field Descriptions</p>
</div>
<div class="section" id="operations">
<h3>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="s-load-dword-s-store-dword">
<h4>S_LOAD_DWORD, S_STORE_DWORD<a class="headerlink" href="#s-load-dword-s-store-dword" title="Permalink to this headline">¶</a></h4>
<p>These instructions load 1-16 Dwords or store 1-4 Dwords between SGPRs
and memory. The data in SGPRs is specified in SDATA, and the address is
composed of the SBASE, OFFSET, and SOFFSET fields.</p>
<div class="section" id="scalar-memory-addressing">
<h5>Scalar Memory Addressing<a class="headerlink" href="#scalar-memory-addressing" title="Permalink to this headline">¶</a></h5>
<p>S_LOAD / S_STORE / S_DACHE_DISCARD:</p>
<div class="informalexample"><p>ADDR = SGPR[base] + inst_offset + { M0 or SGPR[offset] or zero }</p>
</div><p>S_SCRATCH_LOAD / S_SCRATCH_STORE:</p>
<div class="informalexample"><p>ADDR = SGPR[base] + inst_offset + { M0 or SGPR[offset] or zero } * 64</p>
</div><p>Use of offset fields:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">IMM</th>
<th class="head">SOFFSET_EN (SOE)</th>
<th class="head">Address</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>SGPR[base] +
(SGPR[offset] or M0)</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>SGPR[base] +
(SGPR[soffset] or M0)</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>SGPR[base] +
inst_offset</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>SGPR[base] +
inst_offset +
(SGPR[soffset] or M0)</td>
</tr>
</tbody>
</table>
<p>All components of the address (base, offset, inst_offset, M0) are in
bytes, but the two LSBs are ignored and treated as if they were zero.
S_DCACHE_DISCARD ignores the six LSBs to make the address
64-byte-aligned.</p>
<div class="line-block">
<div class="line">It is illegal and undefined if the inst_offset is negative and the
resulting</div>
<div class="line">(inst_offset + (M0 or SGPR[offset])) is negative.</div>
</div>
<p>Scalar access to private space must either use a buffer constant or
manually convert the address:</p>
<div class="informalexample"><p>Addr = Addr - private_base + private_base_addr +
scratch_baseOffset_for_this_wave</p>
</div><p>“Hidden private base” is not available to the shader through hardware:
It must be preloaded into an SGPR or made available through a constant
buffer. This is equivalent to what the driver must do to calculate the
base address from scratch for buffer constants.</p>
<p>A scalar instruction must not overwrite its own source registers because
the possibility of the instruction being replayed due to an ATC XNACK.
Similarly, instructions in scalar memory clauses must not overwrite the
sources of any of the instructions in the clause. A clause is defined as
a string of memory instructions of the same type. A clause is broken by
any non-memory instruction.</p>
<p>Atomics are a special case because they are always naturally aligned and
they must be in a single-instruction clause. By definition, an atomic
that returns the pre-op value overwrites its data source, which is
acceptable.</p>
<div class="section" id="reads-writes-atomics-using-buffer-constant">
<h6>Reads/Writes/Atomics using Buffer Constant<a class="headerlink" href="#reads-writes-atomics-using-buffer-constant" title="Permalink to this headline">¶</a></h6>
<p>Buffer constant fields used: base_address, stride, num_records, NV.
Other fields are ignored.</p>
<p>Scalar memory read/write does not support “swizzled” buffers. <strong>Stride</strong>
is used only for memory address bounds checking, not for computing the
address to access.</p>
<p>The SMEM supplies only a SBASE address (byte) and an offset (byte or
Dword). Any “index * stride” must be calculated manually in shader code
and added to the offset prior to the SMEM.</p>
<p>The two LSBs of V#.base and of the final address are ignored to force
Dword alignment.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&quot;m_*&quot; components come from the buffer constant (V#):
  offset     = IMM ? OFFSET : SGPR[OFFSET]
  m_base     = { SGPR[SBASE * 2 +1][15:0], SGPR[SBASE] }
  m_stride   = SGPR[SBASE * 2 +1][31:16]
  m_num_records = SGPR[SBASE * 2 + 2]
  m_size     = (m_stride == 0) ? 1 : m_num_records
  m_addr     = (SGPR[SBASE * 2] + offset) &amp; ~0x3
  SGPR[SDST] = read_Dword_from_dcache(m_base, offset, m_size)

  If more than 1 dword is being read, it is returned to SDST+1, SDST+2, etc,
  and the offset is incremented by 4 bytes per DWORD.
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="scalar-atomic-operations">
<h4>Scalar Atomic Operations<a class="headerlink" href="#scalar-atomic-operations" title="Permalink to this headline">¶</a></h4>
<p>The scalar memory unit supports the same set of memory atomics as the
vector memory unit. Addressing is the same as for scalar memory loads
and stores. Like the vector memory atomics, scalar atomic operations can
return the “pre-operation value” to the SDATA SGPRs. This is enabled by
setting the microcode GLC bit to 1.</p>
</div>
<div class="section" id="s-dcache-inv-s-dcache-wb">
<h4>S_DCACHE_INV, S_DCACHE_WB<a class="headerlink" href="#s-dcache-inv-s-dcache-wb" title="Permalink to this headline">¶</a></h4>
<p>This instruction invalidates, or does a “write back” of dirty data, for
the entire data cache. It does not return anything to SDST.</p>
</div>
<div class="section" id="s-memtime">
<h4>S_MEMTIME<a class="headerlink" href="#s-memtime" title="Permalink to this headline">¶</a></h4>
<p>This instruction reads a 64-bit clock counter into a pair of SGPRs: SDST
and SDST+1.</p>
</div>
<div class="section" id="s-memrealtime">
<h4>S_MEMREALTIME<a class="headerlink" href="#s-memrealtime" title="Permalink to this headline">¶</a></h4>
<p>This instruction reads a 64-bit “real time-counter” and returns the
value into a pair of SGPRS: SDST and SDST+1. The time value is from a
clock for which the frequency is constant (not affected by power modes
or core clock frequency changes).</p>
</div>
</div>
<div class="section" id="dependency-checking">
<h3>Dependency Checking<a class="headerlink" href="#dependency-checking" title="Permalink to this headline">¶</a></h3>
<p>Scalar memory reads and writes can return data out-of-order from how
they were issued; they can return partial results at different times
when the read crosses two cache lines. The shader program uses the
LGKM_CNT counter to determine when the data has been returned to the
SDST SGPRs. This is done as follows.</p>
<ul class="simple">
<li>LGKM_CNT is incremented by 1 for every fetch of a single Dword.</li>
<li>LGKM_CNT is incremented by 2 for every fetch of two or more Dwords.</li>
<li>LGKM_CNT is decremented by an equal amount when each instruction
completes.</li>
</ul>
<p>Because the instructions can return out-of-order, the only sensible way
to use this counter is to implement S_WAITCNT 0; this imposes a wait
for all data to return from previous SMEMs before continuing.</p>
</div>
<div class="section" id="alignment-and-bounds-checking">
<h3>Alignment and Bounds Checking<a class="headerlink" href="#alignment-and-bounds-checking" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>SDST</dt>
<dd>The value of SDST must be even for fetches of two Dwords (including
S_MEMTIME), or a multiple of four for larger fetches. If this rule
is not followed, invalid data can result. If SDST is out-of-range,
the instruction is not executed.</dd>
<dt>SBASE</dt>
<dd>The value of SBASE must be even for S_BUFFER_LOAD (specifying the
address of an SGPR which is a multiple of four). If SBASE is
out-of-range, the value from SGPR0 is used.</dd>
<dt>OFFSET</dt>
<dd>The value of OFFSET has no alignment restrictions.</dd>
</dl>
<p><strong>Memory Address</strong> : If the memory address is out-of-range (clamped),
the operation is not performed for any Dwords that are out-of-range.</p>
</div>
</div>
<div class="section" id="vector-memory-operations">
<span id="id3"></span><h2>Vector Memory Operations<a class="headerlink" href="#vector-memory-operations" title="Permalink to this headline">¶</a></h2>
<p>Vector Memory (VMEM) instructions read or write one piece of data
separately for each work-item in a wavefront into, or out of, VGPRs.
This is in contrast to Scalar Memory instructions, which move a single
piece of data that is shared by all threads in the wavefront. All Vector
Memory (VM) operations are processed by the texture cache system (level
1 and level 2 caches).</p>
<p>Software initiates a load, store or atomic operation through the texture
cache through one of three types of VMEM instructions:</p>
<ul class="simple">
<li>MTBUF: Memory typed-buffer operations.</li>
<li>MUBUF: Memory untyped-buffer operations.</li>
<li>MIMG: Memory image operations.</li>
</ul>
<p>The instruction defines which VGPR(s) supply the addresses for the
operation, which VGPRs supply or receive data from the operation, and a
series of SGPRs that contain the memory buffer descriptor (V# or T#).
Also, MIMG operations supply a texture sampler from a series of four
SGPRs; this sampler defines texel filtering operations to be performed
on data read from the image.</p>
<div class="section" id="vector-memory-buffer-instructions">
<h3>Vector Memory Buffer Instructions<a class="headerlink" href="#vector-memory-buffer-instructions" title="Permalink to this headline">¶</a></h3>
<p>Vector-memory (VM) operations transfer data between the VGPRs and buffer
objects in memory through the texture cache (TC). <strong>Vector</strong> means that
one or more piece of data is transferred uniquely for every thread in
the wavefront, in contrast to scalar memory reads, which transfer only
one value that is shared by all threads in the wavefront.</p>
<p>Buffer reads have the option of returning data to VGPRs or directly into
LDS.</p>
<p>Examples of buffer objects are vertex buffers, raw buffers, stream-out
buffers, and structured buffers.</p>
<p>Buffer objects support both homogeneous and heterogeneous data, but no
filtering of read-data (no samplers). Buffer instructions are divided
into two groups:</p>
<ul class="simple">
<li>MUBUF: Untyped buffer objects.<ul>
<li>Data format is specified in the resource constant.</li>
<li>Load, store, atomic operations, with or without data format
conversion.</li>
</ul>
</li>
<li>MTBUF: Typed buffer objects.<ul>
<li>Data format is specified in the instruction.</li>
<li>The only operations are Load and Store, both with data format
conversion.</li>
</ul>
</li>
</ul>
<p>Atomic operations take data from VGPRs and combine them arithmetically
with data already in memory. Optionally, the value that was in memory
before the operation took place can be returned to the shader.</p>
<p>All VM operations use a buffer resource constant (V#) which is a 128-bit
value in SGPRs. This constant is sent to the texture cache when the
instruction is executed. This constant defines the address and
characteristics of the buffer in memory. Typically, these constants are
fetched from memory using scalar memory reads prior to executing VM
instructions, but these constants also can be generated within the
shader.</p>
<div class="section" id="simplified-buffer-addressing">
<h4>Simplified Buffer Addressing<a class="headerlink" href="#simplified-buffer-addressing" title="Permalink to this headline">¶</a></h4>
<p>The equation below shows how the hardware calculates the memory address
for a buffer access.</p>
<p><img alt="fig 8 1" src="../_images/fig_8_1.png" /></p>
</div>
<div class="section" id="buffer-instructions">
<h4>Buffer Instructions<a class="headerlink" href="#buffer-instructions" title="Permalink to this headline">¶</a></h4>
<p>Buffer instructions (MTBUF and MUBUF) allow the shader program to read
from, and write to, linear buffers in memory. These operations can
operate on data as small as one byte, and up to four Dwords per
work-item. Atomic arithmetic operations are provided that can operate on
the data values in memory and, optionally, return the value that was in
memory before the arithmetic operation was performed.</p>
<p>The D16 instruction variants convert the results to packed 16-bit
values. For example, BUFFER_LOAD_FORMAT_D16_XYZW will write two
VGPRs.</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MTBUF Instructions</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">TBUFFER_LOAD_FORMAT_{x,x
y,xyz,xyzw}</div>
<div class="line">TBUFFER_STORE_FORMAT_{x,
xy,xyz,xyzw}</div>
</div>
</td>
<td>Read from, or write to, a typed buffer
object. Also used for a vertex fetch.</td>
</tr>
<tr class="row-even"><td>MUBUF Instructions</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">BUFFER_LOAD_FORMAT_{x,xy
,xyz,xyzw}</div>
<div class="line">BUFFER_STORE_FORMAT_{x,x
y,xyz,xyzw}</div>
<div class="line">BUFFER_LOAD_&lt;size&gt;</div>
<div class="line">BUFFER_STORE_&lt;size&gt;</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Read to, or write from, an untyped
buffer object.</div>
<div class="line">&lt;size&gt; = byte, ubyte, short, ushort,
Dword, Dwordx2, Dwordx3, Dwordx4
BUFFER_ATOMIC_&lt;op&gt;</div>
<div class="line">BUFFER_ATOMIC_&lt;op&gt;_ x2</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table: Buffer Instructions</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bit Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OP</td>
<td><div class="first last line-block">
<div class="line">4</div>
<div class="line">7</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">MTBUF: Opcode for
Typed buffer
instructions.</div>
<div class="line">MUBUF: Opcode for
Untyped buffer
instructions.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>VADDR</td>
<td>8</td>
<td>Address of VGPR to
supply first component
of address (offset or
index). When both index
and offset are used,
index is in the first
VGPR, offset in the
second.</td>
</tr>
<tr class="row-even"><td>VDATA</td>
<td>8</td>
<td>Address of VGPR to
supply first component
of write data or receive
first component of
read-data.</td>
</tr>
<tr class="row-odd"><td>SOFFSET</td>
<td>8</td>
<td>SGPR to supply unsigned
byte offset. Must be an
SGPR, M0, or inline
constant.</td>
</tr>
<tr class="row-even"><td>SRSRC</td>
<td>5</td>
<td>Specifies which SGPR
supplies T# (resource
constant) in four or
eight consecutive SGPRs.
This field is missing
the two LSBs of the SGPR
address, since this
address must be aligned
to a multiple of four
SGPRs.</td>
</tr>
<tr class="row-odd"><td>DFMT</td>
<td>4</td>
<td><div class="first last line-block">
<div class="line">Data Format of data in
memory buffer:</div>
<div class="line">0 invalid</div>
<div class="line">1 8</div>
<div class="line">2 16</div>
<div class="line">3 8_8</div>
<div class="line">4 32</div>
<div class="line">5 16_16</div>
<div class="line">6 10_11_11</div>
<div class="line">7 11_11_10</div>
<div class="line">8 10_10_10_2</div>
<div class="line">9 2_10_10_10</div>
<div class="line">10 8_8_8_8</div>
<div class="line">11 32_32</div>
<div class="line">12 16_16_16_16</div>
<div class="line">13 32_32_32</div>
<div class="line">14 32_32_32_32</div>
<div class="line">15 reserved</div>
</div>
</td>
</tr>
<tr class="row-even"><td>NFMT</td>
<td>3</td>
<td><div class="first last line-block">
<div class="line">Numeric format of data
in memory:</div>
<div class="line">0 unorm</div>
<div class="line">1 snorm</div>
<div class="line">2 uscaled</div>
<div class="line">3 sscaled</div>
<div class="line">4 uint</div>
<div class="line">5 sint</div>
<div class="line">6 reserved</div>
<div class="line">7 float</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>OFFSET</td>
<td>12</td>
<td>Unsigned byte offset.</td>
</tr>
<tr class="row-even"><td>OFFEN</td>
<td>1</td>
<td>1 = Supply an offset
from VGPR (VADDR). 0 =
Do not (offset = 0).</td>
</tr>
<tr class="row-odd"><td>IDXEN</td>
<td>1</td>
<td>1 = Supply an index from
VGPR (VADDR). 0 = Do not
(index = 0).</td>
</tr>
<tr class="row-even"><td>GLC</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">Globally Coherent.
Controls how reads and
writes are handled by
the L1 texture cache.</div>
<div class="line"><strong>READ</strong></div>
<div class="line">GLC = 0 Reads can hit
on the L1 and persist
across wavefronts</div>
<div class="line">GLC = 1 Reads always
miss the L1 and force
fetch to L2. No L1
persistence across
waves.</div>
<div class="line"><strong>WRITE</strong></div>
<div class="line">GLC = 0 Writes miss
the L1, write through
to L2, and persist in
L1 across wavefronts.</div>
<div class="line">GLC = 1 Writes miss
the L1, write through
to L2. No persistence
across wavefronts.</div>
<div class="line"><strong>ATOMIC</strong></div>
<div class="line">GLC = 0 Previous data
value is not returned.
No L1 persistence
across wavefronts.</div>
<div class="line">GLC = 1 Previous data
value is returned. No
L1 persistence across
wavefronts.</div>
<div class="line">Note: GLC means
“return pre-op value”
for atomics.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>SLC</td>
<td>1</td>
<td>System Level Coherent.
When set, accesses are
forced to miss in level
2 texture cache and are
coherent with system
memory.</td>
</tr>
<tr class="row-even"><td>TFE</td>
<td>1</td>
<td>Texel Fail Enable for
PRT (partially resident
textures). When set to
1, fetch can return a
NACK that causes a VGPR
write into DST+1 (first
GPR after all fetch-dest
GPRs).</td>
</tr>
<tr class="row-odd"><td>LDS</td>
<td>1</td>
<td>MUBUF-ONLY: 0 = Return
read-data to VGPRs. 1 =
Return read-data to LDS
instead of VGPRs.</td>
</tr>
</tbody>
</table>
<p>Table: Microcode Formats</p>
</div>
<div class="section" id="vgpr-usage">
<h4>VGPR Usage<a class="headerlink" href="#vgpr-usage" title="Permalink to this headline">¶</a></h4>
<p>VGPRs supply address and write-data; also, they can be the destination
for return data (the other option is LDS).</p>
<dl class="docutils">
<dt>Address</dt>
<dd>Zero, one or two VGPRs are used, depending of the offset-enable
(OFFEN) and index-enable (IDXEN) in the instruction word, as shown
in the table below:</dd>
</dl>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">IDXEN</th>
<th class="head">OFFEN</th>
<th class="head">VGPRn</th>
<th class="head">VGPRn+1</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>nothing</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>uint offset</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>uint index</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>uint index</td>
<td>uint offset</td>
</tr>
</tbody>
</table>
<p>Table: Address VGPRs</p>
<p><strong>Write Data</strong> : N consecutive VGPRs, starting at VDATA. The data format
specified in the instruction word (NFMT, DFMT for MTBUF, or encoded in
the opcode field for MUBUF) determines how many Dwords to write.</p>
<p><strong>Read Data</strong> : Same as writes. Data is returned to consecutive GPRs.</p>
<p><strong>Read Data Format</strong> : Read data is always 32 bits, based on the data
format in the instruction or resource. Float or normalized data is
returned as floats; integer formats are returned as integers (signed or
unsigned, same type as the memory storage format). Memory reads of data
in memory that is 32 or 64 bits do not undergo any format conversion.</p>
<p><strong>Atomics with Return</strong> : Data is read out of the VGPR(s) starting at
VDATA to supply to the atomic operation. If the atomic returns a value
to VGPRs, that data is returned to those same VGPRs starting at VDATA.</p>
</div>
<div class="section" id="buffer-data">
<h4>Buffer Data<a class="headerlink" href="#buffer-data" title="Permalink to this headline">¶</a></h4>
<p>The amount and type of data that is read or written is controlled by the
following: data-format (dfmt), numeric-format (nfmt),
destination-component-selects (dst_sel), and the opcode. Dfmt and nfmt
can come from the resource, instruction fields, or the opcode itself.
Dst_sel comes from the resource, but is ignored for many operations.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Data Format</th>
<th class="head">Num Format</th>
<th class="head">DST SEL</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>TBUFFER_LOAD_FOR
MAT_*</td>
<td>instruction</td>
<td>instruction</td>
<td>identity</td>
</tr>
<tr class="row-odd"><td>TBUFFER_STORE_FO
RMAT_*</td>
<td>instruction</td>
<td>instruction</td>
<td>identity</td>
</tr>
<tr class="row-even"><td>BUFFER_LOAD_&lt;typ
e&gt;</td>
<td>derived</td>
<td>derived</td>
<td>identity</td>
</tr>
<tr class="row-odd"><td>BUFFER_STORE_&lt;ty
pe&gt;</td>
<td>derived</td>
<td>derived</td>
<td>identity</td>
</tr>
<tr class="row-even"><td>BUFFER_LOAD_FORM
AT_*</td>
<td>resource</td>
<td>resource</td>
<td>resource</td>
</tr>
<tr class="row-odd"><td>BUFFER_STORE_FOR
MAT_*</td>
<td>resource</td>
<td>resource</td>
<td>resource</td>
</tr>
<tr class="row-even"><td>BUFFER_ATOMIC_*</td>
<td>derived</td>
<td>derived</td>
<td>identity</td>
</tr>
</tbody>
</table>
<p>Table: Buffer Instructions</p>
<p><strong>Instruction</strong> : The instruction’s dfmt and nfmt fields are used
instead of the resource’s fields.</p>
<p><strong>Data format derived</strong> : The data format is derived from the opcode and
ignores the resource definition. For example, buffer_load_ubyte sets
the data-format to 8 and number-format to uint.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The resource’s data format must not be INVALID; that format has special meaning (unbound resource), and for that case the data format is not replaced by the instruction’s implied data format.</p>
</div>
<p><strong>DST_SEL identity</strong> : Depending on the number of components in the
data-format, this is: X000, XY00, XYZ0, or XYZW.</p>
<p>The MTBUF derives the data format from the instruction. The MUBUF
BUFFER_LOAD_FORMAT and BUFFER_STORE_FORMAT instructions use dst_sel
from the resource; other MUBUF instructions derive data-format from the
instruction itself.</p>
<p><strong>D16 Instructions</strong> : Load-format and store-format instructions also
come in a “d16” variant. For stores, each 32-bit VGPR holds two 16-bit
data elements that are passed to the texture unit. This texture unit
converts them to the texture format before writing to memory. For loads,
data returned from the texture unit is converted to 16 bits, and a pair
of data are stored in each 32-bit VGPR (LSBs first, then MSBs). Control
over int vs. float is controlled by NFMT.</p>
</div>
<div class="section" id="buffer-addressing">
<h4>Buffer Addressing<a class="headerlink" href="#buffer-addressing" title="Permalink to this headline">¶</a></h4>
<p>A <strong>buffer</strong> is a data structure in memory that is addressed with an
<strong>index</strong> and an <strong>offset</strong>. The index points to a particular record of
size <strong>stride</strong> bytes, and the offset is the byte-offset within the
record. The <strong>stride</strong> comes from the resource, the index from a VGPR
(or zero), and the offset from an SGPR or VGPR and also from the
instruction itself.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>inst_offset</td>
<td>12</td>
<td>Literal byte offset from
the instruction.</td>
</tr>
<tr class="row-odd"><td>inst_idxen</td>
<td>1</td>
<td>Boolean: get index from
VGPR when true, or no
index when false.</td>
</tr>
<tr class="row-even"><td>inst_offen</td>
<td>1</td>
<td>Boolean: get offset from
VGPR when true, or no
offset when false. Note
that inst_offset is
always present,
regardless of this bit.</td>
</tr>
</tbody>
</table>
<p>Table: BUFFER Instruction Fields for Addressing</p>
<p>The “element size” for a buffer instruction is the amount of data the
instruction transfers. It is determined by the DFMT field for MTBUF
instructions, or from the opcode for MUBUF instructions. It can be 1, 2,
4, 8, or 16 bytes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>const_base</td>
<td>48</td>
<td>Base address, in bytes,
of the buffer resource.</td>
</tr>
<tr class="row-odd"><td>const_stride</td>
<td><div class="first last line-block">
<div class="line">14</div>
<div class="line">or</div>
<div class="line">18</div>
</div>
</td>
<td><div class="first line-block">
<div class="line">Stride of the record
in bytes (0 to 16,383
bytes, or 0 to 262,143
bytes). Normally 14
bits, but is extended
to 18-bits when:</div>
<div class="line">const_add_tid_enabl
e
= true used with MUBUF
instructions which are
not <strong>format</strong> types
(or cache
invalidate/WB).</div>
<div class="line">This is extension
intended for use with
scratch (private)
buffers.</div>
</div>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">If</span> <span class="p">(</span><span class="n">const_add_tid_en</span>
<span class="n">able</span> <span class="o">&amp;&amp;</span> <span class="n">MUBUF</span><span class="o">-</span><span class="n">non</span><span class="o">-</span>
<span class="nb">format</span> <span class="n">instr</span><span class="o">.</span><span class="p">)</span>
    <span class="n">const_stride</span> <span class="p">[</span><span class="mi">17</span><span class="p">:</span><span class="mi">0</span>
<span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">V</span><span class="c1">#.DFMT[3:0],</span>

    <span class="n">V</span><span class="c1">#.const_stride[13</span>
<span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">const_stride</span> <span class="ow">is</span> <span class="mi">14</span>
<span class="n">bits</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="s1">&#39;b0, V#.const_s</span>
<span class="n">tride</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">0</span><span class="p">]}</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td>const_num_records</td>
<td>32</td>
<td><div class="first last line-block">
<div class="line">Number of records in
the buffer.</div>
<div class="line">In units of Bytes for
raw buffers, units of
Stride for structured
buffers, and ignored
for private (scratch)
buffers.</div>
<div class="line">In units of:
(inst_idxen == 1) ?
Bytes : Stride</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>const_add_tid_enable</td>
<td>1</td>
<td>Boolean. Add thread_ID
within the wavefront to
the index when true.</td>
</tr>
<tr class="row-even"><td>const_swizzle_enable</td>
<td>1</td>
<td>Boolean. Indicates that
the surface is swizzled
when true.</td>
</tr>
<tr class="row-odd"><td>const_element_size</td>
<td>2</td>
<td><div class="first last line-block">
<div class="line">Used only when
const_swizzle_en =
true. Number of
contiguous bytes of a
record for a given
index (2, 4, 8, or 16
bytes).</div>
<div class="line">Must be &gt;= the maximum
element size in the
structure.
const_stride must be
an integer multiple of
const_element_size.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>const_index_stride</td>
<td>2</td>
<td>Used only when
const_swizzle_en =
true. Number of
contiguous indices for a
single element (of
const_element_size)
before switching to the
next element. There are
8, 16, 32, or 64
indices.</td>
</tr>
</tbody>
</table>
<p>Table: V# Buffer Resource Constant Fields for Addressing</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SGPR_offset</td>
<td>32</td>
<td>An unsigned byte-offset
to the address. Comes
from an SGPR or M0.</td>
</tr>
<tr class="row-odd"><td>VGPR_offset</td>
<td>32</td>
<td>An optional unsigned
byte-offset. It is
per-thread, and comes
from a VGPR.</td>
</tr>
<tr class="row-even"><td>VGPR_index</td>
<td>32</td>
<td>An optional index value.
It is per-thread and
comes from a VGPR.</td>
</tr>
</tbody>
</table>
<p>Table: Address Components from GPRs</p>
<p>The final buffer memory address is composed of three parts:</p>
<ul class="simple">
<li>the base address from the buffer resource (V#),</li>
<li>the offset from the SGPR, and</li>
<li>a buffer-offset that is calculated differently, depending on whether
the buffer is linearly addressed (a simple Array-of-Structures
calculation) or is swizzled.</li>
</ul>
<div class="figure" id="id17">
<img alt="Address Calculation for a Linear Buffer" src="../_images/fig_8_2.png" />
<p class="caption"><span class="caption-text">Address Calculation for a Linear Buffer</span></p>
</div>
<div class="section" id="range-checking">
<h5>Range Checking<a class="headerlink" href="#range-checking" title="Permalink to this headline">¶</a></h5>
<p>Addresses can be checked to see if they are in or out of range. When an
address is out of range, reads will return zero, and writes and atomics
will be dropped. The address range check algorithm depends on the buffer
type.</p>
<dl class="docutils">
<dt>Private (Scratch) Buffer</dt>
<dd><div class="first last line-block">
<div class="line">Used when: AddTID==1 &amp;&amp; IdxEn==0</div>
<div class="line">For this buffer, there is no range checking.</div>
</div>
</dd>
<dt>Raw Buffer</dt>
<dd><div class="first last line-block">
<div class="line">Used when: AddTID==0 &amp;&amp; SWizzleEn==0 &amp;&amp; IdxEn==0</div>
<div class="line">Out of Range if: (InstOffset + (OffEN ? vgpr_offset : 0)) &gt;=
NumRecords</div>
</div>
</dd>
<dt>Structured Buffer</dt>
<dd><div class="first last line-block">
<div class="line">Used when: AddTID==0 &amp;&amp; Stride!=0 &amp;&amp; IdxEn==1</div>
<div class="line">Out of Range if: Index(vgpr) &gt;= NumRecords</div>
</div>
</dd>
</dl>
<p><strong>Notes:</strong></p>
<ol class="arabic simple">
<li>Reads that go out-of-range return zero (except for components with
V#.dst_sel = SEL_1 that return 1).</li>
<li>Writes that are out-of-range do not write anything.</li>
<li>Load/store-format-* instruction and atomics are range-checked “all
or nothing” - either entirely in or out.</li>
<li>Load/store-Dword-x{2,3,4} and range-check per component.</li>
</ol>
</div>
<div class="section" id="swizzled-buffer-addressing">
<h5>Swizzled Buffer Addressing<a class="headerlink" href="#swizzled-buffer-addressing" title="Permalink to this headline">¶</a></h5>
<p>Swizzled addressing rearranges the data in the buffer to help provide
improved cache locality for arrays of structures. Swizzled addressing
also requires Dword-aligned accesses. A single fetch instruction cannot
attempt to fetch a unit larger than const-element-size. The buffer’s
STRIDE must be a multiple of element_size.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Index = (inst_idxen ? vgpr_index : 0) +
        (const_add_tid_enable ? thread_id[5:0] : 0)

Offset = (inst_offen ? vgpr_offset : 0) + inst_offset

index_msb = index / const_index_stride
index_lsb = index % const_index_stride
offset_msb = offset / const_element_size
offset_lsb = offset % const_element_size

buffer_offset = (index_msb * const_stride + offset_msb *
                  const_element_size) * const_index_stride + index_lsb *
                  const_element_size + offset_lsb

Final Address = const_base + sgpr_offset + buffer_offset
</pre></div>
</div>
<p>Remember that the “sgpr_offset” is not a part of the “offset” term in
the above equations.</p>
<div class="figure" id="id18">
<img alt="Example of Buffer Swizzling" src="../_images/fig_8_3.png" />
<p class="caption"><span class="caption-text">Example of Buffer Swizzling</span></p>
</div>
</div>
<div class="section" id="proposed-use-cases-for-swizzled-addressing">
<h5>Proposed Use Cases for Swizzled Addressing<a class="headerlink" href="#proposed-use-cases-for-swizzled-addressing" title="Permalink to this headline">¶</a></h5>
<p>Here are few proposed uses of swizzled addressing in common graphics
buffers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="11%" />
<col width="11%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">DX11 Raw
Uav OpenCL
Buffer
Object</th>
<th class="head">Dx11
Structured
(literal
offset)</th>
<th class="head">Dx11
Structured
(gpr
offset)</th>
<th class="head">Scratch</th>
<th class="head">Ring /
stream-
out</th>
<th class="head">Const
Buffer</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>inst_vgpr_offset_en</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr class="row-odd"><td>inst_vgpr_index_en</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="row-even"><td>const_stri
de</td>
<td>na</td>
<td>&lt;api&gt;</td>
<td>&lt;api&gt;</td>
<td>scratch
Size</td>
<td>na</td>
<td>na</td>
</tr>
<tr class="row-odd"><td>const_add_tid_enabl
e</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
<tr class="row-even"><td>const_buff
er_swizzle</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr class="row-odd"><td>const_elem
_size</td>
<td>na</td>
<td>4</td>
<td>4</td>
<td>4 or 16</td>
<td>na</td>
<td>4</td>
</tr>
<tr class="row-even"><td>const_inde
x_stride</td>
<td>na</td>
<td>16</td>
<td>16</td>
<td>64</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Table: Swizzled Buffer Use Cases</p>
</div>
</div>
<div class="section" id="bit-memory-operations">
<h4>16-bit Memory Operations<a class="headerlink" href="#bit-memory-operations" title="Permalink to this headline">¶</a></h4>
<p>The D16 buffer instructions allow a kernel to load or store just 16 bits
per work item between VGPRs and memory. There are two variants of these
instructions:</p>
<ul class="simple">
<li>D16 loads data into or stores data from the lower 16 bits of a VGPR.</li>
<li>D16_HI loads data into or stores data from the upper 16 bits of a
VGPR.</li>
</ul>
<p>For example, BUFFER_LOAD_UBYTE_D16 reads a byte per work-item from
memory, converts it to a 16-bit integer, then loads it into the lower 16
bits of the data VGPR.</p>
</div>
<div class="section" id="alignment">
<h4>Alignment<a class="headerlink" href="#alignment" title="Permalink to this headline">¶</a></h4>
<p>For Dword or larger reads or writes, the two LSBs of the byte-address
are ignored, thus forcing Dword alignment.</p>
</div>
<div class="section" id="buffer-resource">
<h4>Buffer Resource<a class="headerlink" href="#buffer-resource" title="Permalink to this headline">¶</a></h4>
<p>The buffer resource describes the location of a buffer in memory and the
format of the data in the buffer. It is specified in four consecutive
SGPRs (four aligned SGPRs) and sent to the texture cache with each
buffer instruction.</p>
<p>The table below details the fields that make up the buffer resource
descriptor.</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="6%" />
<col width="15%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bits</th>
<th class="head">Size</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>47:0</td>
<td>48</td>
<td>Base address</td>
<td>Byte address.</td>
</tr>
<tr class="row-odd"><td>61:48</td>
<td>14</td>
<td>Stride</td>
<td>Bytes 0 to 16383</td>
</tr>
<tr class="row-even"><td>62</td>
<td>1</td>
<td>Cache swizzle</td>
<td>Buffer access. Optionally, swizzle texture cache TC L1 cache banks.</td>
</tr>
<tr class="row-odd"><td>63</td>
<td>1</td>
<td>Swizzle enable</td>
<td>Swizzle AOS according to stride,
index_stride, and element_size, else linear (stride * index offset).</td>
</tr>
<tr class="row-even"><td>95:64</td>
<td>32</td>
<td>Num_records</td>
<td>In units of stride or bytes.</td>
</tr>
<tr class="row-odd"><td>98:96</td>
<td>3</td>
<td>Dst_sel_x</td>
<td><div class="first last line-block">
<div class="line">Destination channel select:</div>
<div class="line">0=0, 1=1, 4=R, 5=G, 6=B, 7=A</div>
</div>
</td>
</tr>
<tr class="row-even"><td>101:99</td>
<td>3</td>
<td>Dst_sel_y</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>104:102</td>
<td>3</td>
<td>Dst_sel_z</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>107:105</td>
<td>3</td>
<td>Dst_sel_w</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>110:108</td>
<td>3</td>
<td>Num format</td>
<td>Numeric data type (float, int, …. ). See instruction encoding for values.</td>
</tr>
<tr class="row-even"><td>114:111</td>
<td>4</td>
<td>Data format</td>
<td>Number of fields and size of each field.
See instruction encoding for values.
For MUBUF instructions with ADD_TID_EN = 1
This field holds Stride [17:14].</td>
</tr>
<tr class="row-odd"><td>115</td>
<td>1</td>
<td>User VM  Enable</td>
<td>Resource is mapped via tiled pool / heap.</td>
</tr>
<tr class="row-even"><td>116</td>
<td>1</td>
<td>User VM mode</td>
<td>Unmapped behavior: 0: null (return 0/drop,write);
1:invalid (results in error)</td>
</tr>
<tr class="row-odd"><td>118:117</td>
<td>2</td>
<td>Index stride</td>
<td>8, 16, 32, or 64. Used for swizzled buffer addressing.</td>
</tr>
<tr class="row-even"><td>119</td>
<td>1</td>
<td>Add tid enable</td>
<td>Add thread ID to the index for to calculate the address.</td>
</tr>
<tr class="row-odd"><td>122:120</td>
<td>3</td>
<td>RSVD</td>
<td>Reserved. Must be set to zero.</td>
</tr>
<tr class="row-even"><td>123</td>
<td>1</td>
<td>NV</td>
<td>Nonvolatile (0=volatile)</td>
</tr>
<tr class="row-odd"><td>125:124</td>
<td>2</td>
<td>RSVD</td>
<td>Reserved. Must be set to zero.</td>
</tr>
<tr class="row-even"><td>127:126</td>
<td>2</td>
<td>Type</td>
<td>Value 0 for buffer. Overlaps upper two bits of
fourbit TYPE field in 128bit T# resource.</td>
</tr>
</tbody>
</table>
<p><strong>Table: Buffer Resource Descriptor</strong></p>
<p>A resource set to all zeros acts as an unbound texture or buffer (return
0,0,0,0).</p>
</div>
<div class="section" id="memory-buffer-load-to-lds">
<h4>Memory Buffer Load to LDS<a class="headerlink" href="#memory-buffer-load-to-lds" title="Permalink to this headline">¶</a></h4>
<p>The MUBUF instruction format allows reading data from a memory buffer
directly into LDS without passing through VGPRs. This is supported for
the following subset of MUBUF instructions.</p>
<ul class="simple">
<li>BUFFER_LOAD_{ubyte, sbyte, ushort, sshort, dword, format_x}.</li>
<li>It is illegal to set the instruction’s TFE bit for loads to LDS.</li>
</ul>
<div class="informalexample"><div class="line-block">
<div class="line">LDS_offset = 16-bit unsigned byte offset from M0[15:0].</div>
<div class="line">Mem_offset = 32-bit unsigned byte offset from an SGPR (the SOFFSET
SGPR).</div>
<div class="line">idx_vgpr = index value from a VGPR (located at VADDR). (Zero if
idxen=0.)</div>
<div class="line">off_vgpr = offset value from a VGPR (located at VADDR or VADDR+1).
(Zero if offen=0.)</div>
</div>
</div><p>The figure below shows the components of the LDS and memory address
calculation:</p>
<p><img alt="fig 8 5" src="../_images/fig_8_5.png" /></p>
<p>TIDinWave is only added if the resource (T#) has the ADD_TID_ENABLE
field set to 1, whereas LDS always adds it. The MEM_ADDR M# is in the
VDATA field; it specifies M0.</p>
<div class="section" id="clamping-rules">
<h5>Clamping Rules<a class="headerlink" href="#clamping-rules" title="Permalink to this headline">¶</a></h5>
<p>Memory address clamping follows the same rules as any other buffer
fetch. LDS address clamping: the return data must not be written outside
the LDS space allocated to this wave.</p>
<ul class="simple">
<li>Set the active-mask to limit buffer reads to those threads that
return data to a legal LDS location.</li>
<li>The LDSbase (alloc) is in units of 32 Dwords, as is LDSsize.</li>
<li>M0[15:0] is in bytes.</li>
</ul>
</div>
</div>
<div class="section" id="glc-bit-explained">
<h4>GLC Bit Explained<a class="headerlink" href="#glc-bit-explained" title="Permalink to this headline">¶</a></h4>
<p>The GLC bit means different things for loads, stores, and atomic ops.</p>
<p><strong>GLC Meaning for Loads</strong></p>
<ul class="simple">
<li>For GLC==0<ul>
<li>The load can read data from the GPU L1.</li>
<li>Typically, all loads (except load-acquire) use GLC==0.</li>
</ul>
</li>
<li>For GLC==1<ul>
<li>The load intentionally misses the GPU L1 and reads from L2. If
there was a line in the GPU L1 that matched, it is invalidated; L2
is reread.</li>
<li>NOTE: L2 is not re-read for every work-item in the same wave-front
for a single load instruction. For example: b=uav[N+tid] // assume
this is a byte read w/ glc==1 and N is aligned to 64B In the above
op, the first Tid of the wavefront brings in the line from L2 or
beyond, and all 63 of the other Tids read from same 64 B cache
line in the L1.</li>
</ul>
</li>
</ul>
<p><strong>GLC Meaning for Stores</strong></p>
<ul class="simple">
<li>For GLC==0 This causes a write-combine across work-items of the
wavefront store op; dirtied lines are written to the L2
automatically.<ul>
<li>If the store operation dirtied all bytes of the 64 B line, it is
left clean and valid in the L1; subsequent accesses to the cache
are allowed to hit on this cache line.</li>
<li>Else do not leave write-combined lines in L1.</li>
</ul>
</li>
<li>For GLC==1 Same as GLC==0, except the write-combined lines are not
left in the line, even if all bytes are dirtied.</li>
</ul>
<p><strong>Atomics</strong></p>
<ul class="simple">
<li>For GLC == 0 No return data (this is “write-only” atomic op).</li>
<li>For GLC == 1 Returns previous value in memory (before the atomic
operation).</li>
</ul>
</div>
</div>
<div class="section" id="vector-memory-vm-image-instructions">
<h3>Vector Memory (VM) Image Instructions<a class="headerlink" href="#vector-memory-vm-image-instructions" title="Permalink to this headline">¶</a></h3>
<p>Vector Memory (VM) operations transfer data between the VGPRs and memory
through the texture cache (TC). Vector means the transfer of one or more
pieces of data uniquely for every work-item in the wavefront. This is in
contrast to scalar memory reads, which transfer only one value that is
shared by all work-items in the wavefront.</p>
<p>Examples of image objects are texture maps and typed surfaces.</p>
<p>Image objects are accessed using from one to four dimensional addresses;
they are composed of homogeneous data of one to four elements. These
image objects are read from, or written to, using IMAGE_* or
SAMPLE_* instructions, all of which use the MIMG instruction format.
IMAGE_LOAD instructions read an element from the image buffer directly
into VGPRS, and SAMPLE instructions use sampler constants (S#) and apply
filtering to the data after it is read. IMAGE_ATOMIC instructions
combine data from VGPRs with data already in memory, and optionally
return the value that was in memory before the operation.</p>
<p>All VM operations use an image resource constant (T#) that is a 256-bit
value in SGPRs. This constant is sent to the texture cache when the
instruction is executed. This constant defines the address, data format,
and characteristics of the surface in memory. Some image instructions
also use a sampler constant that is a 128-bit constant in SGPRs.
Typically, these constants are fetched from memory using scalar memory
reads prior to executing VM instructions, but these constants can also
be generated within the shader.</p>
<p>Texture fetch instructions have a data mask (DMASK) field. DMASK
specifies how many data components it receives. If DMASK is less than
the number of components in the texture, the texture unit only sends
DMASK components, starting with R, then G, B, and A. if DMASK specifies
more than the texture format specifies, the shader receives zero for the
missing components.</p>
<div class="section" id="image-instructions">
<h4>Image Instructions<a class="headerlink" href="#image-instructions" title="Permalink to this headline">¶</a></h4>
<p>This section describes the image instruction set, and the microcode
fields available to those instructions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">MIMG</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SAMPLE_*</td>
<td>Read and filter data from a image
object.</td>
</tr>
<tr class="row-odd"><td>IMAGE_LOAD_&lt;op&gt;</td>
<td>Read data from an image object using
one of the following: image_load,
image_load_mip, image_load_{pck,
pck_sgn, mip_pck, mip_pck_sgn}.</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">IMAGE_STORE</div>
<div class="line">IMAGE_STORE_MIP</div>
</div>
</td>
<td>Store data to an image object. Store
data to a specific mipmap level.</td>
</tr>
<tr class="row-odd"><td>IMAGE_ATOMIC_&lt;op&gt;</td>
<td>Image atomic operation, which is one
of the following: swap, cmpswap,
add, sub, rsub, {u,s}{min,max}, and,
or, xor, inc, dec, fcmpswap, fmin,
fmax.</td>
</tr>
</tbody>
</table>
<p>Table: Image Instructions</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bit Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OP</td>
<td>7</td>
<td>Opcode.</td>
</tr>
<tr class="row-odd"><td>VADDR</td>
<td>8</td>
<td>Address of VGPR to
supply first component
of address.</td>
</tr>
<tr class="row-even"><td>VDATA</td>
<td>8</td>
<td>Address of VGPR to
supply first component
of write data or receive
first component of
read-data.</td>
</tr>
<tr class="row-odd"><td>SSAMP</td>
<td>5</td>
<td>SGPR to supply S#
(sampler constant) in
four consecutive SGPRs.
Missing two LSBs of
SGPR-address since must
be aligned to a multiple
of four SGPRs.</td>
</tr>
<tr class="row-even"><td>SRSRC</td>
<td>5</td>
<td>SGPR to supply T#
(resource constant) in
four or eight
consecutive SGPRs.
Missing two LSBs of
SGPR-address since must
be aligned to a multiple
of four SGPRs.</td>
</tr>
<tr class="row-odd"><td>UNRM</td>
<td>1</td>
<td>Force address to be
un-normalized regardless
of T#. Must be set to 1
for image stores and
atomics.</td>
</tr>
<tr class="row-even"><td>DA</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">Shader declared an
array resource to be
used with this fetch.</div>
<div class="line">When 1, the shader
provides an
array-index with the
instruction.</div>
<div class="line">When 0, no array index
is provided.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>DMASK</td>
<td>4</td>
<td><div class="first last line-block">
<div class="line">Data VGPR enable mask:
one to four
consecutive VGPRs.
Reads: defines which
components are
returned.</div>
<div class="line">0 = red, 1 = green, 2
= blue, 3 = alpha</div>
<div class="line">Writes: defines which
components are written
with data from VGPRs
(missing components
get 0). Enabled
components come from
consecutive VGPRs.</div>
<div class="line">For example:
DMASK=1001: Red is in
VGPRn and alpha in
VGPRn+1. For D16
writes, DMASK is used
only as a word count:
each bit represents 16
bits of data to be
written, starting at
the LSBs of VADDR, the
MSBs, VADDR+1, etc.
Bit position is
ignored.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>GLC</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">Globally Coherent.
Controls how reads and
writes are handled by
the L1 texture cache.</div>
<div class="line"><strong>READ:</strong></div>
<div class="line">GLC = 0 Reads can hit
on the L1 and persist
across waves.</div>
<div class="line">GLC = 1 Reads always
miss the L1 and force
fetch to L2. No L1
persistence across
waves.</div>
<div class="line"><strong>WRITE:</strong></div>
<div class="line">GLC = 0 Writes miss
the L1, write through
to L2, and persist in
L1 across wavefronts.</div>
<div class="line">GLC = 1 Writes miss
the L1, write through
to L2. No persistence
across wavefronts.</div>
<div class="line"><strong>ATOMIC:</strong></div>
<div class="line">GLC = 0 Previous data
value is not returned.
No L1 persistence
across wavefronts.</div>
<div class="line">GLC = 1 Previous data
value is returned. No
L1 persistence across
wavefronts.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>SLC</td>
<td>1</td>
<td>System Level Coherent.
When set, accesses are
forced to miss in level
2 texture cache and are
coherent with system
memory.</td>
</tr>
<tr class="row-even"><td>TFE</td>
<td>1</td>
<td>Texel Fail Enable for
PRT (partially resident
textures). When set, a
fetch can return a NACK,
which causes a VGPR
write into DST+1 (first
GPR after all fetch-dest
GPRs).</td>
</tr>
<tr class="row-odd"><td>LWE</td>
<td>1</td>
<td>Force data to be
un-normalized,
regardless of T#.</td>
</tr>
<tr class="row-even"><td>A16</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">Address components are
16-bits (instead of
the usual 32 bits).
When set, all address
components are 16 bits
(packed into two per
Dword), except:</div>
<div class="line">Texel offsets (three
6-bit uint packed into
one Dword).</div>
<div class="line">PCF reference (for _C
instructions).</div>
<div class="line">Address components are
16-bit uint for image
ops without sampler;
16-bit float with
sampler.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>D16</td>
<td>1</td>
<td><div class="first last line-block">
<div class="line">VGPR-Data-16bit. On
loads, convert data in
memory to 16-bit
format before storing
it in VGPRs. For
stores, convert 16-bit
data in VGPRs to 32
bits before going to
memory. Whether the
data is treated as
float or int is
decided by NFMT.
Allowed only with
these opcodes:</div>
<div class="line">IMAGE_SAMPLE*</div>
<div class="line">IMAGE_GATHER4*, but
not GATHER4H_PCK</div>
<div class="line">IMAGE_LOAD</div>
<div class="line">IMAGE_LOAD_MIP</div>
<div class="line">IMAGE_STORE</div>
<div class="line">IMAGE_STORE_MIP</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table: Instruction Fields</p>
</div>
</div>
<div class="section" id="image-opcodes-with-no-sampler">
<h3>Image Opcodes with No Sampler<a class="headerlink" href="#image-opcodes-with-no-sampler" title="Permalink to this headline">¶</a></h3>
<p>For image opcodes with no sampler, all VGPR address values are taken as
uint. For cubemaps, face_id = slice * 6 + face.</p>
<p>The table below shows the contents of address VGPRs for the various
image opcodes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="9%" />
<col width="15%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Image Opcode
(Resource w/o
Sampler)</th>
<th class="head">Acnt</th>
<th class="head">dim</th>
<th class="head">VGPRn</th>
<th class="head">VGPRn+1</th>
<th class="head">VGPRn+2</th>
<th class="head">VGPRn+3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>get_resinfo</td>
<td>0</td>
<td>Any</td>
<td>mipid</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>load / store /
atomics</td>
<td>0</td>
<td>1D</td>
<td>x</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>1</td>
<td>1D
Array</td>
<td>x</td>
<td>slice</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>2D</td>
<td>x</td>
<td>y</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>2</td>
<td>2D
MSAA</td>
<td>x</td>
<td>y</td>
<td>fragid</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>2D
Array
MSAA</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>fragid</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>3D</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>load_mip /
store_mip</td>
<td>1</td>
<td>1D</td>
<td>x</td>
<td>mipid</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>2</td>
<td>1D
Array</td>
<td>x</td>
<td>slice</td>
<td>mipid</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>2D</td>
<td>x</td>
<td>y</td>
<td>mipid</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>mipid</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>3D</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>mipid</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>mipid</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Table: Image Opcodes with No Sampler</p>
</div>
<div class="section" id="image-opcodes-with-a-sampler">
<h3>Image Opcodes with a Sampler<a class="headerlink" href="#image-opcodes-with-a-sampler" title="Permalink to this headline">¶</a></h3>
<p>For image opcodes with a sampler, all VGPR address values are taken as
float. For cubemaps, face_id = slice * 8 + face.</p>
<p>Certain sample and gather opcodes require additional values from VGPRs
beyond what is shown. These values are: offset, bias, z-compare, and
gradients.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="9%" />
<col width="15%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Image Opcode
(w/ Sampler)</th>
<th class="head">Acnt</th>
<th class="head">dim</th>
<th class="head">VGPRn</th>
<th class="head">VGPRn+1</th>
<th class="head">VGPRn+2</th>
<th class="head">VGPRn+3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>sample</td>
<td>0</td>
<td>1D</td>
<td>x</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1D
Array</td>
<td>x</td>
<td>slice</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>1</td>
<td>2D</td>
<td>x</td>
<td>y</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>2D
interl
aced</td>
<td>x</td>
<td>y</td>
<td>field</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>2</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>3D</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>sample_l</td>
<td>1</td>
<td>1D</td>
<td>x</td>
<td>lod</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>2</td>
<td>1D
Array</td>
<td>x</td>
<td>slice</td>
<td>lod</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>2D</td>
<td>x</td>
<td>y</td>
<td>lod</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>2D
interl
aced</td>
<td>x</td>
<td>y</td>
<td>field</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>3D</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>sample_cl</td>
<td>1</td>
<td>1D</td>
<td>x</td>
<td>clamp</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><p class="first">2</p>
<p class="last">2</p>
</td>
<td>1D
Array
2D</td>
<td><p class="first">x</p>
<p class="last">x</p>
</td>
<td><p class="first">slice</p>
<p class="last">y</p>
</td>
<td><p class="first">clamp</p>
<p class="last">clamp</p>
</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>2D
interl
aced</td>
<td>x</td>
<td>y</td>
<td>field</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>3D</td>
<td>x</td>
<td>y</td>
<td>z</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>gather4</td>
<td>1</td>
<td>2D</td>
<td>x</td>
<td>y</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>2D
interl
aced</td>
<td>x</td>
<td>y</td>
<td>field</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>2</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>gather4_l</td>
<td>2</td>
<td>2D</td>
<td>x</td>
<td>y</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>2D
interl
aced</td>
<td>x</td>
<td>y</td>
<td>field</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>lod</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>gather4_cl</td>
<td>2</td>
<td>2D</td>
<td>x</td>
<td>y</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>2D
interl
aced</td>
<td>x</td>
<td>y</td>
<td>field</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>3</td>
<td>2D
Array</td>
<td>x</td>
<td>y</td>
<td>slice</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Cube</td>
<td>x</td>
<td>y</td>
<td>face_id</td>
<td>clamp</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Table: Image Opcodes with Sampler</p>
<ol class="arabic simple">
<li>Sample includes sample, sample_d, sample_b, sample_lz, sample_c,
sample_c_d, sample_c_b, sample_c_lz, and getlod.</li>
<li>Sample_l includes sample_l and sample_c_l.</li>
<li>Sample_cl includes sample_cl, sample_d_cl, sample_b_cl,
sample_c_cl, sample_c_d_cl, and sample_c_b_cl.</li>
<li>Gather4 includes gather4, gather4_lz, gather4_c, and
gather4_c_lz.</li>
</ol>
<p>The table below lists and briefly describes the legal suffixes for image
instructions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Suffix</th>
<th class="head">Meaning</th>
<th class="head">Extra Addresses</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>_L</td>
<td>LOD</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>LOD is used
instead of TA
computed LOD.</td>
</tr>
<tr class="row-odd"><td>_B</td>
<td>LOD BIAS</td>
<td>1: lod bias</td>
<td>Add this BIAS to
the LOD TA
computes.</td>
</tr>
<tr class="row-even"><td>_CL</td>
<td>LOD CLAMP</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Clamp the LOD to
be no larger than
this value.</td>
</tr>
<tr class="row-odd"><td>_D</td>
<td>Derivative</td>
<td>2,4 or 6: slopes</td>
<td>Send dx/dv, dx/dy,
etc. slopes to TA
for it to used in
LOD computation.</td>
</tr>
<tr class="row-even"><td>_CD</td>
<td>Coarse Derivative</td>
<td>Send dx/dv, dx/dy,
etc. slopes to TA
for it to used in
LOD computation.</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>_LZ</td>
<td>Level 0</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Force use of MIP
level 0.</td>
</tr>
<tr class="row-even"><td>_C</td>
<td>PCF</td>
<td>1: z-comp</td>
<td>Percentage closer
filtering.</td>
</tr>
<tr class="row-odd"><td>_O</td>
<td>Offset</td>
<td>1: offsets</td>
<td>Send X, Y, Z
integer offsets
(packed into 1
Dword) to offset
XYZ address.</td>
</tr>
</tbody>
</table>
<p>Table: Sample Instruction Suffix Key</p>
<div class="section" id="id4">
<h4>VGPR Usage<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>Address: The address consists of up to four parts:</p>
<div class="informalexample"><p>{ offset } { bias } { z-compare } { derivative } { body }</p>
</div><p>These are all packed into consecutive VGPRs.</p>
<ul>
<li><div class="first line-block">
<div class="line">Offset: SAMPLE*<em>O</em>*, GATHER*<em>O</em>*</div>
<div class="line">One Dword of offset_xyz. The offsets are six-bit signed integers:
X=[5:0], Y=[13:8], and Z=[21:16].</div>
</div>
</li>
<li><p class="first">Bias: SAMPLE*<em>B</em>*, GATHER*<em>B</em>*. One Dword float.</p>
</li>
<li><p class="first">Z-compare: SAMPLE*<em>C</em>*, GATHER*<em>C</em>*. One Dword.</p>
</li>
<li><p class="first">Derivatives (sample_d, sample_cd): 2, 4, or 6 Dwords, packed one
Dword per derivative as:</p>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Image Dim</th>
<th class="head">Vgpr N</th>
<th class="head">N+1</th>
<th class="head">N+2</th>
<th class="head">N+3</th>
<th class="head">N+4</th>
<th class="head">N+5</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1D</td>
<td>DX/DH</td>
<td>DX/DV</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>2D</td>
<td>DX/DH</td>
<td>DY/DH</td>
<td>DX/DV</td>
<td>DY/DV</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td>3D</td>
<td>DX/DH</td>
<td>DY/DH</td>
<td>DZ/DH</td>
<td>DX/DV</td>
<td>DY/DV</td>
<td>DZ/DV</td>
</tr>
</tbody>
</table>
<ul>
<li><p class="first">Body: One to four Dwords, as defined by the table:
Address components are X,Y,Z,W
with X in VGPR_M, Y in VGPR_M+1, etc. The number of components in
“body” is the value of the ACNT field in the table, plus one.</p>
</li>
<li><p class="first">Data: Written from, or returned to, one to four consecutive VGPRs.
The amount of data read or written is determined by the DMASK field
of the instruction.</p>
</li>
<li><p class="first">Reads: DMASK specifies which elements of the resource are returned to
consecutive VGPRs. The texture system reads data from memory and
based on the data format expands it to a canonical RGBA form, filling
in zero or one for missing components. Then, DMASK is applied, and
only those components selected are returned to the shader.</p>
</li>
<li><p class="first">Writes: When writing an image object, it is only possible to write an
entire element (all components), not just individual components. The
components come from consecutive VGPRs, and the texture system fills
in the value zero for any missing components of the image’s data
format; it ignores any values that are not part of the stored data
format. For example, if the DMASK=1001, the shader sends Red from
VGPR_N, and Alpha from VGPR_N+1, to the texture unit. If the image
object is RGB, the texel is overwritten with Red from the VGPR_N,
Green and Blue set to zero, and Alpha from the shader ignored.</p>
</li>
<li><div class="first line-block">
<div class="line">Atomics: Image atomic operations are supported only on 32- and
64-bit-per pixel surfaces. The surface data format is specified in
the resource constant. Atomic operations treat the element as a
single component of 32- or 64-bits. For atomic operations, DMASK is
set to the number of VGPRs (Dwords) to send to the texture unit.
DMASK legal values for atomic image operations: no other values of
DMASK are legal.</div>
<div class="line">0x1 = 32-bit atomics except cmpswap.</div>
<div class="line">0x3 = 32-bit atomic cmpswap.</div>
<div class="line">0x3 = 64-bit atomics except cmpswap.</div>
<div class="line">0xf = 64-bit atomic cmpswap.</div>
</div>
</li>
<li><p class="first">Atomics with Return: Data is read out of the VGPR(s), starting at
VDATA, to supply to the atomic operation. If the atomic returns a
value to VGPRs, that data is returned to those same VGPRs starting at
VDATA.</p>
</li>
<li><p class="first">D16 Instructions: Load-format and store-format instructions also come
in a “d16” variant. For stores, each 32-bit VGPR holds two 16-bit
data elements that are passed to the texture unit. The texture unit
converts them to the texture format before writing to memory. For
loads, data returned from the texture unit is converted to 16 bits,
and a pair of data are stored in each 32- bit VGPR (LSBs first, then
MSBs). The DMASK bit represents individual 16- bit elements; so, when
DMASK=0011 for an image-load, two 16-bit components are loaded into a
single 32-bit VGPR.</p>
</li>
</ul>
</div>
<div class="section" id="image-resource">
<h4>Image Resource<a class="headerlink" href="#image-resource" title="Permalink to this headline">¶</a></h4>
<p>The image resource (also referred to as T#) defines the location of the
image buffer in memory, its dimensions, tiling, and data format. These
resources are stored in four or eight consecutive SGPRs and are read by
MIMG instructions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="10%" />
<col width="19%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bits</th>
<th class="head">Size</th>
<th class="head">Name</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>128-bi
t
Resource
:
1D-tex,
2d-tex,
2d-msaa
(multi-s
ample
auto-ali
asing)</strong></td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>39:0</td>
<td>40</td>
<td>base address</td>
<td>256-byte aligned. Also used for fmask-ptr.</td>
</tr>
<tr class="row-even"><td>51:40</td>
<td>12</td>
<td>min lod</td>
<td>4.8 (four uint bits, eight fraction bits)
format.</td>
</tr>
<tr class="row-odd"><td>57:52</td>
<td>6</td>
<td>data format</td>
<td>Number of comps, number of bits/comp.</td>
</tr>
<tr class="row-even"><td>61:58</td>
<td>4</td>
<td>num format</td>
<td>Numeric format.</td>
</tr>
<tr class="row-odd"><td>62</td>
<td>1</td>
<td>NV</td>
<td>Non-volatile (0=volatile)</td>
</tr>
<tr class="row-even"><td>77:64</td>
<td>14</td>
<td>width</td>
<td>width-1 of mip0 in texels</td>
</tr>
<tr class="row-odd"><td>91:78</td>
<td>14</td>
<td>height</td>
<td>height-1 of mip0 in texels</td>
</tr>
<tr class="row-even"><td>94:92</td>
<td>3</td>
<td>perf
modulation</td>
<td>Scales sampler’s perf_z, perf_mip,
aniso_bias, lod_bias_sec.</td>
</tr>
<tr class="row-odd"><td>98:96</td>
<td>3</td>
<td>dst_sel_x</td>
<td>0 = 0, 1 = 1, 4 = R, 5 = G, 6 = B, 7 = A.</td>
</tr>
<tr class="row-even"><td>101:99</td>
<td>3</td>
<td>dst_sel_y</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>104:102</td>
<td>3</td>
<td>dst_sel_z</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>107:105</td>
<td>3</td>
<td>dst_sel_w</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>111:108</td>
<td>4</td>
<td>base level</td>
<td>largest mip level in the resource view. For
msaa, set to zero.</td>
</tr>
<tr class="row-even"><td>115:112</td>
<td>4</td>
<td>last level</td>
<td>For msaa, holds number of samples</td>
</tr>
<tr class="row-odd"><td>120:116</td>
<td>5</td>
<td>Tiling index</td>
<td><div class="first last line-block">
<div class="line">Lookuptable: 32 x 16</div>
<div class="line">bank_width[2], bank_height[2],
num_banks[2], tile_split[2],
macro_tile_aspect[2],
micro_tile_mode[2], array_mode[4].</div>
</div>
</td>
</tr>
<tr class="row-even"><td>127:124</td>
<td>4</td>
<td>type</td>
<td>0 = buf, 8 = 1d, 9 = 2d, 10 = 3d, 11 =
cube, 12 = 1d-array, 13 = 2d-array, 14 =
2d-msaa, 15 = 2d-msaa-array. 1-7 are
reserved.</td>
</tr>
<tr class="row-odd"><td><strong>256-bi
t
Resource
:
1d-array
,
2d-array
,
3d,
cubemap,
MSAA</strong></td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>140:128</td>
<td>13</td>
<td>depth</td>
<td>depth-1 of mip0 for 3d map</td>
</tr>
<tr class="row-odd"><td>156:141</td>
<td>16</td>
<td>pitch</td>
<td>In texel units.</td>
</tr>
<tr class="row-even"><td>159:157</td>
<td>3</td>
<td>border color
swizzle</td>
<td>Specifies the channel ordering for border
color independent of the T# dst_sel
fields. 0=xyzw, 1=xwyz, 2=wqyx, 3=wxyz,
4=zyxw, 5=yxwz</td>
</tr>
<tr class="row-odd"><td>176:173</td>
<td>4</td>
<td>Array Pitch</td>
<td>array pitch for quilts, encoded as:
trunc(log2(array_pitch))+1</td>
</tr>
<tr class="row-even"><td>184:177</td>
<td>8</td>
<td>meta data
address</td>
<td>bits[47:40]</td>
</tr>
<tr class="row-odd"><td>185</td>
<td>1</td>
<td>meta_linear</td>
<td>forces metadata surface to be linear</td>
</tr>
<tr class="row-even"><td>186</td>
<td>1</td>
<td>meta_pipe_a
ligned</td>
<td>maintain pipe alignment in metadata
addressing</td>
</tr>
<tr class="row-odd"><td>187</td>
<td>1</td>
<td>meta_rb_ali
gned</td>
<td>maintain RB alignment in metadata
addressing</td>
</tr>
<tr class="row-even"><td>191:188</td>
<td>4</td>
<td>Max Mip</td>
<td>Resource mipLevel-1. Describes the
resource, as opposed to base_level and
last_level, which describes the resouce
view. For MSAA, holds log2(number of
samples).</td>
</tr>
<tr class="row-odd"><td>203:192</td>
<td>12</td>
<td>min LOD warn</td>
<td>Feedback trigger for LOD, in U4.8 format.</td>
</tr>
<tr class="row-even"><td>211:204</td>
<td>8</td>
<td>counter bank
ID</td>
<td>PRT counter ID</td>
</tr>
<tr class="row-odd"><td>212</td>
<td>1</td>
<td>LOD hardware
count enable</td>
<td>PRT hardware counter enable</td>
</tr>
<tr class="row-even"><td>213</td>
<td>1</td>
<td>Compression
Enable</td>
<td>enable delta color compression</td>
</tr>
<tr class="row-odd"><td>214</td>
<td>1</td>
<td>Alpha is on
MSB</td>
<td>Set to 1 if the surface’s component swap is
not reversed (DCC)</td>
</tr>
<tr class="row-even"><td>215</td>
<td>1</td>
<td>Color
Transform</td>
<td>Auto=0, none=1 (DCC)</td>
</tr>
<tr class="row-odd"><td>255:216</td>
<td>40</td>
<td>Meta Data
Address</td>
<td>Upper bits of meta-data address (DCC)
[47:8]</td>
</tr>
</tbody>
</table>
<p>Table: Image Resource Definition</p>
<p>All image resource view descriptors (T#’s) are written by the driver as
256 bits.</p>
<p>The MIMG-format instructions have a DeclareArray (DA) bit that reflects
whether the shader was expecting an array-texture or simple texture to
be bound. When DA is zero, the hardware does not send an array index to
the texture cache. If the texture map was indexed, the hardware supplies
an index value of zero. Indices sent for non-indexed texture maps are
ignored.</p>
</div>
<div class="section" id="image-sampler">
<h4>Image Sampler<a class="headerlink" href="#image-sampler" title="Permalink to this headline">¶</a></h4>
<p>The sampler resource (also referred to as S#) defines what operations to
perform on texture map data read by <strong>sample</strong> instructions. These are
primarily address clamping and filter options. Sampler resources are
defined in four consecutive SGPRs and are supplied to the texture cache
with every sample instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Bits</th>
<th class="head">Size</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>2:0</td>
<td>3</td>
<td>clamp x</td>
<td>Clamp/wrap mode.</td>
</tr>
<tr class="row-odd"><td>5:3</td>
<td>3</td>
<td>clamp y</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>8:6</td>
<td>3</td>
<td>clamp z</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>11:9</td>
<td>3</td>
<td>max aniso ratio</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>14:12</td>
<td>3</td>
<td>depth compare func</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>1</td>
<td>force unnormalized</td>
<td>Force address
cords to be unorm.</td>
</tr>
<tr class="row-even"><td>18:16</td>
<td>3</td>
<td>aniso threshold</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>1</td>
<td>mc coord trunc</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>20</td>
<td>1</td>
<td>force degamma</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>26:21</td>
<td>6</td>
<td>aniso bias</td>
<td>u1.5.</td>
</tr>
<tr class="row-even"><td>27</td>
<td>1</td>
<td>trunc coord</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>28</td>
<td>1</td>
<td>disable cube wrap</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>30:29</td>
<td>2</td>
<td>filter_mode</td>
<td>Normal lerp, min,
or max filter.</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>1</td>
<td>compat_mode</td>
<td>1 = new mode; 0 =
legacy</td>
</tr>
<tr class="row-even"><td>43:32</td>
<td>12</td>
<td>min lod</td>
<td>u4.8.</td>
</tr>
<tr class="row-odd"><td>55:44</td>
<td>12</td>
<td>max lod</td>
<td>u4.8.</td>
</tr>
<tr class="row-even"><td>59:56</td>
<td>4</td>
<td>perf_mip</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>63:60</td>
<td>4</td>
<td>perf z</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>77:64</td>
<td>14</td>
<td>lod bias</td>
<td>s5.8.</td>
</tr>
<tr class="row-odd"><td>83:78</td>
<td>6</td>
<td>lod bias sec</td>
<td>s1.4.</td>
</tr>
<tr class="row-even"><td>85:84</td>
<td>2</td>
<td>xy mag filter</td>
<td>Magnification
filter.</td>
</tr>
<tr class="row-odd"><td>87:86</td>
<td>2</td>
<td>xy min filter</td>
<td>Minification
filter.</td>
</tr>
<tr class="row-even"><td>89:88</td>
<td>2</td>
<td>z filter</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>91:90</td>
<td>2</td>
<td>mip filter</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>92</td>
<td>1</td>
<td>mip_point_precla
mp</td>
<td>When mipfilter =
point, add 0.5
before clamping.</td>
</tr>
<tr class="row-odd"><td>93</td>
<td>1</td>
<td>disable_lsb_ceil</td>
<td>Disable ceiling
logic in filter
(rounds up).</td>
</tr>
<tr class="row-even"><td>94</td>
<td>1</td>
<td>Filter_Prec_Fix</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>95</td>
<td>1</td>
<td>Aniso_override</td>
<td>Disable Aniso
filtering if
base_level =
last_level</td>
</tr>
<tr class="row-even"><td>107:96</td>
<td>12</td>
<td>border color ptr</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>125:108</td>
<td>18</td>
<td>unused</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>127:126</td>
<td>2</td>
<td>border color type</td>
<td>Opaque-black,
transparent-black,
white, use border
color ptr.</td>
</tr>
</tbody>
</table>
<p>Table: Image Sampler Definition</p>
</div>
<div class="section" id="data-formats">
<h4>Data Formats<a class="headerlink" href="#data-formats" title="Permalink to this headline">¶</a></h4>
<p>Data formats 0-15 are available to buffer resources, and all formats are
available to image formats. The table below details all the data formats
that can be used by image and buffer resources.</p>
<p><img alt="gfx9 valid texture formats" src="../_images/gfx9_valid_texture_formats.png" /></p>
</div>
<div class="section" id="vector-memory-instruction-data-dependencies">
<h4>Vector Memory Instruction Data Dependencies<a class="headerlink" href="#vector-memory-instruction-data-dependencies" title="Permalink to this headline">¶</a></h4>
<p>When a VM instruction is issued, the address is immediately read out of
VGPRs and sent to the texture cache. Any texture or buffer resources and
samplers are also sent immediately. However, write-data is not
immediately sent to the texture cache.</p>
<p>The shader developer’s responsibility to avoid data hazards associated
with VMEM instructions include waiting for VMEM read instruction
completion before reading data fetched from the TC (VMCNT).</p>
<p>This is explained in the section:</p>
<p><a class="reference internal" href="#vector-memory-operations"><span class="std std-ref">Vector Memory Operations</span></a></p>
</div>
</div>
</div>
<div class="section" id="flat-memory-instructions">
<h2>Flat Memory Instructions<a class="headerlink" href="#flat-memory-instructions" title="Permalink to this headline">¶</a></h2>
<p>Flat Memory instructions read, or write, one piece of data into, or out
of, VGPRs; they do this separately for each work-item in a wavefront.
Unlike buffer or image instructions, Flat instructions do not use a
resource constant to define the base address of a surface. Instead, Flat
instructions use a single flat address from the VGPR; this addresses
memory as a single flat memory space. This memory space includes video
memory, system memory, LDS memory, and scratch (private) memory. It does
not include GDS memory. Parts of the flat memory space may not map to
any real memory, and accessing these regions generates a
memory-violation error. The determination of the memory space to which
an address maps is controlled by a set of “memory aperture” base and
size registers.</p>
<div class="section" id="flat-memory-instruction">
<h3>Flat Memory Instruction<a class="headerlink" href="#flat-memory-instruction" title="Permalink to this headline">¶</a></h3>
<p>Flat memory instructions let the kernel read or write data in memory, or
perform atomic operations on data already in memory. These operations
occur through the texture L2 cache. The instruction declares which VGPR
holds the address (either 32- or 64-bit, depending on the memory
configuration), the VGPR which sends and the VGPR which receives data.
Flat instructions also use M0 as described in the table below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Bit Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OP</td>
<td>7</td>
<td>Opcode. Can be Flat,
Scratch or Global
instruction. See next
table.</td>
</tr>
<tr class="row-odd"><td>ADDR</td>
<td>8</td>
<td>VGPR which holds the
address. For 64-bit
addresses, ADDR has the
LSBs, and ADDR+1 has the
MSBs.</td>
</tr>
<tr class="row-even"><td>DATA</td>
<td>8</td>
<td>VGPR which holds the
first Dword of data.
Instructions can use 0-4
Dwords.</td>
</tr>
<tr class="row-odd"><td>VDST</td>
<td>8</td>
<td>VGPR destination for
data returned to the
kernel, either from
LOADs or Atomics with
GLC=1 (return pre-op
value).</td>
</tr>
<tr class="row-even"><td>SLC</td>
<td>1</td>
<td>System Level Coherent.
Used in conjunction with
GLC to determine cache
policies.</td>
</tr>
<tr class="row-odd"><td>GLC</td>
<td>1</td>
<td>Global Level Coherent.
For Atomics, GLC: 1
means return pre-op
value, 0 means do not
return pre-op value.</td>
</tr>
<tr class="row-even"><td>SEG</td>
<td>2</td>
<td>Memory Segment: 0=FLAT,
1=SCRATCH, 2=GLOBAL,
3=reserved.</td>
</tr>
<tr class="row-odd"><td>LDS</td>
<td>1</td>
<td>When set, data is moved
between LDS and memory
instead of VGPRs and
memory. For Global and
Scratch only; must be
zero for Flat.</td>
</tr>
<tr class="row-even"><td>NV</td>
<td>1</td>
<td>Non-volatile. When set,
the read/write is
operating on
non-volatile memory.</td>
</tr>
<tr class="row-odd"><td>OFFSET</td>
<td>13</td>
<td><div class="first last line-block">
<div class="line">Address offset.</div>
<div class="line">Scratch, Global:
13-bit signed byte
offset.</div>
<div class="line">Flat: 12-bit unsigned
offset (MSB is
ignored).</div>
</div>
</td>
</tr>
<tr class="row-even"><td>SADDR</td>
<td>7</td>
<td><div class="first last line-block">
<div class="line">Scalar SGPR that
provides an offset
address. To disable,
set this field to
0x7F. Meaning of this
field is different for
Scratch and Global:</div>
<div class="line">Flat: Unused.</div>
<div class="line">Scratch: Use an SGPR
(instead of VGPR) for
the address.</div>
<div class="line">Global: Use the SGPR
to provide a base
address; the VGPR
provides a 32-bit
offset.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>M0</td>
<td>16</td>
<td>Implied use of M0 for
SCRATCH and GLOBAL only
when LDS=1. Provides the
LDS address-offset.</td>
</tr>
</tbody>
</table>
<p>Table: Flat, Global and Scratch Microcode Formats</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Flat Opcodes</th>
<th class="head">Global Opcodes</th>
<th class="head">Scratch Opcodes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FLAT</td>
<td>GLOBAL</td>
<td>SCRATCH</td>
</tr>
<tr class="row-odd"><td>FLAT_LOAD_UBYTE</td>
<td>GLOBAL_LOAD_UBYTE</td>
<td>SCRATCH_LOAD_UBYTE</td>
</tr>
<tr class="row-even"><td>FLAT_LOAD_UBYTE_D16</td>
<td>GLOBAL_LOAD_UBYTE_D1
6</td>
<td>SCRATCH_LOAD_UBYTE_D1
6</td>
</tr>
<tr class="row-odd"><td>FLAT_LOAD_UBYTE_D16_HI</td>
<td>GLOBAL_LOAD_UBYTE_D1
6_HI</td>
<td>SCRATCH_LOAD_UBYTE_D1
6_HI</td>
</tr>
<tr class="row-even"><td>FLAT_LOAD_SBYTE</td>
<td>GLOBAL_LOAD_SBYTE</td>
<td>SCRATCH_LOAD_SBYTE</td>
</tr>
<tr class="row-odd"><td>FLAT_LOAD_SBYTE_D16</td>
<td>GLOBAL_LOAD_SBYTE_D1
6</td>
<td>SCRATCH_LOAD_SBYTE_D1
6</td>
</tr>
<tr class="row-even"><td>FLAT_LOAD_SBYTE_D16_HI</td>
<td>GLOBAL_LOAD_SBYTE_D1
6_HI</td>
<td>SCRATCH_LOAD_SBYTE_D1
6_HI</td>
</tr>
<tr class="row-odd"><td>FLAT_LOAD_USHORT</td>
<td>GLOBAL_LOAD_USHORT</td>
<td>SCRATCH_LOAD_USHORT</td>
</tr>
<tr class="row-even"><td>FLAT_LOAD_SSHORT</td>
<td>GLOBAL_LOAD_SSHORT</td>
<td>SCRATCH_LOAD_SSHORT</td>
</tr>
<tr class="row-odd"><td>FLAT_LOAD_SHORT_D16</td>
<td>GLOBAL_LOAD_SHORT_D1
6</td>
<td>SCRATCH_LOAD_SHORT_D1
6</td>
</tr>
<tr class="row-even"><td>FLAT_LOAD_SHORT_D16_HI</td>
<td>GLOBAL_LOAD_SHORT_D1
6_HI</td>
<td>SCRATCH_LOAD_SHORT_D1
6_HI</td>
</tr>
<tr class="row-odd"><td>FLAT_LOAD_DWORD</td>
<td>GLOBAL_LOAD_DWORD</td>
<td>SCRATCH_LOAD_DWORD</td>
</tr>
<tr class="row-even"><td>FLAT_LOAD_DWORDX2</td>
<td>GLOBAL_LOAD_DWORDX2</td>
<td>SCRATCH_LOAD_DWORDX2</td>
</tr>
<tr class="row-odd"><td>FLAT_LOAD_DWORDX3</td>
<td>GLOBAL_LOAD_DWORDX3</td>
<td>SCRATCH_LOAD_DWORDX3</td>
</tr>
<tr class="row-even"><td>FLAT_LOAD_DWORDX4</td>
<td>GLOBAL_LOAD_DWORDX4</td>
<td>SCRATCH_LOAD_DWORDX4</td>
</tr>
<tr class="row-odd"><td>FLAT_STORE_BYTE</td>
<td>GLOBAL_STORE_BYTE</td>
<td>SCRATCH_STORE_BYTE</td>
</tr>
<tr class="row-even"><td>FLAT_STORE_BYTE_D16_HI</td>
<td>GLOBAL_STORE_BYTE_D1
6_HI</td>
<td>SCRATCH_STORE_BYTE_D1
6_HI</td>
</tr>
<tr class="row-odd"><td>FLAT_STORE_SHORT</td>
<td>GLOBAL_STORE_SHORT</td>
<td>SCRATCH_STORE_SHORT</td>
</tr>
<tr class="row-even"><td>FLAT_STORE_SHORT_D16
_HI</td>
<td>GLOBAL_STORE_SHORT_D
16_HI</td>
<td>SCRATCH_STORE_SHORT_D
16_HI</td>
</tr>
<tr class="row-odd"><td>FLAT_STORE_DWORD</td>
<td>GLOBAL_STORE_DWORD</td>
<td>SCRATCH_STORE_DWORD</td>
</tr>
<tr class="row-even"><td>FLAT_STORE_DWORDX2</td>
<td>GLOBAL_STORE_DWORDX2</td>
<td>SCRATCH_STORE_DWORDX2</td>
</tr>
<tr class="row-odd"><td>FLAT_STORE_DWORDX3</td>
<td>GLOBAL_STORE_DWORDX3</td>
<td>SCRATCH_STORE_DWORDX3</td>
</tr>
<tr class="row-even"><td>FLAT_STORE_DWORDX4</td>
<td>GLOBAL_STORE_DWORDX4</td>
<td>SCRATCH_STORE_DWORDX4</td>
</tr>
<tr class="row-odd"><td>FLAT_ATOMIC_SWAP</td>
<td>GLOBAL_ATOMIC_SWAP</td>
<td>none</td>
</tr>
<tr class="row-even"><td>FLAT_ATOMIC_CMPSWAP</td>
<td>GLOBAL_ATOMIC_CMPSWAP</td>
<td>none</td>
</tr>
<tr class="row-odd"><td>FLAT_ATOMIC_ADD</td>
<td>GLOBAL_ATOMIC_ADD</td>
<td>none</td>
</tr>
<tr class="row-even"><td>FLAT_ATOMIC_SUB</td>
<td>GLOBAL_ATOMIC_SUB</td>
<td>none</td>
</tr>
<tr class="row-odd"><td>FLAT_ATOMIC_SMIN</td>
<td>GLOBAL_ATOMIC_SMIN</td>
<td>none</td>
</tr>
<tr class="row-even"><td>FLAT_ATOMIC_UMIN</td>
<td>GLOBAL_ATOMIC_UMIN</td>
<td>none</td>
</tr>
<tr class="row-odd"><td>FLAT_ATOMIC_SMAX</td>
<td>GLOBAL_ATOMIC_SMAX</td>
<td>none</td>
</tr>
<tr class="row-even"><td>FLAT_ATOMIC_UMAX</td>
<td>GLOBAL_ATOMIC_UMAX</td>
<td>none</td>
</tr>
<tr class="row-odd"><td>FLAT_ATOMIC_AND</td>
<td>GLOBAL_ATOMIC_AND</td>
<td>none</td>
</tr>
<tr class="row-even"><td>FLAT_ATOMIC_OR</td>
<td>GLOBAL_ATOMIC_OR</td>
<td>none</td>
</tr>
<tr class="row-odd"><td>FLAT_ATOMIC_XOR</td>
<td>GLOBAL_ATOMIC_XOR</td>
<td>none</td>
</tr>
<tr class="row-even"><td>FLAT_ATOMIC_INC</td>
<td>GLOBAL_ATOMIC_INC</td>
<td>none</td>
</tr>
<tr class="row-odd"><td>FLAT_ATOMIC_DEC</td>
<td>GLOBAL_ATOMIC_DEC</td>
<td>none</td>
</tr>
<tr class="row-even"><td>The atomic instructions
above are also
available in “_X2”
versions (64-bit).</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Table: Flat, Global and Scratch Opcodes</p>
</div>
<div class="section" id="id5">
<h3>Instructions<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>The FLAT instruction set is nearly identical to the Buffer instruction
set, but without the FORMAT reads and writes. Unlike Buffer
instructions, FLAT instructions cannot return data directly to LDS, but
only to VGPRs.</p>
<p>FLAT instructions do not use a resource constant (V#) or sampler (S#);
however, they do require a special SGPR-pair to hold scratch-space
information in case any threads’ address resolves to scratch space. See
the Scratch section for details.</p>
<p>Internally, FLAT instruction are executed as both an LDS and a Buffer
instruction; so, they increment both VM_CNT and LGKM_CNT and are not
considered done until both have been decremented. There is no way
beforehand to determine whether a FLAT instruction uses only LDS or TA
memory space.</p>
<div class="section" id="ordering">
<h4>Ordering<a class="headerlink" href="#ordering" title="Permalink to this headline">¶</a></h4>
<p>Flat instructions can complete out of order with each other. If one flat
instruction finds all of its data in Texture cache, and the next finds
all of its data in LDS, the second instruction might complete first. If
the two fetches return data to the same VGPR, the result are unknown.</p>
</div>
<div class="section" id="importing-timing-consideration">
<h4>Importing Timing Consideration<a class="headerlink" href="#importing-timing-consideration" title="Permalink to this headline">¶</a></h4>
<p>Since the data for a FLAT load can come from either LDS or the texture
cache, and because these units have different latencies, there is a
potential race condition with respect to the VM_CNT and LGKM_CNT
counters. Because of this, the only sensible S_WAITCNT value to use
after FLAT instructions is zero.</p>
</div>
</div>
<div class="section" id="addressing">
<h3>Addressing<a class="headerlink" href="#addressing" title="Permalink to this headline">¶</a></h3>
<p>FLAT instructions support both 64- and 32-bit addressing. The address
size is set using a mode register (PTR32), and a local copy of the value
is stored per wave.</p>
<p>The addresses for the aperture check differ in 32- and 64-bit mode;
however, this is not covered here.</p>
<p>64-bit addresses are stored with the LSBs in the VGPR at ADDR, and the
MSBs in the VGPR at ADDR+1.</p>
<p>For scratch space, the texture unit takes the address from the VGPR and
does the following.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Address</span> <span class="o">=</span> <span class="n">VGPR</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">+</span> <span class="n">TID_in_wave</span> <span class="o">*</span> <span class="n">Size</span>
          <span class="o">-</span> <span class="n">private</span> <span class="n">aperture</span> <span class="n">base</span> <span class="p">(</span><span class="ow">in</span> <span class="n">SH_MEM_BASES</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">offset</span> <span class="p">(</span><span class="kn">from</span> <span class="nn">flat_scratch</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="global">
<h3>Global<a class="headerlink" href="#global" title="Permalink to this headline">¶</a></h3>
<p>Global instructions are similar to Flat instructions, but the programmer
must ensure that no threads access LDS space; thus, no LDS bandwidth is
used by global instructions.</p>
<p>Global instructions offer two types of addressing:</p>
<ul class="simple">
<li>Memory_addr = VGPR-address + instruction offset.</li>
<li>Memory_addr = SGPR-address + VGPR-offset + instruction offset.</li>
</ul>
<p>The size of the address component is dependent on ADDRESS_MODE: 32-bits
or 64-bit pointers. The VGPR-offset is always 32 bits.</p>
<p>These instructions also allow direct data movement between LDS and
memory without going through VGPRs.</p>
<p>Since these instructions do not access LDS, only VM_CNT is used, not
LGKM_CNT. If a global instruction does attempt to access LDS, the
instruction returns MEM_VIOL.</p>
</div>
<div class="section" id="scratch">
<h3>Scratch<a class="headerlink" href="#scratch" title="Permalink to this headline">¶</a></h3>
<p>Scratch instructions are similar to Flat, but the programmer must ensure
that no threads access LDS space, and the memory space is swizzled.
Thus, no LDS bandwidth is used by scratch instructions.</p>
<p>Scratch instructions also support multi-Dword access and mis-aligned
access (although mis-aligned is slower).</p>
<p>Scratch instructions use the following addressing:</p>
<ul class="simple">
<li>Memory_addr = flat_scratch.addr + swizzle(V/SGPR_offset +
inst_offset, threadID)</li>
<li>The offset can come from either an SGPR or a VGPR, and is always a
32- bit unsigned byte.</li>
</ul>
<p>The size of the address component is dependent on the ADDRESS_MODE:
32-bits or 64-bit pointers. The VGPR-offset is always 32 bits.</p>
<p>These instructions also allow direct data movement between LDS and
memory without going through VGPRs.</p>
<p>Since these instructions do not access LDS, only VM_CNT is used, not
LGKM_CNT. It is not possible for a Scratch instruction to access LDS;
thus, no error or aperture checking is done.</p>
</div>
<div class="section" id="memory-error-checking">
<h3>Memory Error Checking<a class="headerlink" href="#memory-error-checking" title="Permalink to this headline">¶</a></h3>
<p>Both TA and LDS can report that an error occurred due to a bad address.
This can occur for the following reasons:</p>
<ul class="simple">
<li>invalid address (outside any aperture)</li>
<li>write to read-only surface</li>
<li>misaligned data</li>
<li>out-of-range address:<ul>
<li>LDS access with an address outside the range: [ 0, MIN(M0,
LDS_SIZE)-1 ]</li>
<li>Scratch access with an address outside the range: [0, scratch-size
-1 ]</li>
</ul>
</li>
</ul>
<p>The policy for threads with bad addresses is: writes outside this range
do not write a value, and reads return zero.</p>
<p>Addressing errors from either LDS or TA are returned on their respective
“instruction done” busses as MEM_VIOL. This sets the wave’s MEM_VIOL
TrapStatus bit and causes an exception (trap) if the corresponding
EXCPEN bit is set.</p>
</div>
<div class="section" id="data">
<h3>Data<a class="headerlink" href="#data" title="Permalink to this headline">¶</a></h3>
<p>FLAT instructions can use zero to four consecutive Dwords of data in
VGPRs and/or memory. The DATA field determines which VGPR(s) supply
source data (if any), and the VDST VGPRs hold return data (if any). No
data-format conversion is done.</p>
</div>
<div class="section" id="scratch-space-private">
<h3>Scratch Space (Private)<a class="headerlink" href="#scratch-space-private" title="Permalink to this headline">¶</a></h3>
<p>Scratch (thread-private memory) is an area of memory defined by the
aperture registers. When an address falls in scratch space, additional
address computation is automatically performed by the hardware. The
kernel must provide additional information for this computation to occur
in the form of the FLAT_SCRATCH register.</p>
<p>The FLAT_SCRATCH address is automatically sent with every FLAT request.</p>
<p>FLAT_SCRATCH is a 64-bit, byte address. The shader composes the value
by adding together two separate values: the base address, which can be
passed in via an initialized SGPR, or perhaps through a constant buffer,
and the per-wave allocation offset (also initialized in an SGPR).</p>
</div>
</div>
<div class="section" id="data-share-operations">
<h2>Data Share Operations<a class="headerlink" href="#data-share-operations" title="Permalink to this headline">¶</a></h2>
<p>Local data share (LDS) is a very low-latency, RAM scratchpad for
temporary data with at least one order of magnitude higher effective
bandwidth than direct, uncached global memory. It permits sharing of
data between work-items in a work-group, as well as holding parameters
for pixel shader parameter interpolation. Unlike read-only caches, the
LDS permits high-speed write-to-read re-use of the memory space (full
gather/read/load and scatter/write/store operations).</p>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>The figure below shows the conceptual framework of the LDS is
integration into the memory of AMD GPUs using OpenCL.</p>
<div class="figure">
<img alt="../_images/fig_10_1.png" src="../_images/fig_10_1.png" />
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">alt:</th><td class="field-body"><p class="first">High-Level Memory Configuration</p>
<p class="last">High-Level Memory Configuration</p>
</td>
</tr>
</tbody>
</table>
<p>Physically located on-chip, directly next to the ALUs, the LDS is
approximately one order of magnitude faster than global memory (assuming
no bank conflicts).</p>
<p>There are 64 kB memory per compute unit, segmented into 32 of 512
Dwords. Each bank is a 256x32 two-port RAM (1R/1W per clock cycle).
Dwords are placed in the banks serially, but all banks can execute a
store or load simultaneously. One work-group can request up to 64 kB
memory. Reads across wavefront are dispatched over four cycles in
waterfall.</p>
<p>The high bandwidth of the LDS memory is achieved not only through its
proximity to the ALUs, but also through simultaneous access to its
memory banks. Thus, it is possible to concurrently execute 32 write or
read instructions, each nominally 32-bits; extended instructions,
read2/write2, can be 64-bits each. If, however, more than one access
attempt is made to the same bank at the same time, a bank conflict
occurs. In this case, for indexed and atomic operations, hardware
prevents the attempted concurrent accesses to the same bank by turning
them into serial accesses. This decreases the effective bandwidth of the
LDS. For maximum throughput (optimal efficiency), therefore, it is
important to avoid bank conflicts. A knowledge of request scheduling and
address mapping is key to achieving this.</p>
</div>
<div class="section" id="dataflow-in-memory-hierarchy">
<h3>Dataflow in Memory Hierarchy<a class="headerlink" href="#dataflow-in-memory-hierarchy" title="Permalink to this headline">¶</a></h3>
<p>The figure below is a conceptual diagram of the dataflow withing the
memory structure.</p>
<p><img alt="fig 10 2" src="../_images/fig_10_2.png" /></p>
<p>To load data into LDS from global memory, it is read from global memory
and placed into the work-item’s registers; then, a store is performed to
LDS. Similarly, to store data into global memory, data is read from LDS
and placed into the workitem’s registers, then placed into global
memory. To make effective use of the LDS, an algorithm must perform many
operations on what is transferred between global memory and LDS. It also
is possible to load data from a memory buffer directly into LDS,
bypassing VGPRs.</p>
<p>LDS atomics are performed in the LDS hardware. (Thus, although ALUs are
not directly used for these operations, latency is incurred by the LDS
executing this function.)</p>
</div>
<div class="section" id="lds-access">
<h3>LDS Access<a class="headerlink" href="#lds-access" title="Permalink to this headline">¶</a></h3>
<p>The LDS is accessed in one of three ways:</p>
<ul class="simple">
<li>Direct Read</li>
<li>Parameter Read</li>
<li>Indexed or Atomic</li>
</ul>
<p>The following subsections describe these methods.</p>
<div class="section" id="lds-direct-reads">
<h4>LDS Direct Reads<a class="headerlink" href="#lds-direct-reads" title="Permalink to this headline">¶</a></h4>
<p>Direct reads are only available in LDS, not in GDS.</p>
<p>LDS Direct reads occur in vector ALU (VALU) instructions and allow the
LDS to supply a single DWORD value which is broadcast to all threads in
the wavefront and is used as the SRC0 input to the ALU operations. A
VALU instruction indicates that input is to be supplied by LDS by using
the LDS_DIRECT for the SRC0 field.</p>
<p>The LDS address and data-type of the data to be read from LDS comes from
the M0 register:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LDS_addr</span> <span class="o">=</span> <span class="n">M0</span><span class="p">[</span><span class="mi">15</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="n">byte</span> <span class="n">address</span> <span class="ow">and</span> <span class="n">must</span> <span class="n">be</span> <span class="n">Dword</span> <span class="n">aligned</span><span class="p">)</span>
<span class="n">DataType</span> <span class="o">=</span> <span class="n">M0</span><span class="p">[</span><span class="mi">18</span><span class="p">:</span><span class="mi">16</span><span class="p">]</span>
    <span class="mi">0</span> <span class="n">unsigned</span> <span class="n">byte</span>
    <span class="mi">1</span> <span class="n">unsigned</span> <span class="n">short</span>
    <span class="mi">2</span> <span class="n">Dword</span>
    <span class="mi">3</span> <span class="n">unused</span>
    <span class="mi">4</span> <span class="n">signed</span> <span class="n">byte</span>
    <span class="mi">5</span> <span class="n">signed</span> <span class="n">short</span>
</pre></div>
</div>
</div>
<div class="section" id="lds-parameter-reads">
<h4>LDS Parameter Reads<a class="headerlink" href="#lds-parameter-reads" title="Permalink to this headline">¶</a></h4>
<p>Parameter reads are only available in LDS, not in GDS.</p>
<p>Pixel shaders use LDS to read vertex parameter values; the pixel shader
then interpolates them to find the per-pixel parameter values. LDS
parameter reads occur when the following opcodes are used.</p>
<ul class="simple">
<li>V_INTERP_P1_F32 D = P10 * S + P0 Parameter interpolation, first
step.</li>
<li>V_INTERP_P2_F32D = P20 * S + DParameter interpolation, second
step.</li>
<li>V_INTERP_MOV_F32D = {P10,P20,P0}[S]Parameter load.</li>
</ul>
<p>The typical parameter interpolation operations involves reading three
parameters: P0, P10, and P20, and using the two barycentric coordinates,
I and J, to determine the final per-pixel value:</p>
<div class="informalexample"><p>Final value = P0 + P10 * I + P20 * J</p>
</div><p>Parameter interpolation instructions indicate the parameter attribute
number (0 to 32) and the component number (0=x, 1=y, 2=z and 3=w).</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VDST</td>
<td>8</td>
<td>Destination VGPR. Also acts as source for
v_interp_p2_f32.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>2</td>
<td><div class="first last line-block">
<div class="line">Opcode:</div>
<div class="line">0: v_interp_p1_f32 VDST = P10 * VSRC + P0</div>
<div class="line">1: v_interp_p2_f32 VDST = P20 * VSRC +
VDST</div>
<div class="line">2: v_interp_mov_f32 VDST = (P0, P10 or P20
selected by VSRC[1:0])</div>
<div class="line">P0, P10 and P20 are parameter values read from
LDS</div>
</div>
</td>
</tr>
<tr class="row-even"><td>ATTR</td>
<td>6</td>
<td>Attribute number: 0 to 32.</td>
</tr>
<tr class="row-odd"><td>ATTRCHAN</td>
<td>2</td>
<td>0=X, 1=Y, 2=Z, 3=W</td>
</tr>
<tr class="row-even"><td>VSRC</td>
<td>8</td>
<td>Source VGPR supplies interpolation “I” or “J”
value. For OP==v_interp_mov_f32: 0=P10,
1=P20, 2=P0. VSRC must not be the same register
as VDST because 16-bank LDS chips implement
v_interp_p1 as a macro of two instructions.</td>
</tr>
<tr class="row-odd"><td>( M0 )</td>
<td>32</td>
<td>Use of the M0 register is automatic. M0 must
contain: { 1’b0, new_prim_mask[15:1],
lds_param_offset[15:0] }</td>
</tr>
</tbody>
</table>
<p>Table: Parameter Instruction Fields</p>
<p>Parameter interpolation and parameter move instructions must initialize
the M0 register before using it. The lds_param_offset[15:0] is an
address offset from the beginning of LDS storage allocated to this
wavefront to where parameters begin in LDS memory for this wavefront.
The new_prim_mask is a 15-bit mask with one bit per quad; a one in
this mask indicates that this quad begins a new primitive, a zero
indicates it uses the same primitive as the previous quad. The mask is
15 bits, not 16, since the first quad in a wavefront always begins a new
primitive and so it is not included in the mask.</p>
</div>
<div class="section" id="data-share-indexed-and-atomic-access">
<h4>Data Share Indexed and Atomic Access<a class="headerlink" href="#data-share-indexed-and-atomic-access" title="Permalink to this headline">¶</a></h4>
<p>Both LDS and GDS can perform indexed and atomic data share operations.
For brevity, “LDS” is used in the text below and, except where noted,
also applies to GDS.</p>
<p>Indexed and atomic operations supply a unique address per work-item from
the VGPRs to the LDS, and supply or return unique data per work-item
back to VGPRs. Due to the internal banked structure of LDS, operations
can complete in as little as two cycles, or take as many 64 cycles,
depending upon the number of bank conflicts (addresses that map to the
same memory bank).</p>
<p>Indexed operations are simple LDS load and store operations that read
data from, and return data to, VGPRs.</p>
<p>Atomic operations are arithmetic operations that combine data from VGPRs
and data in LDS, and write the result back to LDS. Atomic operations
have the option of returning the LDS “pre-op” value to VGPRs.</p>
<p>The table below lists and briefly describes the LDS instruction fields.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OP</td>
<td>7</td>
<td>LDS opcode.</td>
</tr>
<tr class="row-odd"><td>GDS</td>
<td>1</td>
<td>0 = LDS, 1 = GDS.</td>
</tr>
<tr class="row-even"><td>OFFSET0</td>
<td>8</td>
<td>Immediate offset, in bytes. Instructions with
one address combine the offset fields into a
single 16-bit unsigned offset: {offset1,
offset0}. Instructions with two addresses (for
example: READ2) use the offsets separately as
two 8- bit unsigned offsets. DS_*_SRC2_*
ops treat the offset as a 16-bit signed Dword
offset.</td>
</tr>
<tr class="row-odd"><td>OFFSET1</td>
<td>8</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>VDST</td>
<td>8</td>
<td>VGPR to which result is written: either from
LDS-load or atomic return value.</td>
</tr>
<tr class="row-odd"><td>ADDR</td>
<td>8</td>
<td>VGPR that supplies the byte address offset.</td>
</tr>
<tr class="row-even"><td>DATA0</td>
<td>8</td>
<td>VGPR that supplies first data source.</td>
</tr>
<tr class="row-odd"><td>DATA1</td>
<td>8</td>
<td>VGPR that supplies second data source.</td>
</tr>
</tbody>
</table>
<p>Table: LDS Instruction Fields</p>
<p>All LDS operations require that M0 be initialized prior to use. M0
contains a size value that can be used to restrict access to a subset of
the allocated LDS range. If no clamping is wanted, set M0 to 0xFFFFFFFF.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Load / Store</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>DS_READ_{B32
,B64,B96,B128,
U8,I8,U16,I16}</td>
<td>Read one value per thread; sign extend to Dword, if
signed.</td>
</tr>
<tr class="row-odd"><td>DS_READ2_{B3
2,B64}</td>
<td>Read two values at unique addresses.</td>
</tr>
<tr class="row-even"><td>DS_READ2ST64_{B32,B64}</td>
<td>Read 2 values at unique addresses; offset *= 64.</td>
</tr>
<tr class="row-odd"><td>DS_WRITE_{B3
2,B64,B96,B128
,B8,B16}</td>
<td>Write one value.</td>
</tr>
<tr class="row-even"><td>DS_WRITE2_{B
32,B64}</td>
<td>Write two values.</td>
</tr>
<tr class="row-odd"><td>DS_WRITE2ST64
_{B32,B64}</td>
<td>Write two values, offset *= 64.</td>
</tr>
<tr class="row-even"><td>DS_WRXCHG2_R
TN_{B32,B64}</td>
<td>Exchange GPR with LDS-memory.</td>
</tr>
<tr class="row-odd"><td>DS_WRXCHG2ST6
4_RTN_{B32,B
64}</td>
<td>Exchange GPR with LDS-memory; offset *= 64.</td>
</tr>
<tr class="row-even"><td>DS_PERMUTE_B
32</td>
<td><div class="first last line-block">
<div class="line">Forward permute. Does not write any LDS memory.</div>
<div class="line">LDS[dst] = src0</div>
<div class="line">returnVal = LDS[thread_id]</div>
<div class="line">where thread_id is 0..63.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>DS_BPERMUTE_
B32</td>
<td><div class="first last line-block">
<div class="line">Backward permute. Does not actually write any LDS
memory.</div>
<div class="line">LDS[thread_id] = src0</div>
<div class="line">where thread_id is 0..63, and returnVal = LDS[dst].</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table: LDS Indexed Load/Store</p>
<div class="line-block">
<div class="line"><strong>Single Address Instructions</strong></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LDS_Addr</span> <span class="o">=</span> <span class="n">LDS_BASE</span> <span class="o">+</span> <span class="n">VGPR</span><span class="p">[</span><span class="n">ADDR</span><span class="p">]</span> <span class="o">+</span> <span class="p">{</span><span class="n">InstrOffset1</span><span class="p">,</span><span class="n">InstrOffset0</span><span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><strong>Double Address Instructions</strong></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LDS_Addr0</span> <span class="o">=</span> <span class="n">LDS_BASE</span> <span class="o">+</span> <span class="n">VGPR</span><span class="p">[</span><span class="n">ADDR</span><span class="p">]</span> <span class="o">+</span> <span class="n">InstrOffset0</span><span class="o">*</span><span class="n">ADJ</span> <span class="o">+</span>
<span class="n">LDS_Addr1</span> <span class="o">=</span> <span class="n">LDS_BASE</span> <span class="o">+</span> <span class="n">VGPR</span><span class="p">[</span><span class="n">ADDR</span><span class="p">]</span> <span class="o">+</span> <span class="n">InstrOffset1</span><span class="o">*</span><span class="n">ADJ</span>
   <span class="n">Where</span> <span class="n">ADJ</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">for</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span> <span class="ow">and</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="n">data</span> <span class="n">types</span><span class="p">;</span> <span class="ow">and</span> <span class="n">ADJ</span> <span class="o">=</span> <span class="mi">8</span> <span class="k">for</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="o">.</span>
</pre></div>
</div>
<p>Note that LDS_ADDR1 is used only for READ2*, WRITE2*, and WREXCHG2*.</p>
<p>M0[15:0] provides the size in bytes for this access. The size sent to
LDS is MIN(M0, LDS_SIZE), where LDS_SIZE is the amount of LDS space
allocated by the shader processor interpolator, SPI, at the time the
wavefront was created.</p>
<p>The address comes from VGPR, and both ADDR and InstrOffset are byte
addresses.</p>
<p>At the time of wavefront creation, LDS_BASE is assigned to the physical
LDS region owned by this wavefront or work-group.</p>
<p>Specify only one address by setting both offsets to the same value. This
causes only one read or write to occur and uses only the first DATA0.</p>
<p><strong>SRC2 Ops</strong> The ds_&lt;op&gt;_src2_&lt;type&gt; opcodes are different. These
operands perform an atomic operation on 2 operands from the LDS memory:
one is viewed as the data and the other is the second source operand and
the final destination. The addressing for these can operate in two
different modes depending on the MSB of offset1[7]: If it is 0, the
offset for the data term is derived by the offset fields as a SIGNED
dword offset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LDS_Addr0</span> <span class="o">=</span> <span class="n">LDS_BASE</span> <span class="o">+</span> <span class="n">VGPR</span><span class="p">(</span><span class="n">ADDR</span><span class="p">)</span> <span class="o">+</span> <span class="n">SIGNEXTEND</span><span class="p">(</span><span class="n">InstrOffset1</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">0</span><span class="p">],</span><span class="n">InstrOffset0</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="mi">2</span>    <span class="o">//</span> <span class="n">data</span> <span class="n">term</span>
<span class="n">LDS_Addr1</span> <span class="o">=</span> <span class="n">LDS_BASE</span> <span class="o">+</span> <span class="n">VGPR</span><span class="p">(</span><span class="n">ADDR</span><span class="p">)</span>                 <span class="o">//</span> <span class="n">second</span> <span class="n">source</span> <span class="ow">and</span> <span class="n">final</span> <span class="n">destination</span> <span class="n">address</span>
</pre></div>
</div>
<p>If the bit is 1, the offset for the data term becomes per thread and is
a SIGNED dword offset derived from the msbs read from the VGPR for the
index. The addressing becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LDS_Addr0</span> <span class="o">=</span> <span class="n">LDS_BASE</span> <span class="o">+</span> <span class="n">VGPR</span><span class="p">(</span><span class="n">ADDR</span><span class="p">)[</span><span class="mi">16</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">SIGNEXTEND</span><span class="p">(</span><span class="n">VGPR</span><span class="p">(</span><span class="n">ADDR</span><span class="p">)[</span><span class="mi">31</span><span class="p">:</span><span class="mi">17</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">2</span>      <span class="o">//</span> <span class="n">data</span> <span class="n">term</span>
<span class="n">LDS_Addr1</span> <span class="o">=</span> <span class="n">LDS_BASE</span> <span class="o">+</span> <span class="n">VGPR</span><span class="p">(</span><span class="n">ADDR</span><span class="p">)[</span><span class="mi">16</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>     <span class="o">//</span> <span class="n">second</span> <span class="n">source</span> <span class="ow">and</span> <span class="n">final</span> <span class="n">destination</span> <span class="n">address</span>
</pre></div>
</div>
<p><strong>LDS Atomic Ops</strong> DS_&lt;atomicOp&gt; OP, GDS=0, OFFSET0, OFFSET1, VDST,
ADDR, Data0, Data1</p>
<p>Data size is encoded in atomicOp: byte, word, Dword, or double.</p>
<div class="informalexample"><p>LDS_Addr0 = LDS_BASE + VGPR[ADDR] + {InstrOffset1,InstrOffset0}</p>
</div><p>ADDR is a Dword address. VGPRs 0,1 and dst are double-GPRs for doubles
data.</p>
<p>VGPR data sources can only be VGPRs or constant values, not SGPRs.</p>
</div>
</div>
</div>
<div class="section" id="exporting-pixel-and-vertex-data">
<h2>Exporting Pixel and Vertex Data<a class="headerlink" href="#exporting-pixel-and-vertex-data" title="Permalink to this headline">¶</a></h2>
<p>The export instruction copies pixel or vertex shader data from VGPRs
into a dedicated output buffer. The export instruction outputs the
following types of data.</p>
<ul class="simple">
<li>Vertex Position</li>
<li>Vertex Parameter</li>
<li>Pixel color</li>
<li>Pixel depth (Z)</li>
</ul>
<div class="section" id="id6">
<h3>Microcode Encoding<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>The export instruction uses the EXP microcode format.</p>
<p><img alt="microcode exp" src="../_images/microcode_exp.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field</th>
<th class="head">Size</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VM</td>
<td>1</td>
<td>Valid Mask. When set to
1, this indicates that
the EXEC mask represents
the valid-mask for this
wavefront. It can be
sent multiple times per
shader (the final value
is used), but must be
sent at least once per
pixel shader.</td>
</tr>
<tr class="row-odd"><td>DONE</td>
<td>1</td>
<td>This is the final pixel
shader or
vertex-position export
of the program. Used
only for pixel and
position exports. Set to
zero for parameters.</td>
</tr>
<tr class="row-even"><td>COMPR</td>
<td>1</td>
<td>Compressed data. When
set, indicates that the
data being exported is
16-bits per component
rather than the usual
32-bit.</td>
</tr>
<tr class="row-odd"><td>TARGET</td>
<td>6</td>
<td><div class="first last line-block">
<div class="line">Indicates type of data
exported.</div>
<div class="line">0..7 MRT 0..7</div>
<div class="line">8 Z</div>
<div class="line">9 Null (no data)</div>
<div class="line">12-15 Position 0..3</div>
<div class="line">32-63 Param 0..31</div>
</div>
</td>
</tr>
<tr class="row-even"><td>EN</td>
<td>4</td>
<td><div class="first last line-block">
<div class="line"><strong>COMPR==1</strong>: export
half-Dword enable.
Valid values are:
0x0,3,C,F.</div>
<div class="line">[0] enables VSRC0 :
R,G from one VGPGR</div>
<div class="line">[2] enables VSRC1 :
B,A from one VGPR</div>
<div class="line"><strong>COMPR==0</strong>: [0-3] =
enables for VSRC0..3.</div>
<div class="line">EN can be zero (used
when exporting only
valid mask to NULL
target).</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>VSRC3</td>
<td>8</td>
<td><div class="first last line-block">
<div class="line">VGPR from which to
read data.</div>
<div class="line">Pos &amp; Param: vsrc0=X,
1=Y, 2=Z, 3=W</div>
<div class="line">MRT: vsrc0=R, 1=G,
2=B, 3=A</div>
</div>
</td>
</tr>
<tr class="row-even"><td>VSRC2</td>
<td>8</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>VSRC1</td>
<td>8</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>VSRC0</td>
<td>8</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Table: EXP Encoding Field Descriptions</p>
</div>
<div class="section" id="id7">
<h3>Operations<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="section" id="pixel-shader-exports">
<h4>Pixel Shader Exports<a class="headerlink" href="#pixel-shader-exports" title="Permalink to this headline">¶</a></h4>
<p>Export instructions copy color data to the MRTs. Data always has four
components (R, G, B, A). Optionally, export instructions also output
depth (Z) data.</p>
<p>Every pixel shader must have at least one export instruction. The last
export instruction executed must have the DONE bit set to one.</p>
<p>The EXEC mask is applied to all exports. Only pixels with the
corresponding EXEC bit set to 1 export data to the output buffer.
Results from multiple exports are accumulated in the output buffer.</p>
<p>At least one export must have the VM bit set to 1. This export, in
addition to copying data to the color or depth output buffer, also
informs the color buffer which pixels are valid and which have been
discarded. The value of the EXEC mask communicates the pixel valid mask.
If multiple exports are sent with VM set to 1, the mask from the final
export is used. If the shader program wants to only update the valid
mask but not send any new data, the program can do an export to the NULL
target.</p>
</div>
<div class="section" id="vertex-shader-exports">
<h4>Vertex Shader Exports<a class="headerlink" href="#vertex-shader-exports" title="Permalink to this headline">¶</a></h4>
<p>The vertex shader uses export instructions to output vertex position
data and vertex parameter data to the output buffer. This data is passed
on to subsequent pixel shaders.</p>
<p>Every vertex shader must output at least one position vector (x, y, z; w
is optional) to the POS0 target. The last position export must have the
DONE bit set to 1. A vertex shader can export zero or more parameters.
For best performance, it is best to output all position data as early as
possible in the vertex shader.</p>
</div>
</div>
<div class="section" id="id8">
<h3>Dependency Checking<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Export instructions are executed by the hardware in two phases. First,
the instruction is selected to be executed, and EXPCNT is incremented by
1. At this time, the hardware requests the use of internal busses needed
to complete the instruction.</p>
<p>When access to the bus is granted, the EXEC mask is read and the VGPR
data sent out. After the last of the VGPR data is sent, the EXPCNT
counter is decremented by 1.</p>
<p>Use S_WAITCNT on EXPCNT to prevent the shader program from overwriting
EXEC or the VGPRs holding the data to be exported before the export
operation has completed.</p>
<p>Multiple export instructions can be outstanding at one time. Exports of
the same type (for example: position) are completed in order, but
exports of different types can be completed out of order.</p>
<p>If the STATUS register’s SKIP_EXPORT bit is set to one, the hardware
treats all EXPORT instructions as if they were NOPs.</p>
</div>
</div>
<div class="section" id="id9">
<h2>Instructions<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>This chapter lists, and provides descriptions for, all instructions in
the GCN Vega Generation environment. Instructions are grouped according
to their format.</p>
<p><strong>Instruction suffixes have the following definitions:</strong></p>
<ul>
<li><div class="first line-block">
<div class="line">B32 Bitfield (untyped data) 32-bit</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">B64 Bitfield (untyped data) 64-bit</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">F32 floating-point 32-bit (IEEE 754 single-precision float)</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">F64 floating-point 64-bit (IEEE 754 double-precision float)</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">I32 signed 32-bit integer</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">I64 signed 64-bit integer</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">U32 unsigned 32-bit integer</div>
</div>
</li>
<li><p class="first">U64 unsigned 64-bit integer</p>
</li>
</ul>
<p>If an instruction has two suffixes (for example, _I32_F32), the first
suffix indicates the destination type, the second the source type.</p>
<p>The following abbreviations are used in instruction definitions:</p>
<ul>
<li><div class="first line-block">
<div class="line">D = destination</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">U = unsigned integer</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">S = source</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">SCC = scalar condition code</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">I = signed integer</div>
</div>
</li>
<li><p class="first">B = bitfield</p>
</li>
</ul>
<p>Note: .u or .i specifies to interpret the argument as an unsigned or
signed float.</p>
<p>Note: Rounding and Denormal modes apply to all floating-point operations
unless otherwise specified in the instruction description.</p>
<div class="section" id="sop2-instructions">
<h3>SOP2 Instructions<a class="headerlink" href="#sop2-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode sop2" src="../_images/microcode_sop2.png" /></p>
<p>Instructions in this format may use a 32-bit literal constant which
occurs immediately after the instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_ADD_U32</td>
<td>D.u = S0.u + S1.u; SCC = (S0.u + S1.u &gt;=
0x100000000ULL ? 1 : 0). // unsigned
overflow/carry-out, S_ADDC_U32</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_SUB_U32</td>
<td>D.u = S0.u - S1.u; SCC = (S1.u &gt; S0.u ? 1 : 0). //
unsigned overflow or carry-out for S_SUBB_U32.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_ADD_I32</td>
<td>D.i = S0.i + S1.i; SCC = (S0.u[31] == S1.u[31] &amp;&amp;
S0.u[31] != D.u[31]). // signed overflow. This
opcode is not suitable for use with S_ADDC_U32
for implementing 64-bit operations.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_SUB_I32</td>
<td>D.i = S0.i - S1.i; SCC = (S0.u[31] != S1.u[31] &amp;&amp;
S0.u[31] != D.u[31]). // signed overflow. This
opcode is not suitable for use with S_SUBB_U32
for implementing 64-bit operations.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_ADDC_U32</td>
<td>D.u = S0.u + S1.u + SCC; SCC = (S0.u + S1.u + SCC
&gt;= 0x100000000ULL ? 1 : 0). // unsigned overflow.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_SUBB_U32</td>
<td>D.u = S0.u - S1.u - SCC; SCC = (S1.u + SCC &gt; S0.u
? 1 : 0). // unsigned overflow.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_MIN_I32</td>
<td>D.i = (S0.i &lt; S1.i) ? S0.i : S1.i; SCC = (S0.i &lt;
S1.i).</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_MIN_U32</td>
<td>D.u = (S0.u &lt; S1.u) ? S0.u : S1.u; SCC = (S0.u &lt;
S1.u).</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_MAX_I32</td>
<td>D.i = (S0.i &gt; S1.i) ? S0.i : S1.i; SCC = (S0.i &gt;
S1.i).</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_MAX_U32</td>
<td>D.u = (S0.u &gt; S1.u) ? S0.u : S1.u; SCC = (S0.u &gt;
S1.u).</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_CSELECT_B3
2</td>
<td>D.u = SCC ? S0.u : S1.u. Conditional select.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_CSELECT_B6
4</td>
<td>D.u64 = SCC ? S0.u64 : S1.u64. Conditional select.</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_AND_B32</td>
<td>D = S0 &amp; S1; SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_AND_B64</td>
<td>D = S0 &amp; S1; SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_OR_B32</td>
<td>D = S0 | S1; SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_OR_B64</td>
<td>D = S0 | S1; SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_XOR_B32</td>
<td>D = S0 ^ S1; SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_XOR_B64</td>
<td>D = S0 ^ S1; SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_ANDN2_B32</td>
<td>D = S0 &amp; ~S1; SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_ANDN2_B64</td>
<td>D = S0 &amp; ~S1; SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>20</td>
<td>S_ORN2_B32</td>
<td>D = S0 | ~S1; SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>S_ORN2_B64</td>
<td>D = S0 | ~S1; SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>22</td>
<td>S_NAND_B32</td>
<td>D = ~(S0 &amp; S1); SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>S_NAND_B64</td>
<td>D = ~(S0 &amp; S1); SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>24</td>
<td>S_NOR_B32</td>
<td>D = ~(S0 | S1); SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>S_NOR_B64</td>
<td>D = ~(S0 | S1); SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>26</td>
<td>S_XNOR_B32</td>
<td>D = ~(S0 ^ S1); SCC = (D != 0).</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>S_XNOR_B64</td>
<td>D = ~(S0 ^ S1); SCC = (D != 0).</td>
</tr>
<tr class="row-even"><td>28</td>
<td>S_LSHL_B32</td>
<td>D.u = S0.u &lt;&lt; S1.u[4:0]; SCC = (D.u != 0).</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>S_LSHL_B64</td>
<td>D.u64 = S0.u64 &lt;&lt; S1.u[5:0]; SCC = (D.u64 != 0).</td>
</tr>
<tr class="row-even"><td>30</td>
<td>S_LSHR_B32</td>
<td>D.u = S0.u &gt;&gt; S1.u[4:0]; SCC = (D.u != 0).</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>S_LSHR_B64</td>
<td>D.u64 = S0.u64 &gt;&gt; S1.u[5:0]; SCC = (D.u64 != 0).</td>
</tr>
<tr class="row-even"><td>32</td>
<td>S_ASHR_I32</td>
<td>D.i = signext(S0.i) &gt;&gt; S1.u[4:0]; SCC = (D.i !=
0).</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>S_ASHR_I64</td>
<td>D.i64 = signext(S0.i64) &gt;&gt; S1.u[5:0]; SCC = (D.i64
!= 0).</td>
</tr>
<tr class="row-even"><td>34</td>
<td>S_BFM_B32</td>
<td>D.u = ((1 &lt;&lt; S0.u[4:0]) - 1) &lt;&lt; S1.u[4:0].
Bitfield mask.</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>S_BFM_B64</td>
<td>D.u64 = ((1ULL &lt;&lt; S0.u[5:0]) - 1) &lt;&lt; S1.u[5:0].
Bitfield mask.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>S_MUL_I32</td>
<td>D.i = S0.i * S1.i.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>S_BFE_U32</td>
<td>D.u = (S0.u &gt;&gt; S1.u[4:0]) &amp; ((1 &lt;&lt; S1.u[22:16]) -
1); SCC = (D.u != 0). Bit field extract. S0 is
Data, S1[4:0] is field offset, S1[22:16] is field
width.</td>
</tr>
<tr class="row-even"><td>38</td>
<td>S_BFE_I32</td>
<td>D.i = signext((S0.i &gt;&gt; S1.u[4:0]) &amp; ((1 &lt;&lt;
S1.u[22:16]) - 1)); SCC = (D.i != 0). Bit field
extract. S0 is Data, S1[4:0] is field offset,
S1[22:16] is field width.</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>S_BFE_U64</td>
<td>D.u64 = (S0.u64 &gt;&gt; S1.u[5:0]) &amp; ((1 &lt;&lt;
S1.u[22:16]) - 1); SCC = (D.u64 != 0). Bit field
extract. S0 is Data, S1[5:0] is field offset,
S1[22:16] is field width.</td>
</tr>
<tr class="row-even"><td>40</td>
<td>S_BFE_I64</td>
<td>D.i64 = signext((S0.i64 &gt;&gt; S1.u[5:0]) &amp; ((1 &lt;&lt;
S1.u[22:16]) - 1)); SCC = (D.i64 != 0). Bit field
extract. S0 is Data, S1[5:0] is field offset,
S1[22:16] is field width.</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>S_CBRANCH_G_FORK</td>
<td>mask_pass = S0.u64 &amp; EXEC; mask_fail = ~S0.u64 &amp;
EXEC; if(mask_pass == EXEC) then PC = S1.u64;
elsif(mask_fail == EXEC) then PC += 4;
elsif(bitcount(mask_fail) &lt; bitcount(mask_pass))
EXEC = mask_fail; SGPR[CSP*4] = { S1.u64,
mask_pass }; CSP += 1; PC += 4; else EXEC =
mask_pass; SGPR[CSP*4] = { PC + 4, mask_fail };
CSP += 1; PC = S1.u64; endif. Conditional branch
using branch-stack. S0 = compare mask(vcc or any
sgpr) and S1 = 64-bit byte address of target
instruction. See also S_CBRANCH_JOIN.</td>
</tr>
<tr class="row-even"><td>42</td>
<td>S_ABSDIFF_I3
2</td>
<td>D.i = S0.i - S1.i; if(D.i &lt; 0) then D.i = -D.i;
endif; SCC = (D.i != 0). Compute the absolute
value of difference between two values. Examples:
S_ABSDIFF_I32(0x00000002, 0x00000005) =&gt;
0x00000003 S_ABSDIFF_I32(0xffffffff, 0x00000000)
=&gt; 0x00000001 S_ABSDIFF_I32(0x80000000,
0x00000000) =&gt; 0x80000000 // Note: result is
negative! S_ABSDIFF_I32(0x80000000, 0x00000001)
=&gt; 0x7fffffff S_ABSDIFF_I32(0x80000000,
0xffffffff) =&gt; 0x7fffffff
S_ABSDIFF_I32(0x80000000, 0xfffffffe) =&gt;
0x7ffffffe</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>S_RFE_RESTOR
E_B64</td>
<td>PRIV = 0; PC = S0.u64. Return from exception
handler and continue. This instruction may only be
used within a trap handler. This instruction is
provided for compatibility with older ASICs. New
shader code must use S_RFE_B64. The second
argument is ignored.</td>
</tr>
<tr class="row-even"><td>44</td>
<td>S_MUL_HI_U3
2</td>
<td>D.u = (S0.u * S1.u) &gt;&gt; 32.</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>S_MUL_HI_I3
2</td>
<td>D.i = (S0.i * S1.i) &gt;&gt; 32.</td>
</tr>
<tr class="row-even"><td>46</td>
<td>S_LSHL1_ADD_U32</td>
<td>D.u = (S0.u &lt;&lt; 1) + S1.u; SCC = (((S0.u &lt;&lt; 1) +
S1.u) &gt;= 0x100000000ULL ? 1 : 0). // unsigned
overflow.</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>S_LSHL2_ADD_U32</td>
<td>D.u = (S0.u &lt;&lt; 2) + S1.u; SCC = (((S0.u &lt;&lt; 2) +
S1.u) &gt;= 0x100000000ULL ? 1 : 0). // unsigned
overflow.</td>
</tr>
<tr class="row-even"><td>48</td>
<td>S_LSHL3_ADD_U32</td>
<td>D.u = (S0.u &lt;&lt; 3) + S1.u; SCC = (((S0.u &lt;&lt; 3) +
S1.u) &gt;= 0x100000000ULL ? 1 : 0). // unsigned
overflow.</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>S_LSHL4_ADD_U32</td>
<td>D.u = (S0.u &lt;&lt; 4) + S1.u; SCC = (((S0.u &lt;&lt; 4) +
S1.u) &gt;= 0x100000000ULL ? 1 : 0). // unsigned
overflow.</td>
</tr>
<tr class="row-even"><td>50</td>
<td>S_PACK_LL_B
32_B16</td>
<td>D.u[31:0] = { S1.u[15:0], S0.u[15:0] }.</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>S_PACK_LH_B
32_B16</td>
<td>D.u[31:0] = { S1.u[31:16], S0.u[15:0] }.</td>
</tr>
<tr class="row-even"><td>52</td>
<td>S_PACK_HH_B
32_B16</td>
<td>D.u[31:0] = { S1.u[31:16], S0.u[31:16] }.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sopk-instructions">
<h3>SOPK Instructions<a class="headerlink" href="#sopk-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode sopk" src="../_images/microcode_sopk.png" /></p>
<p>Instructions in this format may use a 32-bit literal constant which
occurs immediately after the instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_MOVK_I32</td>
<td>D.i = signext(SIMM16). Sign extension from a
16-bit constant.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_CMOVK_I32</td>
<td>if(SCC) then D.i = signext(SIMM16); endif.
Conditional move with sign extension.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_CMPK_EQ_I
32</td>
<td>SCC = (S0.i == signext(SIMM16)).</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_CMPK_LG_I
32</td>
<td>SCC = (S0.i != signext(SIMM16)).</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_CMPK_GT_I
32</td>
<td>SCC = (S0.i &gt; signext(SIMM16)).</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_CMPK_GE_I
32</td>
<td>SCC = (S0.i &gt;= signext(SIMM16)).</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_CMPK_LT_I
32</td>
<td>SCC = (S0.i &lt; signext(SIMM16)).</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_CMPK_LE_I
32</td>
<td>SCC = (S0.i &lt;= signext(SIMM16)).</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_CMPK_EQ_U
32</td>
<td>SCC = (S0.u == SIMM16).</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_CMPK_LG_U
32</td>
<td>SCC = (S0.u != SIMM16).</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_CMPK_GT_U
32</td>
<td>SCC = (S0.u &gt; SIMM16).</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_CMPK_GE_U
32</td>
<td>SCC = (S0.u &gt;= SIMM16).</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_CMPK_LT_U
32</td>
<td>SCC = (S0.u &lt; SIMM16).</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_CMPK_LE_U
32</td>
<td>SCC = (S0.u &lt;= SIMM16).</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_ADDK_I32</td>
<td>tmp = D.i; // save value so we can check sign bits
for overflow later. D.i = D.i + signext(SIMM16);
SCC = (tmp[31] == SIMM16[15] &amp;&amp; tmp[31] !=
D.i[31]). // signed overflow.</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_MULK_I32</td>
<td>D.i = D.i * signext(SIMM16).</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_CBRANCH_I_FORK</td>
<td>mask_pass = S0.u64 &amp; EXEC; mask_fail = ~S0.u64 &amp;
EXEC; target_addr = PC + signext(SIMM16 * 4) +
4; if(mask_pass == EXEC) PC = target_addr;
elsif(mask_fail == EXEC) PC += 4;
elsif(bitcount(mask_fail) &lt; bitcount(mask_pass))
EXEC = mask_fail; SGPR[CSP*4] = { target_addr,
mask_pass }; CSP += 1; PC += 4; else EXEC =
mask_pass; SGPR[CSP*4] = { PC + 4, mask_fail };
CSP += 1; PC = target_addr; endif. Conditional
branch using branch-stack. S0 = compare mask(vcc
or any sgpr), and SIMM16 = signed DWORD branch
offset relative to next instruction. See also
S_CBRANCH_JOIN.</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_GETREG_B32</td>
<td>D.u = hardware-reg. Read some or all of a hardware
register into the LSBs of D. SIMM16 = {size[4:0],
offset[4:0], hwRegId[5:0]}; offset is 0..31, size
is 1..32.</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_SETREG_B32</td>
<td>hardware-reg = S0.u. Write some or all of the LSBs
of D into a hardware register. SIMM16 =
{size[4:0], offset[4:0], hwRegId[5:0]}; offset is
0..31, size is 1..32.</td>
</tr>
<tr class="row-odd"><td>20</td>
<td>S_SETREG_IMM
32_B32</td>
<td>Write some or all of the LSBs of IMM32 into a
hardware register; this instruction requires a
32-bit literal constant. SIMM16 = {size[4:0],
offset[4:0], hwRegId[5:0]}; offset is 0..31, size
is 1..32.</td>
</tr>
<tr class="row-even"><td>21</td>
<td>S_CALL_B64</td>
<td>D.u64 = PC + 4; PC = PC + signext(SIMM16 * 4) +
4. Implements a short call, where the return
address (the next instruction after the
S_CALL_B64) is saved to D. Long calls should
consider S_SWAPPC_B64 instead. Note that this
instruction is always 4 bytes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sop1-instructions">
<h3>SOP1 Instructions<a class="headerlink" href="#sop1-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode sop1" src="../_images/microcode_sop1.png" /></p>
<p>Instructions in this format may use a 32-bit literal constant which
occurs immediately after the instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_MOV_B32</td>
<td>D.u = S0.u.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_MOV_B64</td>
<td>D.u64 = S0.u64.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_CMOV_B32</td>
<td>if(SCC) then D.u = S0.u; endif. Conditional move.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_CMOV_B64</td>
<td>if(SCC) then D.u64 = S0.u64; endif. Conditional
move.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_NOT_B32</td>
<td>D = ~S0; SCC = (D != 0). Bitwise negation.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_NOT_B64</td>
<td>D = ~S0; SCC = (D != 0). Bitwise negation.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_WQM_B32</td>
<td>for i in 0 … opcode_size_in_bits - 1 do D[i]
= (S0[(i &amp; ~3):(i | 3)] != 0); endfor; SCC = (D
!= 0). Computes whole quad mode for an
active/valid mask. If any pixel in a quad is
active, all pixels of the quad are marked active.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_WQM_B64</td>
<td>for i in 0 … opcode_size_in_bits - 1 do D[i]
= (S0[(i &amp; ~3):(i | 3)] != 0); endfor; SCC = (D
!= 0). Computes whole quad mode for an
active/valid mask. If any pixel in a quad is
active, all pixels of the quad are marked active.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_BREV_B32</td>
<td>D.u[31:0] = S0.u[0:31]. Reverse bits.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_BREV_B64</td>
<td>D.u64[63:0] = S0.u64[0:63]. Reverse bits.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_BCNT0_I32_B32</td>
<td>D = 0; for i in 0 … opcode_size_in_bits - 1
do D += (S0[i] == 0 ? 1 : 0) endfor; SCC = (D !=
0). Examples: S_BCNT0_I32_B32(0x00000000) =&gt; 32
S_BCNT0_I32_B32(0xcccccccc) =&gt; 16
S_BCNT0_I32_B32(0xffffffff) =&gt; 0</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_BCNT0_I32_B64</td>
<td>D = 0; for i in 0 … opcode_size_in_bits - 1
do D += (S0[i] == 0 ? 1 : 0) endfor; SCC = (D !=
0). Examples: S_BCNT0_I32_B32(0x00000000) =&gt; 32
S_BCNT0_I32_B32(0xcccccccc) =&gt; 16
S_BCNT0_I32_B32(0xffffffff) =&gt; 0</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_BCNT1_I32_B32</td>
<td>D = 0; for i in 0 … opcode_size_in_bits - 1
do D += (S0[i] == 1 ? 1 : 0) endfor; SCC = (D !=
0). Examples: S_BCNT1_I32_B32(0x00000000) =&gt; 0
S_BCNT1_I32_B32(0xcccccccc) =&gt; 16
S_BCNT1_I32_B32(0xffffffff) =&gt; 32</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_BCNT1_I32_B64</td>
<td>D = 0; for i in 0 … opcode_size_in_bits - 1
do D += (S0[i] == 1 ? 1 : 0) endfor; SCC = (D !=
0). Examples: S_BCNT1_I32_B32(0x00000000) =&gt; 0
S_BCNT1_I32_B32(0xcccccccc) =&gt; 16
S_BCNT1_I32_B32(0xffffffff) =&gt; 32</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_FF0_I32_B
32</td>
<td>D.i = -1; // Set if no zeros are found for i in 0
… opcode_size_in_bits - 1 do // Search from
LSB if S0[i] == 0 then D.i = i; break for; endif;
endfor. Returns the bit position of the first zero
from the LSB, or -1 if there are no zeros.
Examples: S_FF0_I32_B32(0xaaaaaaaa) =&gt; 0
S_FF0_I32_B32(0x55555555) =&gt; 1
S_FF0_I32_B32(0x00000000) =&gt; 0
S_FF0_I32_B32(0xffffffff) =&gt; 0xffffffff
S_FF0_I32_B32(0xfffeffff) =&gt; 16</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_FF0_I32_B
64</td>
<td>D.i = -1; // Set if no zeros are found for i in 0
… opcode_size_in_bits - 1 do // Search from
LSB if S0[i] == 0 then D.i = i; break for; endif;
endfor. Returns the bit position of the first zero
from the LSB, or -1 if there are no zeros.
Examples: S_FF0_I32_B32(0xaaaaaaaa) =&gt; 0
S_FF0_I32_B32(0x55555555) =&gt; 1
S_FF0_I32_B32(0x00000000) =&gt; 0
S_FF0_I32_B32(0xffffffff) =&gt; 0xffffffff
S_FF0_I32_B32(0xfffeffff) =&gt; 16</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_FF1_I32_B
32</td>
<td>D.i = -1; // Set if no ones are found for i in 0
… opcode_size_in_bits - 1 do // Search from
LSB if S0[i] == 1 then D.i = i; break for; endif;
endfor. Returns the bit position of the first one
from the LSB, or -1 if there are no ones.
Examples: S_FF1_I32_B32(0xaaaaaaaa) =&gt; 1
S_FF1_I32_B32(0x55555555) =&gt; 0
S_FF1_I32_B32(0x00000000) =&gt; 0xffffffff
S_FF1_I32_B32(0xffffffff) =&gt; 0
S_FF1_I32_B32(0x00010000) =&gt; 16</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_FF1_I32_B
64</td>
<td>D.i = -1; // Set if no ones are found for i in 0
… opcode_size_in_bits - 1 do // Search from
LSB if S0[i] == 1 then D.i = i; break for; endif;
endfor. Returns the bit position of the first one
from the LSB, or -1 if there are no ones.
Examples: S_FF1_I32_B32(0xaaaaaaaa) =&gt; 1
S_FF1_I32_B32(0x55555555) =&gt; 0
S_FF1_I32_B32(0x00000000) =&gt; 0xffffffff
S_FF1_I32_B32(0xffffffff) =&gt; 0
S_FF1_I32_B32(0x00010000) =&gt; 16</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_FLBIT_I32_B32</td>
<td>D.i = -1; // Set if no ones are found for i in 0
… opcode_size_in_bits - 1 do // Note: search
is from the MSB if S0[opcode_size_in_bits - 1 -
i] == 1 then D.i = i; break for; endif; endfor.
Counts how many zeros before the first one
starting from the MSB. Returns -1 if there are no
ones. Examples: S_FLBIT_I32_B32(0x00000000) =&gt;
0xffffffff S_FLBIT_I32_B32(0x0000cccc) =&gt; 16
S_FLBIT_I32_B32(0xffff3333) =&gt; 0
S_FLBIT_I32_B32(0x7fffffff) =&gt; 1
S_FLBIT_I32_B32(0x80000000) =&gt; 0
S_FLBIT_I32_B32(0xffffffff) =&gt; 0</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_FLBIT_I32_B64</td>
<td>D.i = -1; // Set if no ones are found for i in 0
… opcode_size_in_bits - 1 do // Note: search
is from the MSB if S0[opcode_size_in_bits - 1 -
i] == 1 then D.i = i; break for; endif; endfor.
Counts how many zeros before the first one
starting from the MSB. Returns -1 if there are no
ones. Examples: S_FLBIT_I32_B32(0x00000000) =&gt;
0xffffffff S_FLBIT_I32_B32(0x0000cccc) =&gt; 16
S_FLBIT_I32_B32(0xffff3333) =&gt; 0
S_FLBIT_I32_B32(0x7fffffff) =&gt; 1
S_FLBIT_I32_B32(0x80000000) =&gt; 0
S_FLBIT_I32_B32(0xffffffff) =&gt; 0</td>
</tr>
<tr class="row-even"><td>20</td>
<td>S_FLBIT_I32</td>
<td>D.i = -1; // Set if all bits are the same for i in
1 … opcode_size_in_bits - 1 do // Note:
search is from the MSB if
S0[opcode_size_in_bits - 1 - i] !=
S0[opcode_size_in_bits - 1] then D.i = i; break
for; endif; endfor. Counts how many bits in a row
(from MSB to LSB) are the same as the sign bit.
Returns -1 if all bits are the same. Examples:
S_FLBIT_I32(0x00000000) =&gt; 0xffffffff
S_FLBIT_I32(0x0000cccc) =&gt; 16
S_FLBIT_I32(0xffff3333) =&gt; 16
S_FLBIT_I32(0x7fffffff) =&gt; 1
S_FLBIT_I32(0x80000000) =&gt; 1
S_FLBIT_I32(0xffffffff) =&gt; 0xffffffff</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>S_FLBIT_I32_I64</td>
<td>D.i = -1; // Set if all bits are the same for i in
1 … opcode_size_in_bits - 1 do // Note:
search is from the MSB if
S0[opcode_size_in_bits - 1 - i] !=
S0[opcode_size_in_bits - 1] then D.i = i; break
for; endif; endfor. Counts how many bits in a row
(from MSB to LSB) are the same as the sign bit.
Returns -1 if all bits are the same. Examples:
S_FLBIT_I32(0x00000000) =&gt; 0xffffffff
S_FLBIT_I32(0x0000cccc) =&gt; 16
S_FLBIT_I32(0xffff3333) =&gt; 16
S_FLBIT_I32(0x7fffffff) =&gt; 1
S_FLBIT_I32(0x80000000) =&gt; 1
S_FLBIT_I32(0xffffffff) =&gt; 0xffffffff</td>
</tr>
<tr class="row-even"><td>22</td>
<td>S_SEXT_I32_
I8</td>
<td>D.i = signext(S0.i[7:0]). Sign extension.</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>S_SEXT_I32_
I16</td>
<td>D.i = signext(S0.i[15:0]). Sign extension.</td>
</tr>
<tr class="row-even"><td>24</td>
<td>S_BITSET0_B3
2</td>
<td>D.u[S0.u[4:0]] = 0.</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>S_BITSET0_B6
4</td>
<td>D.u64[S0.u[5:0]] = 0.</td>
</tr>
<tr class="row-even"><td>26</td>
<td>S_BITSET1_B3
2</td>
<td>D.u[S0.u[4:0]] = 1.</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>S_BITSET1_B6
4</td>
<td>D.u64[S0.u[5:0]] = 1.</td>
</tr>
<tr class="row-even"><td>28</td>
<td>S_GETPC_B64</td>
<td>D.u64 = PC + 4. Destination receives the byte
address of the next instruction. Note that this
instruction is always 4 bytes.</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>S_SETPC_B64</td>
<td>PC = S0.u64. S0.u64 is a byte address of the
instruction to jump to.</td>
</tr>
<tr class="row-even"><td>30</td>
<td>S_SWAPPC_B64</td>
<td>D.u64 = PC + 4; PC = S0.u64. S0.u64 is a byte
address of the instruction to jump to. Destination
receives the byte address of the instruction
immediately following the SWAPPC instruction. Note
that this instruction is always 4 bytes.</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>S_RFE_B64</td>
<td>PRIV = 0; PC = S0.u64. Return from exception
handler and continue. This instruction may only be
used within a trap handler.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>S_AND_SAVEEX
EC_B64</td>
<td>D.u64 = EXEC; EXEC = S0.u64 &amp; EXEC; SCC = (EXEC !=
0).</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>S_OR_SAVEEXE
C_B64</td>
<td>D.u64 = EXEC; EXEC = S0.u64 | EXEC; SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-even"><td>34</td>
<td>S_XOR_SAVEEX
EC_B64</td>
<td>D.u64 = EXEC; EXEC = S0.u64 ^ EXEC; SCC = (EXEC !=
0).</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>S_ANDN2_SAVE
EXEC_B64</td>
<td>D.u64 = EXEC; EXEC = S0.u64 &amp; ~EXEC; SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-even"><td>36</td>
<td>S_ORN2_SAVEE
XEC_B64</td>
<td>D.u64 = EXEC; EXEC = S0.u64 | ~EXEC; SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>S_NAND_SAVEE
XEC_B64</td>
<td>D.u64 = EXEC; EXEC = ~(S0.u64 &amp; EXEC); SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-even"><td>38</td>
<td>S_NOR_SAVEEX
EC_B64</td>
<td>D.u64 = EXEC; EXEC = ~(S0.u64 | EXEC); SCC =
(EXEC != 0).</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>S_XNOR_SAVEE
XEC_B64</td>
<td>D.u64 = EXEC; EXEC = ~(S0.u64 ^ EXEC); SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-even"><td>40</td>
<td>S_QUADMASK_B
32</td>
<td>D = 0; for i in 0 … (opcode_size_in_bits / 4)
- 1 do D[i] = (S0[i * 4 + 3:i * 4] != 0);
endfor; SCC = (D != 0). Reduce a pixel mask to a
quad mask. To perform the inverse operation see
S_BITREPLICATE_B64_B32.</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>S_QUADMASK_B
64</td>
<td>D = 0; for i in 0 … (opcode_size_in_bits / 4)
- 1 do D[i] = (S0[i * 4 + 3:i * 4] != 0);
endfor; SCC = (D != 0). Reduce a pixel mask to a
quad mask. To perform the inverse operation see
S_BITREPLICATE_B64_B32.</td>
</tr>
<tr class="row-even"><td>42</td>
<td>S_MOVRELS_B3
2</td>
<td>addr = SGPR address appearing in instruction SRC0
field; addr += M0.u; D.u = SGPR[addr].u. Move from
a relative source address. For example, the
following instruction sequence will perform a move
s5 &lt;== s17: s_mov_b32 m0, 10 s_movrels_b32 s5,
s7</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>S_MOVRELS_B6
4</td>
<td>addr = SGPR address appearing in instruction SRC0
field; addr += M0.u; D.u64 = SGPR[addr].u64. Move
from a relative source address. The index in M0.u
must be even for this operation.</td>
</tr>
<tr class="row-even"><td>44</td>
<td>S_MOVRELD_B3
2</td>
<td>addr = SGPR address appearing in instruction DST
field; addr += M0.u; SGPR[addr].u = S0.u. Move to
a relative destination address. For example, the
following instruction sequence will perform a move
s15 &lt;== s7: s_mov_b32 m0, 10 s_movreld_b32 s5,
s7</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>S_MOVRELD_B6
4</td>
<td>addr = SGPR address appearing in instruction DST
field; addr += M0.u; SGPR[addr].u64 = S0.u64. Move
to a relative destination address. The index in
M0.u must be even for this operation.</td>
</tr>
<tr class="row-even"><td>46</td>
<td>S_CBRANCH_JO
IN</td>
<td>saved_csp = S0.u; if(CSP == saved_csp) then PC
+= 4; // Second time to JOIN: continue with
program. else CSP -= 1; // First time to JOIN;
jump to other FORK path. {PC, EXEC} = SGPR[CSP *
4]; // Read 128 bits from 4 consecutive SGPRs.
endif. Conditional branch join point (end of
conditional branch block). S0 is saved CSP value.
See S_CBRANCH_G_FORK and S_CBRANCH_I_FORK
for related instructions.</td>
</tr>
<tr class="row-odd"><td>48</td>
<td>S_ABS_I32</td>
<td>D.i = (S.i &lt; 0 ? -S.i : S.i); SCC = (D.i != 0).
Integer absolute value. Examples:
S_ABS_I32(0x00000001) =&gt; 0x00000001
S_ABS_I32(0x7fffffff) =&gt; 0x7fffffff
S_ABS_I32(0x80000000) =&gt; 0x80000000 // Note this
is negative! S_ABS_I32(0x80000001) =&gt; 0x7fffffff
S_ABS_I32(0x80000002) =&gt; 0x7ffffffe
S_ABS_I32(0xffffffff) =&gt; 0x00000001</td>
</tr>
<tr class="row-even"><td>50</td>
<td>S_SET_GPR_I
DX_IDX</td>
<td>M0[7:0] = S0.u[7:0]. Modify the index used in
vector GPR indexing. S_SET_GPR_IDX_ON,
S_SET_GPR_IDX_OFF, S_SET_GPR_IDX_MODE and
S_SET_GPR_IDX_IDX are related instructions.</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>S_ANDN1_SAVE
EXEC_B64</td>
<td>D.u64 = EXEC; EXEC = ~S0.u64 &amp; EXEC; SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-even"><td>52</td>
<td>S_ORN1_SAVEE
XEC_B64</td>
<td>D.u64 = EXEC; EXEC = ~S0.u64 | EXEC; SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>S_ANDN1_WREX
EC_B64</td>
<td>EXEC = ~S0.u64 &amp; EXEC; D.u64 = EXEC; SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-even"><td>54</td>
<td>S_ANDN2_WREX
EC_B64</td>
<td>EXEC = S0.u64 &amp; ~EXEC; D.u64 = EXEC; SCC = (EXEC
!= 0).</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>S_BITREPLICAT
E_B64_B32</td>
<td>for i in 0 … 31 do D.u64[i * 2 + 0] = S0.u32[i]
D.u64[i * 2 + 1] = S0.u32[i] endfor. Replicate
the low 32 bits of S0 by ‘doubling’ each bit. This
opcode can be used to convert a quad mask into a
pixel mask; given quad mask in s0, the following
sequence will produce a pixel mask in s1:
s_bitreplicate_b64 s1, s0 s_bitreplicate_b64
s1, s1 To perform the inverse operation see
S_QUADMASK_B64.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sopc-instructions">
<h3>SOPC Instructions<a class="headerlink" href="#sopc-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode sopc" src="../_images/microcode_sopc.png" /></p>
<p>Instructions in this format may use a 32-bit literal constant which
occurs immediately after the instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_CMP_EQ_I3
2</td>
<td>SCC = (S0 == S1). Note that S_CMP_EQ_I32 and
S_CMP_EQ_U32 are identical opcodes, but both
are provided for symmetry.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_CMP_LG_I3
2</td>
<td>SCC = (S0 != S1). Note that S_CMP_LG_I32 and
S_CMP_LG_U32 are identical opcodes, but both
are provided for symmetry.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_CMP_GT_I3
2</td>
<td>SCC = (S0.i &gt; S1.i).</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_CMP_GE_I3
2</td>
<td>SCC = (S0.i &gt;= S1.i).</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_CMP_LT_I3
2</td>
<td>SCC = (S0.i &lt; S1.i).</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_CMP_LE_I3
2</td>
<td>SCC = (S0.i &lt;= S1.i).</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_CMP_EQ_U3
2</td>
<td>SCC = (S0 == S1). Note that S_CMP_EQ_I32 and
S_CMP_EQ_U32 are identical opcodes, but both
are provided for symmetry.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_CMP_LG_U3
2</td>
<td>SCC = (S0 != S1). Note that S_CMP_LG_I32 and
S_CMP_LG_U32 are identical opcodes, but both
are provided for symmetry.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_CMP_GT_U3
2</td>
<td>SCC = (S0.u &gt; S1.u).</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_CMP_GE_U3
2</td>
<td>SCC = (S0.u &gt;= S1.u).</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_CMP_LT_U3
2</td>
<td>SCC = (S0.u &lt; S1.u).</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_CMP_LE_U3
2</td>
<td>SCC = (S0.u &lt;= S1.u).</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_BITCMP0_B3
2</td>
<td>SCC = (S0.u[S1.u[4:0]] == 0).</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_BITCMP1_B3
2</td>
<td>SCC = (S0.u[S1.u[4:0]] == 1).</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_BITCMP0_B6
4</td>
<td>SCC = (S0.u64[S1.u[5:0]] == 0).</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_BITCMP1_B6
4</td>
<td>SCC = (S0.u64[S1.u[5:0]] == 1).</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_SETVSKIP</td>
<td>VSKIP = S0.u[S1.u[4:0]]. Enables and disables
VSKIP mode. When VSKIP is enabled, no
VOP*/M*BUF/MIMG/DS/FLAT/EXP instuctions are
issued. Note that VSKIPped memory instructions do
not manipulate the waitcnt counters; as a result,
if you have outstanding memory requests you may
want to issue S_WAITCNT 0 prior to enabling
VSKIP, otherwise you’ll need to be careful not to
count VSKIPped instructions in your waitcnt
calculations. Examples: s_setvskip 1, 0 // Enable
vskip mode. s_setvskip 0, 0 // Disable vskip
mode.</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_SET_GPR_I
DX_ON</td>
<td>MODE.gpr_idx_en = 1; M0[7:0] = S0.u[7:0];
M0[15:12] = SIMM4; // this is the direct content
of S1 field // Remaining bits of M0 are
unmodified. Enable GPR indexing mode. Vector
operations after this will perform relative GPR
addressing based on the contents of M0. The
structure SQ_M0_GPR_IDX_WORD may be used to
decode M0. The raw contents of the S1 field are
read and used to set the enable bits. S1[0] =
VSRC0_REL, S1[1] = VSRC1_REL, S1[2] = VSRC2_REL
and S1[3] = VDST_REL. S_SET_GPR_IDX_ON,
S_SET_GPR_IDX_OFF, S_SET_GPR_IDX_MODE and
S_SET_GPR_IDX_IDX are related instructions.</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_CMP_EQ_U6
4</td>
<td>SCC = (S0.i64 == S1.i64).</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_CMP_LG_U6
4</td>
<td>SCC = (S0.i64 != S1.i64).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sopp-instructions">
<h3>SOPP Instructions<a class="headerlink" href="#sopp-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode sopp" src="../_images/microcode_sopp.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="24%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_NOP</td>
<td>Do nothing. Repeat NOP 1..16 times based on
SIMM16[3:0] – 0x0 = 1 time, 0xf = 16 times.
This instruction may be used to introduce wait
states to resolve hazards. Compare with
S_SLEEP.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_ENDPGM</td>
<td>End of program; terminate wavefront. The
hardware implicitly executes S_WAITCNT 0 before
executing this instruction. See S_ENDPGM_SAVED
for the context-switch version of this
instruction and S_ENDPGM_ORDERED_PS_DONE for
the POPS critical region version of this
instruction.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_BRANCH</td>
<td>PC = PC + signext(SIMM16 * 4) + 4. // short
jump. For a long jump, use S_SETPC_B64.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_WAKEUP</td>
<td>Allow a wave to ‘ping’ all the other waves in
its threadgroup to force them to wake up
immediately from an S_SLEEP instruction. The
ping is ignored if the waves are not sleeping.
This allows for efficient polling on a memory
location. The waves which are polling can sit in
a long S_SLEEP between memory reads, but the
wave which writes the value can tell them all to
wake up early now that the data is available.
This is useful for fBarrier implementations
(speedup). This method is also safe from races
because if any wave misses the ping, everything
still works fine (waves which missed it just
completes their normal S_SLEEP). If the wave
executing S_WAKEUP is in a threadgroup (in_tg
set), then it will wake up all waves associated
with the same threadgroup ID. Otherwise,
S_WAKEUP is treated as an S_NOP.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_CBRANCH_SCC0</td>
<td>if(SCC == 0) then PC = PC + signext(SIMM16 * 4)
+ 4; endif.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_CBRANCH_SCC1</td>
<td>if(SCC == 1) then PC = PC + signext(SIMM16 * 4)
+ 4; endif.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_CBRANCH_VCCZ</td>
<td>if(VCC == 0) then PC = PC + signext(SIMM16 * 4)
+ 4; endif.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_CBRANCH_VCCN
Z</td>
<td>if(VCC != 0) then PC = PC + signext(SIMM16 * 4)
+ 4; endif.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_CBRANCH_EXEC
Z</td>
<td>if(EXEC == 0) then PC = PC + signext(SIMM16 *
4) + 4; endif.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_CBRANCH_EXEC
NZ</td>
<td>if(EXEC != 0) then PC = PC + signext(SIMM16 *
4) + 4; endif.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_BARRIER</td>
<td>Synchronize waves within a threadgroup. If not
all waves of the threadgroup have been created
yet, waits for entire group before proceeding.
If some waves in the threadgroup have already
terminated, this waits on only the surviving
waves. Barriers are legal inside trap handlers.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_SETKILL</td>
<td>Set KILL bit to value of SIMM16[0]. Used
primarily for debugging kill wave host command
behavior.</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_WAITCNT</td>
<td>Wait for the counts of outstanding lds,
vector-memory and export/vmem-write-data to be
at or below the specified levels. SIMM16[3:0] =
vmcount (vector memory operations) lower bits
[3:0], SIMM16[6:4] = export/mem-write-data
count, SIMM16[11:8] = LGKM_cnt
(scalar-mem/GDS/LDS count), SIMM16[15:14] =
vmcount (vector memory operations) upper bits
[5:4],</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_SETHALT</td>
<td>Set HALT bit to value of SIMM16[0]; 1 = halt, 0
= resume. The halt flag is ignored while PRIV ==
1 (inside trap handlers) but the shader will
halt immediately after the handler returns if
HALT is still set at that time.</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_SLEEP</td>
<td>Cause a wave to sleep for (64 * SIMM16[6:0] +
1..64) clocks. The exact amount of delay is
approximate. Compare with S_NOP.</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_SETPRIO</td>
<td>User settable wave priority is set to
SIMM16[1:0]. 0 = lowest, 3 = highest. The
overall wave priority is {SPIPrio[1:0] +
UserPrio[1:0], WaveAge[3:0]}.</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_SENDMSG</td>
<td>Send a message upstream to VGT or the interrupt
handler. SIMM16[9:0] contains the message type.</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_SENDMSGHALT</td>
<td>Send a message and then HALT the wavefront; see
S_SENDMSG for details.</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_TRAP</td>
<td>TrapID = SIMM16[7:0]; Wait for all instructions
to complete; {TTMP1, TTMP0} = {3’h0,
PCRewind[3:0], HT[0], TrapID[7:0], PC[47:0]}; PC
= TBA; // trap base address PRIV = 1. Enter the
trap handler. This instruction may be generated
internally as well in response to a host trap
(HT = 1) or an exception. TrapID 0 is reserved
for hardware use and should not be used in a
shader-generated trap.</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_ICACHE_INV</td>
<td>Invalidate entire L1 instruction cache. You must
have 16 separate S_NOP instructions or a
jump/branch instruction after this instruction
to ensure the SQ instruction buffer is purged.
NOTE: The number of S_NOPs required depends on
the size of the shader instruction buffer, which
in current generations is 16 DWORDs long. Older
architectures had a 12 DWORD instruction buffer
and in those architectures, 12 S_NOP
instructions were sufficient.</td>
</tr>
<tr class="row-even"><td>20</td>
<td>S_INCPERFLEVEL</td>
<td>Increment performance counter specified in
SIMM16[3:0] by 1.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>S_DECPERFLEVEL</td>
<td>Decrement performance counter specified in
SIMM16[3:0] by 1.</td>
</tr>
<tr class="row-even"><td>22</td>
<td>S_TTRACEDATA</td>
<td>Send M0 as user data to the thread trace stream.</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>S_CBRANCH_CDBG
SYS</td>
<td>if(conditional_debug_system != 0) then PC = PC
+ signext(SIMM16 * 4) + 4; endif.</td>
</tr>
<tr class="row-even"><td>24</td>
<td>S_CBRANCH_CDBG
USER</td>
<td>if(conditional_debug_user != 0) then PC = PC +
signext(SIMM16 * 4) + 4; endif.</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>S_CBRANCH_CDBG
SYS_OR_USER</td>
<td>if(conditional_debug_system ||
conditional_debug_user) then PC = PC +
signext(SIMM16 * 4) + 4; endif.</td>
</tr>
<tr class="row-even"><td>26</td>
<td>S_CBRANCH_CDBG
SYS_AND_USER</td>
<td>if(conditional_debug_system &amp;&amp;
conditional_debug_user) then PC = PC +
signext(SIMM16 * 4) + 4; endif.</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>S_ENDPGM_SAVED</td>
<td>End of program; signal that a wave has been
saved by the context-switch trap handler and
terminate wavefront. The hardware implicitly
executes S_WAITCNT 0 before executing this
instruction. See S_ENDPGM for additional
variants.</td>
</tr>
<tr class="row-even"><td>28</td>
<td>S_SET_GPR_IDX
_OFF</td>
<td>MODE.gpr_idx_en = 0. Clear GPR indexing mode.
Vector operations after this will not perform
relative GPR addressing regardless of the
contents of M0. This instruction does not modify
M0. S_SET_GPR_IDX_ON, S_SET_GPR_IDX_OFF,
S_SET_GPR_IDX_MODE and S_SET_GPR_IDX_IDX
are related instructions.</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>S_SET_GPR_IDX
_MODE</td>
<td>M0[15:12] = SIMM16[3:0]. Modify the mode used
for vector GPR indexing. The raw contents of the
source field are read and used to set the enable
bits. SIMM16[0] = VSRC0_REL, SIMM16[1] =
VSRC1_REL, SIMM16[2] = VSRC2_REL and SIMM16[3]
= VDST_REL. S_SET_GPR_IDX_ON,
S_SET_GPR_IDX_OFF, S_SET_GPR_IDX_MODE
and S_SET_GPR_IDX_IDX are related
instructions.</td>
</tr>
<tr class="row-even"><td>30</td>
<td>S_ENDPGM_ORDER
ED_PS_DONE</td>
<td>End of program; signal that a wave has exited
its POPS critical section and terminate
wavefront. The hardware implicitly executes
S_WAITCNT 0 before executing this instruction.
This instruction is an optimization that
combines S_SENDMSG(MSG_ORDERED_PS_DONE) and
S_ENDPGM; there may be cases where you still
need to send the message separately, in which
case you can end the shader with a normal
S_ENDPGM instruction. See S_ENDPGM for
additional variants.</td>
</tr>
</tbody>
</table>
<div class="section" id="send-message">
<h4>Send Message<a class="headerlink" href="#send-message" title="Permalink to this headline">¶</a></h4>
<p>The S_SENDMSG instruction encodes the message type in M0, and can also
send data from the SIMM16 field and in some cases from EXEC.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="15%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Message</th>
<th class="head">SIMM16[3:0
]</th>
<th class="head">SIMM16[6:4
]</th>
<th class="head">Payload</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>none</td>
<td>0</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>illegal</td>
</tr>
<tr class="row-odd"><td>GS</td>
<td>2</td>
<td>0=nop,
1=cut,
2=emit,
3=emit-cut</td>
<td>GS output. M0[4:0]=gs-waveID, SIMM[9:8] =
stream-id</td>
</tr>
<tr class="row-even"><td>GS-done</td>
<td>3</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>save wave</td>
<td>4</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>used in context switching</td>
</tr>
<tr class="row-even"><td>Stall Wave
Gen</td>
<td>5</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>stop new wave generation</td>
</tr>
<tr class="row-odd"><td>Halt Waves</td>
<td>6</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>halt all running waves of this vmid</td>
</tr>
<tr class="row-even"><td>Ordered PS
Done</td>
<td>7</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>POPS ordered section done</td>
</tr>
<tr class="row-odd"><td>Early Prim
Dealloc</td>
<td>8</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Deallocate primitives. This message is
optional. EXEC[N*12+10:N*12] = number
of verts to deallocate from buffer N
(N=0..3). Exec[58:48] = number of
vertices to deallocate.</td>
</tr>
<tr class="row-even"><td>GS alloc
req</td>
<td>9</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Request GS space in parameter cache.
M0[9:0] = number of vertices</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="smem-instructions">
<h3>SMEM Instructions<a class="headerlink" href="#smem-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode smem" src="../_images/microcode_smem.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="29%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_LOAD_DWORD</td>
<td>Read 1 dword from scalar data cache. If the
offset is specified as an SGPR, the SGPR
contains an UNSIGNED BYTE offset (the 2 LSBs
are ignored). If the offset is specified as
an immediate 21-bit constant, the constant is
a SIGNED BYTE offset.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_LOAD_DWORDX2</td>
<td>Read 2 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_LOAD_DWORDX4</td>
<td>Read 4 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_LOAD_DWORDX8</td>
<td>Read 8 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_LOAD_DWORDX16</td>
<td>Read 16 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_SCRATCH_LOAD_DW
ORD</td>
<td>Read 1 dword from scalar data cache. If the
offset is specified as an SGPR, the SGPR
contains an UNSIGNED 64-byte offset,
consistent with other scratch operations. If
the offset is specified as an immediate
21-bit constant, the constant is a SIGNED
BYTE offset.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_SCRATCH_LOAD_DW
ORDX2</td>
<td>Read 2 dwords from scalar data cache. See
S_SCRATCH_LOAD_DWORD for details on the
offset input.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_SCRATCH_LOAD_DW
ORDX4</td>
<td>Read 4 dwords from scalar data cache. See
S_SCRATCH_LOAD_DWORD for details on the
offset input.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_BUFFER_LOAD_DWO
RD</td>
<td>Read 1 dword from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_BUFFER_LOAD_DWO
RDX2</td>
<td>Read 2 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_BUFFER_LOAD_DWO
RDX4</td>
<td>Read 4 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_BUFFER_LOAD_DWO
RDX8</td>
<td>Read 8 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_BUFFER_LOAD_DWO
RDX16</td>
<td>Read 16 dwords from scalar data cache. See
S_LOAD_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>S_STORE_DWORD</td>
<td>Write 1 dword to scalar data cache. If the
offset is specified as an SGPR, the SGPR
contains an UNSIGNED BYTE offset (the 2 LSBs
are ignored). If the offset is specified as
an immediate 21-bit constant, the constant is
an SIGNED BYTE offset.</td>
</tr>
<tr class="row-even"><td>17</td>
<td>S_STORE_DWORDX2</td>
<td>Write 2 dwords to scalar data cache. See
S_STORE_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-odd"><td>18</td>
<td>S_STORE_DWORDX4</td>
<td>Write 4 dwords to scalar data cache. See
S_STORE_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-even"><td>21</td>
<td>S_SCRATCH_STORE_D
WORD</td>
<td>Write 1 dword from scalar data cache. If the
offset is specified as an SGPR, the SGPR
contains an UNSIGNED 64-byte offset,
consistent with other scratch operations. If
the offset is specified as an immediate
21-bit constant, the constant is a SIGNED
BYTE offset.</td>
</tr>
<tr class="row-odd"><td>22</td>
<td>S_SCRATCH_STORE_D
WORDX2</td>
<td>Write 2 dwords from scalar data cache. See
S_SCRATCH_STORE_DWORD for details on the
offset input.</td>
</tr>
<tr class="row-even"><td>23</td>
<td>S_SCRATCH_STORE_D
WORDX4</td>
<td>Write 4 dwords from scalar data cache. See
S_SCRATCH_STORE_DWORD for details on the
offset input.</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>S_BUFFER_STORE_DW
ORD</td>
<td>Write 1 dword to scalar data cache. See
S_STORE_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-even"><td>25</td>
<td>S_BUFFER_STORE_DW
ORDX2</td>
<td>Write 2 dwords to scalar data cache. See
S_STORE_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-odd"><td>26</td>
<td>S_BUFFER_STORE_DW
ORDX4</td>
<td>Write 4 dwords to scalar data cache. See
S_STORE_DWORD for details on the offset
input.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>S_DCACHE_INV</td>
<td>Invalidate the scalar data cache.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>S_DCACHE_WB</td>
<td>Write back dirty data in the scalar data
cache.</td>
</tr>
<tr class="row-even"><td>34</td>
<td>S_DCACHE_INV_VOL</td>
<td>Invalidate the scalar data cache volatile
lines.</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>S_DCACHE_WB_VOL</td>
<td>Write back dirty data in the scalar data
cache volatile lines.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>S_MEMTIME</td>
<td>Return current 64-bit timestamp.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>S_MEMREALTIME</td>
<td>Return current 64-bit RTC.</td>
</tr>
<tr class="row-even"><td>38</td>
<td>S_ATC_PROBE</td>
<td>Probe or prefetch an address into the SQC
data cache.</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>S_ATC_PROBE_BUFFE
R</td>
<td>Probe or prefetch an address into the SQC
data cache.</td>
</tr>
<tr class="row-even"><td>40</td>
<td>S_DCACHE_DISCARD</td>
<td>Discard one dirty scalar data cache line. A
cache line is 64 bytes. Normally, dirty
cachelines (one which have been written by
the shader) are written back to memory, but
this instruction allows the shader to
invalidate and not write back cachelines
which it has previously written. This is a
performance optimization to be used when the
shader knows it no longer needs that data.
Address is calculated the same as
S_STORE_DWORD, except the 6 LSBs are
ignored to get the 64 byte aligned address.
LGKM count is incremented by 1 for this
opcode.</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>S_DCACHE_DISCARD_
X2</td>
<td>Discard two consecutive dirty scalar data
cache lines. A cache line is 64 bytes.
Normally, dirty cachelines (one which have
been written by the shader) are written back
to memory, but this instruction allows the
shader to invalidate and not write back
cachelines which it has previously written.
This is a performance optimization to be used
when the shader knows it no longer needs that
data. Address is calculated the same as
S_STORE_DWORD, except the 6 LSBs are
ignored to get the 64 byte aligned address.
LGKM count is incremented by 2 for this
opcode.</td>
</tr>
<tr class="row-even"><td>64</td>
<td>S_BUFFER_ATOMIC_S
WAP</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>S_BUFFER_ATOMIC_C
MPSWAP</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp
= DATA[1]; MEM[ADDR] = (tmp == cmp) ? src :
tmp; RETURN_DATA[0] = tmp.</td>
</tr>
<tr class="row-even"><td>66</td>
<td>S_BUFFER_ATOMIC_A
DD</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>S_BUFFER_ATOMIC_S
UB</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>68</td>
<td>S_BUFFER_ATOMIC_S
MIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>S_BUFFER_ATOMIC_U
MIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>70</td>
<td>S_BUFFER_ATOMIC_S
MAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>S_BUFFER_ATOMIC_U
MAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>72</td>
<td>S_BUFFER_ATOMIC_A
ND</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>S_BUFFER_ATOMIC_O
R</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>74</td>
<td>S_BUFFER_ATOMIC_X
OR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>S_BUFFER_ATOMIC_I
NC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>76</td>
<td>S_BUFFER_ATOMIC_D
EC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp ==
0 || tmp &gt; DATA) ? DATA : tmp - 1; //
unsigned compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>S_BUFFER_ATOMIC_S
WAP_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] =
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>97</td>
<td>S_BUFFER_ATOMIC_C
MPSWAP_X2</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA[0:1];
cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>S_BUFFER_ATOMIC_A
DD_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>99</td>
<td>S_BUFFER_ATOMIC_S
UB_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>S_BUFFER_ATOMIC_S
MIN_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>101</td>
<td>S_BUFFER_ATOMIC_U
MIN_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>S_BUFFER_ATOMIC_S
MAX_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>103</td>
<td>S_BUFFER_ATOMIC_U
MAX_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>S_BUFFER_ATOMIC_A
ND_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>105</td>
<td>S_BUFFER_ATOMIC_O
R_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>S_BUFFER_ATOMIC_X
OR_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>107</td>
<td>S_BUFFER_ATOMIC_I
NC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA[0:1]) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>S_BUFFER_ATOMIC_D
EC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp ==
0 || tmp &gt; DATA[0:1]) ? DATA[0:1] : tmp -
1; // unsigned compare RETURN_DATA[0:1] =
tmp.</td>
</tr>
<tr class="row-even"><td>128</td>
<td>S_ATOMIC_SWAP</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>129</td>
<td>S_ATOMIC_CMPSWAP</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA[0]; cmp
= DATA[1]; MEM[ADDR] = (tmp == cmp) ? src :
tmp; RETURN_DATA[0] = tmp.</td>
</tr>
<tr class="row-even"><td>130</td>
<td>S_ATOMIC_ADD</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>131</td>
<td>S_ATOMIC_SUB</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>132</td>
<td>S_ATOMIC_SMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>133</td>
<td>S_ATOMIC_UMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>134</td>
<td>S_ATOMIC_SMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>135</td>
<td>S_ATOMIC_UMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>136</td>
<td>S_ATOMIC_AND</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>137</td>
<td>S_ATOMIC_OR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>138</td>
<td>S_ATOMIC_XOR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>139</td>
<td>S_ATOMIC_INC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>140</td>
<td>S_ATOMIC_DEC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp ==
0 || tmp &gt; DATA) ? DATA : tmp - 1; //
unsigned compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>160</td>
<td>S_ATOMIC_SWAP_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] =
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>161</td>
<td>S_ATOMIC_CMPSWAP_
X2</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA[0:1];
cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>162</td>
<td>S_ATOMIC_ADD_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>163</td>
<td>S_ATOMIC_SUB_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>164</td>
<td>S_ATOMIC_SMIN_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>165</td>
<td>S_ATOMIC_UMIN_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>166</td>
<td>S_ATOMIC_SMAX_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>167</td>
<td>S_ATOMIC_UMAX_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>168</td>
<td>S_ATOMIC_AND_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>169</td>
<td>S_ATOMIC_OR_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>170</td>
<td>S_ATOMIC_XOR_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>171</td>
<td>S_ATOMIC_INC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA[0:1]) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>172</td>
<td>S_ATOMIC_DEC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp ==
0 || tmp &gt; DATA[0:1]) ? DATA[0:1] : tmp -
1; // unsigned compare RETURN_DATA[0:1] =
tmp.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vop2-instructions">
<h3>VOP2 Instructions<a class="headerlink" href="#vop2-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode vop2" src="../_images/microcode_vop2.png" /></p>
<p>Instructions in this format may use a 32-bit literal constant which
occurs immediately after the instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="22%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>V_CNDMASK_B32</td>
<td>D.u = (VCC[threadId] ? S1.u : S0.u). Conditional
mask on each thread. In VOP3 the VCC source may
be a scalar GPR specified in S2.u.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>V_ADD_F32</td>
<td>D.f = S0.f + S1.f. 0.5ULP precision, denormals
are supported.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>V_SUB_F32</td>
<td>D.f = S0.f - S1.f.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>V_SUBREV_F32</td>
<td>D.f = S1.f - S0.f.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>V_MUL_LEGACY_F32</td>
<td>D.f = S0.f * S1.f. // DX9 rules, 0.0*x = 0.0</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>V_MUL_F32</td>
<td>D.f = S0.f * S1.f. 0.5ULP precision, denormals
are supported.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>V_MUL_I32_I2
4</td>
<td>D.i = S0.i[23:0] * S1.i[23:0].</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>V_MUL_HI_I32
_I24</td>
<td>D.i = (S0.i[23:0] * S1.i[23:0])&gt;&gt;32.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>V_MUL_U32_U2
4</td>
<td>D.u = S0.u[23:0] * S1.u[23:0].</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>V_MUL_HI_U32
_U24</td>
<td>D.i = (S0.u[23:0] * S1.u[23:0])&gt;&gt;32.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>V_MIN_F32</td>
<td>if (IEEE_MODE &amp;&amp; S0.f == sNaN) D.f =
Quiet(S0.f); else if (IEEE_MODE &amp;&amp; S1.f == sNaN)
D.f = Quiet(S1.f); else if (S0.f == NaN) D.f =
S1.f; else if (S1.f == NaN) D.f = S0.f; else if
(S0.f == +0.0 &amp;&amp; S1.f == -0.0) D.f = S1.f; else
if (S0.f == -0.0 &amp;&amp; S1.f == +0.0) D.f = S0.f;
else // Note: there’s no IEEE special case here
like there is for V_MAX_F32. D.f = (S0.f &lt; S1.f
? S0.f : S1.f); endif.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>V_MAX_F32</td>
<td>if (IEEE_MODE &amp;&amp; S0.f == sNaN) D.f =
Quiet(S0.f); else if (IEEE_MODE &amp;&amp; S1.f == sNaN)
D.f = Quiet(S1.f); else if (S0.f == NaN) D.f =
S1.f; else if (S1.f == NaN) D.f = S0.f; else if
(S0.f == +0.0 &amp;&amp; S1.f == -0.0) D.f = S0.f; else
if (S0.f == -0.0 &amp;&amp; S1.f == +0.0) D.f = S1.f;
else if (IEEE_MODE) D.f = (S0.f &gt;= S1.f ? S0.f :
S1.f); else D.f = (S0.f &gt; S1.f ? S0.f : S1.f);
endif.</td>
</tr>
<tr class="row-even"><td>12</td>
<td>V_MIN_I32</td>
<td>D.i = (S0.i &lt; S1.i ? S0.i : S1.i).</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>V_MAX_I32</td>
<td>D.i = (S0.i &gt;= S1.i ? S0.i : S1.i).</td>
</tr>
<tr class="row-even"><td>14</td>
<td>V_MIN_U32</td>
<td>D.u = (S0.u &lt; S1.u ? S0.u : S1.u).</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>V_MAX_U32</td>
<td>D.u = (S0.u &gt;= S1.u ? S0.u : S1.u).</td>
</tr>
<tr class="row-even"><td>16</td>
<td>V_LSHRREV_B32</td>
<td>D.u = S1.u &gt;&gt; S0.u[4:0].</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>V_ASHRREV_I32</td>
<td>D.i = signext(S1.i) &gt;&gt; S0.i[4:0].</td>
</tr>
<tr class="row-even"><td>18</td>
<td>V_LSHLREV_B32</td>
<td>D.u = S1.u &lt;&lt; S0.u[4:0].</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>V_AND_B32</td>
<td>D.u = S0.u &amp; S1.u. Input and output modifiers not
supported.</td>
</tr>
<tr class="row-even"><td>20</td>
<td>V_OR_B32</td>
<td>D.u = S0.u | S1.u. Input and output modifiers
not supported.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>V_XOR_B32</td>
<td>D.u = S0.u ^ S1.u. Input and output modifiers not
supported.</td>
</tr>
<tr class="row-even"><td>22</td>
<td>V_MAC_F32</td>
<td>D.f = S0.f * S1.f + D.f.</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>V_MADMK_F32</td>
<td>D.f = S0.f * K + S1.f. // K is a 32-bit literal
constant. This opcode cannot use the VOP3
encoding and cannot use input/output modifiers.</td>
</tr>
<tr class="row-even"><td>24</td>
<td>V_MADAK_F32</td>
<td>D.f = S0.f * S1.f + K. // K is a 32-bit literal
constant. This opcode cannot use the VOP3
encoding and cannot use input/output modifiers.</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>V_ADD_CO_U32</td>
<td>D.u = S0.u + S1.u; VCC[threadId] = (S0.u + S1.u
&gt;= 0x100000000ULL ? 1 : 0). // VCC is an UNSIGNED
overflow/carry-out for V_ADDC_CO_U32. In VOP3
the VCC destination may be an arbitrary
SGPR-pair.</td>
</tr>
<tr class="row-even"><td>26</td>
<td>V_SUB_CO_U32</td>
<td>D.u = S0.u - S1.u; VCC[threadId] = (S1.u &gt; S0.u ?
1 : 0). // VCC is an UNSIGNED overflow/carry-out
for V_SUBB_CO_U32. In VOP3 the VCC destination
may be an arbitrary SGPR-pair.</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>V_SUBREV_CO_
U32</td>
<td>D.u = S1.u - S0.u; VCC[threadId] = (S0.u &gt; S1.u ?
1 : 0). // VCC is an UNSIGNED overflow/carry-out
for V_SUBB_CO_U32. In VOP3 the VCC destination
may be an arbitrary SGPR-pair.</td>
</tr>
<tr class="row-even"><td>28</td>
<td>V_ADDC_CO_U3
2</td>
<td>D.u = S0.u + S1.u + VCC[threadId]; VCC[threadId]
= (S0.u + S1.u + VCC[threadId] &gt;= 0x100000000ULL
? 1 : 0). // VCC is an UNSIGNED overflow. In VOP3
the VCC destination may be an arbitrary
SGPR-pair, and the VCC source comes from the
SGPR-pair at S2.u.</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>V_SUBB_CO_U3
2</td>
<td>D.u = S0.u - S1.u - VCC[threadId]; VCC[threadId]
= (S1.u + VCC[threadId] &gt; S0.u ? 1 : 0). // VCC
is an UNSIGNED overflow. In VOP3 the VCC
destination may be an arbitrary SGPR-pair, and
the VCC source comes from the SGPR-pair at S2.u.</td>
</tr>
<tr class="row-even"><td>30</td>
<td>V_SUBBREV_CO_U32</td>
<td>D.u = S1.u - S0.u - VCC[threadId]; VCC[threadId]
= (S1.u + VCC[threadId] &gt; S0.u ? 1 : 0). // VCC
is an UNSIGNED overflow. In VOP3 the VCC
destination may be an arbitrary SGPR-pair, and
the VCC source comes from the SGPR-pair at S2.u.</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>V_ADD_F16</td>
<td>D.f16 = S0.f16 + S1.f16. Supports denormals,
round mode, exception flags, saturation. 0.5ULP
precision, denormals are supported.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>V_SUB_F16</td>
<td>D.f16 = S0.f16 - S1.f16. Supports denormals,
round mode, exception flags, saturation.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>V_SUBREV_F16</td>
<td>D.f16 = S1.f16 - S0.f16. Supports denormals,
round mode, exception flags, saturation.</td>
</tr>
<tr class="row-even"><td>34</td>
<td>V_MUL_F16</td>
<td>D.f16 = S0.f16 * S1.f16. Supports denormals,
round mode, exception flags, saturation. 0.5ULP
precision, denormals are supported.</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>V_MAC_F16</td>
<td>D.f16 = S0.f16 * S1.f16 + D.f16. Supports round
mode, exception flags, saturation.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>V_MADMK_F16</td>
<td>D.f16 = S0.f16 * K.f16 + S1.f16. // K is a
16-bit literal constant stored in the following
literal DWORD. This opcode cannot use the VOP3
encoding and cannot use input/output modifiers.
Supports round mode, exception flags, saturation.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>V_MADAK_F16</td>
<td>D.f16 = S0.f16 * S1.f16 + K.f16. // K is a
16-bit literal constant stored in the following
literal DWORD. This opcode cannot use the VOP3
encoding and cannot use input/output modifiers.
Supports round mode, exception flags, saturation.</td>
</tr>
<tr class="row-even"><td>38</td>
<td>V_ADD_U16</td>
<td>D.u16 = S0.u16 + S1.u16. Supports saturation
(unsigned 16-bit integer domain).</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>V_SUB_U16</td>
<td>D.u16 = S0.u16 - S1.u16. Supports saturation
(unsigned 16-bit integer domain).</td>
</tr>
<tr class="row-even"><td>40</td>
<td>V_SUBREV_U16</td>
<td>D.u16 = S1.u16 - S0.u16. Supports saturation
(unsigned 16-bit integer domain).</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>V_MUL_LO_U16</td>
<td>D.u16 = S0.u16 * S1.u16. Supports saturation
(unsigned 16-bit integer domain).</td>
</tr>
<tr class="row-even"><td>42</td>
<td>V_LSHLREV_B16</td>
<td>D.u[15:0] = S1.u[15:0] &lt;&lt; S0.u[3:0].</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>V_LSHRREV_B16</td>
<td>D.u[15:0] = S1.u[15:0] &gt;&gt; S0.u[3:0].</td>
</tr>
<tr class="row-even"><td>44</td>
<td>V_ASHRREV_I16</td>
<td>D.i[15:0] = signext(S1.i[15:0]) &gt;&gt; S0.i[3:0].</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>V_MAX_F16</td>
<td>if (IEEE_MODE &amp;&amp; S0.f16 == sNaN) D.f16 =
Quiet(S0.f16); else if (IEEE_MODE &amp;&amp; S1.f16 ==
sNaN) D.f16 = Quiet(S1.f16); else if (S0.f16 ==
NaN) D.f16 = S1.f16; else if (S1.f16 == NaN)
D.f16 = S0.f16; else if (S0.f16 == +0.0 &amp;&amp; S1.f16
== -0.0) D.f16 = S0.f16; else if (S0.f16 == -0.0
&amp;&amp; S1.f16 == +0.0) D.f16 = S1.f16; else if
(IEEE_MODE) D.f16 = (S0.f16 &gt;= S1.f16 ? S0.f16 :
S1.f16); else D.f16 = (S0.f16 &gt; S1.f16 ? S0.f16 :
S1.f16); endif. IEEE compliant. Supports
denormals, round mode, exception flags,
saturation.</td>
</tr>
<tr class="row-even"><td>46</td>
<td>V_MIN_F16</td>
<td>if (IEEE_MODE &amp;&amp; S0.f16 == sNaN) D.f16 =
Quiet(S0.f16); else if (IEEE_MODE &amp;&amp; S1.f16 ==
sNaN) D.f16 = Quiet(S1.f16); else if (S0.f16 ==
NaN) D.f16 = S1.f16; else if (S1.f16 == NaN)
D.f16 = S0.f16; else if (S0.f16 == +0.0 &amp;&amp; S1.f16
== -0.0) D.f16 = S1.f16; else if (S0.f16 == -0.0
&amp;&amp; S1.f16 == +0.0) D.f16 = S0.f16; else // Note:
there’s no IEEE special case here like there is
for V_MAX_F16. D.f16 = (S0.f16 &lt; S1.f16 ?
S0.f16 : S1.f16); endif. IEEE compliant. Supports
denormals, round mode, exception flags,
saturation.</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>V_MAX_U16</td>
<td>D.u16 = (S0.u16 &gt;= S1.u16 ? S0.u16 : S1.u16).</td>
</tr>
<tr class="row-even"><td>48</td>
<td>V_MAX_I16</td>
<td>D.i16 = (S0.i16 &gt;= S1.i16 ? S0.i16 : S1.i16).</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>V_MIN_U16</td>
<td>D.u16 = (S0.u16 &lt; S1.u16 ? S0.u16 : S1.u16).</td>
</tr>
<tr class="row-even"><td>50</td>
<td>V_MIN_I16</td>
<td>D.i16 = (S0.i16 &lt; S1.i16 ? S0.i16 : S1.i16).</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>V_LDEXP_F16</td>
<td>D.f16 = S0.f16 * (2 ** S1.i16). Note that the
S1 has a format of f16 since floating point
literal constants are interpreted as 16 bit value
for this opcode</td>
</tr>
<tr class="row-even"><td>52</td>
<td>V_ADD_U32</td>
<td>D.u = S0.u + S1.u.</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>V_SUB_U32</td>
<td>D.u = S0.u - S1.u.</td>
</tr>
<tr class="row-even"><td>54</td>
<td>V_SUBREV_U32</td>
<td>D.u = S1.u - S0.u.</td>
</tr>
</tbody>
</table>
<div class="section" id="vop2-using-vop3-encoding">
<h4>VOP2 using VOP3 encoding<a class="headerlink" href="#vop2-using-vop3-encoding" title="Permalink to this headline">¶</a></h4>
<p>Instructions in this format may also be encoded as VOP3. This allows
access to the extra control bits (e.g. ABS, OMOD) in exchange for not
being able to use a literal constant. The VOP3 opcode is: VOP2 opcode +
0x100.</p>
<p><img alt="microcode vop3a" src="../_images/microcode_vop3a.png" /></p>
<p><img alt="microcode vop3b" src="../_images/microcode_vop3b.png" /></p>
</div>
</div>
<div class="section" id="vop1-instructions">
<h3>VOP1 Instructions<a class="headerlink" href="#vop1-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode vop1" src="../_images/microcode_vop1.png" /></p>
<p>Instructions in this format may use a 32-bit literal constant which
occurs immediately after the instruction.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="22%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>V_NOP</td>
<td>Do nothing.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>V_MOV_B32</td>
<td>D.u = S0.u. Input and output modifiers not
supported; this is an untyped operation.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>V_READFIRSTLAN
E_B32</td>
<td>Copy one VGPR value to one SGPR. D = SGPR
destination, S0 = source data (VGPR# or M0 for
lds direct access), Lane# =
FindFirst1fromLSB(exec) (Lane# = 0 if exec is
zero). Ignores exec mask for the access. Input
and output modifiers not supported; this is an
untyped operation.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>V_CVT_I32_F6
4</td>
<td>D.i = (int)S0.d. 0.5ULP accuracy, out-of-range
floating point values (including infinity)
saturate. NaN is converted to 0. Generation of
the INEXACT exception is controlled by the CLAMP
bit. INEXACT exceptions are enabled for this
conversion iff CLAMP == 1.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>V_CVT_F64_I3
2</td>
<td>D.d = (double)S0.i. 0ULP accuracy.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>V_CVT_F32_I3
2</td>
<td>D.f = (float)S0.i. 0.5ULP accuracy.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>V_CVT_F32_U3
2</td>
<td>D.f = (float)S0.u. 0.5ULP accuracy.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>V_CVT_U32_F3
2</td>
<td>D.u = (unsigned)S0.f. 1ULP accuracy, out-of-range
floating point values (including infinity)
saturate. NaN is converted to 0. Generation of
the INEXACT exception is controlled by the CLAMP
bit. INEXACT exceptions are enabled for this
conversion iff CLAMP == 1.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>V_CVT_I32_F3
2</td>
<td>D.i = (int)S0.f. 1ULP accuracy, out-of-range
floating point values (including infinity)
saturate. NaN is converted to 0. Generation of
the INEXACT exception is controlled by the CLAMP
bit. INEXACT exceptions are enabled for this
conversion iff CLAMP == 1.</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>V_CVT_F16_F3
2</td>
<td>D.f16 = flt32_to_flt16(S0.f). 0.5ULP accuracy,
supports input modifiers and creates FP16
denormals when appropriate.</td>
</tr>
<tr class="row-even"><td>11</td>
<td>V_CVT_F32_F1
6</td>
<td>D.f = flt16_to_flt32(S0.f16). 0ULP accuracy,
FP16 denormal inputs are accepted.</td>
</tr>
<tr class="row-odd"><td>12</td>
<td>V_CVT_RPI_I3
2_F32</td>
<td>D.i = (int)floor(S0.f + 0.5). 0.5ULP accuracy,
denormals are supported.</td>
</tr>
<tr class="row-even"><td>13</td>
<td>V_CVT_FLR_I3
2_F32</td>
<td>D.i = (int)floor(S0.f). 1ULP accuracy, denormals
are supported.</td>
</tr>
<tr class="row-odd"><td>14</td>
<td>V_CVT_OFF_F3
2_I4</td>
<td>4-bit signed int to 32-bit float. Used for
interpolation in shader. S0 Result 1000 -0.5f
1001 -0.4375f 1010 -0.375f 1011 -0.3125f 1100
-0.25f 1101 -0.1875f 1110 -0.125f 1111 -0.0625f
0000 0.0f 0001 0.0625f 0010 0.125f 0011 0.1875f
0100 0.25f 0101 0.3125f 0110 0.375f 0111 0.4375f</td>
</tr>
<tr class="row-even"><td>15</td>
<td>V_CVT_F32_F6
4</td>
<td>D.f = (float)S0.d. 0.5ULP accuracy, denormals are
supported.</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>V_CVT_F64_F3
2</td>
<td>D.d = (double)S0.f. 0ULP accuracy, denormals are
supported.</td>
</tr>
<tr class="row-even"><td>17</td>
<td>V_CVT_F32_UB
YTE0</td>
<td>D.f = (float)(S0.u[7:0]).</td>
</tr>
<tr class="row-odd"><td>18</td>
<td>V_CVT_F32_UB
YTE1</td>
<td>D.f = (float)(S0.u[15:8]).</td>
</tr>
<tr class="row-even"><td>19</td>
<td>V_CVT_F32_UB
YTE2</td>
<td>D.f = (float)(S0.u[23:16]).</td>
</tr>
<tr class="row-odd"><td>20</td>
<td>V_CVT_F32_UB
YTE3</td>
<td>D.f = (float)(S0.u[31:24]).</td>
</tr>
<tr class="row-even"><td>21</td>
<td>V_CVT_U32_F6
4</td>
<td>D.u = (unsigned)S0.d. 0.5ULP accuracy,
out-of-range floating point values (including
infinity) saturate. NaN is converted to 0.
Generation of the INEXACT exception is controlled
by the CLAMP bit. INEXACT exceptions are enabled
for this conversion iff CLAMP == 1.</td>
</tr>
<tr class="row-odd"><td>22</td>
<td>V_CVT_F64_U3
2</td>
<td>D.d = (double)S0.u. 0ULP accuracy.</td>
</tr>
<tr class="row-even"><td>23</td>
<td>V_TRUNC_F64</td>
<td>D.d = trunc(S0.d). Return integer part of S0.d,
round-to-zero semantics.</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>V_CEIL_F64</td>
<td>D.d = trunc(S0.d); if(S0.d &gt; 0.0 &amp;&amp; S0.d != D.d)
then D.d += 1.0; endif. Round up to next whole
integer.</td>
</tr>
<tr class="row-even"><td>25</td>
<td>V_RNDNE_F64</td>
<td>D.d = floor(S0.d + 0.5); if(floor(S0.d) is even
&amp;&amp; fract(S0.d) == 0.5) then D.d -= 1.0; endif.
Round-to-nearest-even semantics.</td>
</tr>
<tr class="row-odd"><td>26</td>
<td>V_FLOOR_F64</td>
<td>D.d = trunc(S0.d); if(S0.d &lt; 0.0 &amp;&amp; S0.d != D.d)
then D.d += -1.0; endif. Round down to previous
whole integer.</td>
</tr>
<tr class="row-even"><td>27</td>
<td>V_FRACT_F32</td>
<td>D.f = S0.f + -floor(S0.f). Return fractional
portion of a number. 0.5ULP accuracy, denormals
are accepted.</td>
</tr>
<tr class="row-odd"><td>28</td>
<td>V_TRUNC_F32</td>
<td>D.f = trunc(S0.f). Return integer part of S0.f,
round-to-zero semantics.</td>
</tr>
<tr class="row-even"><td>29</td>
<td>V_CEIL_F32</td>
<td>D.f = trunc(S0.f); if(S0.f &gt; 0.0 &amp;&amp; S0.f != D.f)
then D.f += 1.0; endif. Round up to next whole
integer.</td>
</tr>
<tr class="row-odd"><td>30</td>
<td>V_RNDNE_F32</td>
<td>D.f = floor(S0.f + 0.5); if(floor(S0.f) is even
&amp;&amp; fract(S0.f) == 0.5) then D.f -= 1.0; endif.
Round-to-nearest-even semantics.</td>
</tr>
<tr class="row-even"><td>31</td>
<td>V_FLOOR_F32</td>
<td>D.f = trunc(S0.f); if(S0.f &lt; 0.0 &amp;&amp; S0.f != D.f)
then D.f += -1.0; endif. Round down to previous
whole integer.</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>V_EXP_F32</td>
<td>D.f = pow(2.0, S0.f). Base 2 exponentiation. 1ULP
accuracy, denormals are flushed. Examples:
V_EXP_F32(0xff800000) =&gt; 0x00000000 //
exp(-INF) = 0 V_EXP_F32(0x80000000) =&gt;
0x3f800000 // exp(-0.0) = 1
V_EXP_F32(0x7f800000) =&gt; 0x7f800000 //
exp(+INF) = +INF</td>
</tr>
<tr class="row-even"><td>33</td>
<td>V_LOG_F32</td>
<td>D.f = log2(S0.f). Base 2 logarithm. 1ULP
accuracy, denormals are flushed. Examples:
V_LOG_F32(0xff800000) =&gt; 0xffc00000 //
log(-INF) = NAN V_LOG_F32(0xbf800000) =&gt;
0xffc00000 // log(-1.0) = NAN
V_LOG_F32(0x80000000) =&gt; 0xff800000 //
log(-0.0) = -INF V_LOG_F32(0x00000000) =&gt;
0xff800000 // log(+0.0) = -INF
V_LOG_F32(0x3f800000) =&gt; 0x00000000 //
log(+1.0) = 0 V_LOG_F32(0x7f800000) =&gt;
0x7f800000 // log(+INF) = +INF</td>
</tr>
<tr class="row-odd"><td>34</td>
<td>V_RCP_F32</td>
<td>D.f = 1.0 / S0.f. Reciprocal with IEEE rules and
1ULP accuracy. Accuracy converges to &lt; 0.5ULP
when using the Newton-Raphson method and 2 FMA
operations. Denormals are flushed. Examples:
V_RCP_F32(0xff800000) =&gt; 0x80000000 //
rcp(-INF) = -0 V_RCP_F32(0xc0000000) =&gt;
0xbf000000 // rcp(-2.0) = -0.5
V_RCP_F32(0x80000000) =&gt; 0xff800000 //
rcp(-0.0) = -INF V_RCP_F32(0x00000000) =&gt;
0x7f800000 // rcp(+0.0) = +INF
V_RCP_F32(0x7f800000) =&gt; 0x00000000 //
rcp(+INF) = +0</td>
</tr>
<tr class="row-even"><td>35</td>
<td>V_RCP_IFLAG_
F32</td>
<td>D.f = 1.0 / S0.f. Reciprocal intended for integer
division, can raise integer DIV_BY_ZERO
exception but cannot raise floating-point
exceptions. To be used in an integer reciprocal
macro by the compiler with one of the following
sequences: Unsigned: CVT_F32_U32
RCP_IFLAG_F32 MUL_F32 (2**32 - 1)
CVT_U32_F32 Signed: CVT_F32_I32
RCP_IFLAG_F32 MUL_F32 (2**31 - 1)
CVT_I32_F32</td>
</tr>
<tr class="row-odd"><td>36</td>
<td>V_RSQ_F32</td>
<td>D.f = 1.0 / sqrt(S0.f). Reciprocal square root
with IEEE rules. 1ULP accuracy, denormals are
flushed. Examples: V_RSQ_F32(0xff800000) =&gt;
0xffc00000 // rsq(-INF) = NAN
V_RSQ_F32(0x80000000) =&gt; 0xff800000 //
rsq(-0.0) = -INF V_RSQ_F32(0x00000000) =&gt;
0x7f800000 // rsq(+0.0) = +INF
V_RSQ_F32(0x40800000) =&gt; 0x3f000000 //
rsq(+4.0) = +0.5 V_RSQ_F32(0x7f800000) =&gt;
0x00000000 // rsq(+INF) = +0</td>
</tr>
<tr class="row-even"><td>37</td>
<td>V_RCP_F64</td>
<td>D.d = 1.0 / S0.d. Reciprocal with IEEE rules and
perhaps not the accuracy you were hoping for –
(2**29)ULP accuracy. On the upside, denormals
are supported.</td>
</tr>
<tr class="row-odd"><td>38</td>
<td>V_RSQ_F64</td>
<td>D.f16 = 1.0 / sqrt(S0.f16). Reciprocal square
root with IEEE rules and perhaps not the accuracy
you were hoping for – (2**29)ULP accuracy. On
the upside, denormals are supported.</td>
</tr>
<tr class="row-even"><td>39</td>
<td>V_SQRT_F32</td>
<td>D.f = sqrt(S0.f). Square root. 1ULP accuracy,
denormals are flushed. Examples:
V_SQRT_F32(0xff800000) =&gt; 0xffc00000 //
sqrt(-INF) = NAN V_SQRT_F32(0x80000000) =&gt;
0x80000000 // sqrt(-0.0) = -0
V_SQRT_F32(0x00000000) =&gt; 0x00000000 //
sqrt(+0.0) = +0 V_SQRT_F32(0x40800000) =&gt;
0x40000000 // sqrt(+4.0) = +2.0
V_SQRT_F32(0x7f800000) =&gt; 0x7f800000 //
sqrt(+INF) = +INF</td>
</tr>
<tr class="row-odd"><td>40</td>
<td>V_SQRT_F64</td>
<td>D.d = sqrt(S0.d). Square root with perhaps not
the accuracy you were hoping for – (2**29)ULP
accuracy. On the upside, denormals are supported.</td>
</tr>
<tr class="row-even"><td>41</td>
<td>V_SIN_F32</td>
<td>D.f = sin(S0.f * 2 * PI). Trigonometric sine.
Denormals are supported. Examples:
V_SIN_F32(0xff800000) =&gt; 0xffc00000 //
sin(-INF) = NAN V_SIN_F32(0xff7fffff) =&gt;
0x00000000 // -MaxFloat, finite
V_SIN_F32(0x80000000) =&gt; 0x80000000 //
sin(-0.0) = -0 V_SIN_F32(0x3e800000) =&gt;
0x3f800000 // sin(0.25) = 1
V_SIN_F32(0x7f800000) =&gt; 0xffc00000 //
sin(+INF) = NAN</td>
</tr>
<tr class="row-odd"><td>42</td>
<td>V_COS_F32</td>
<td>D.f = cos(S0.f * 2 * PI). Trigonometric cosine.
Denormals are supported. Examples:
V_COS_F32(0xff800000) =&gt; 0xffc00000 //
cos(-INF) = NAN V_COS_F32(0xff7fffff) =&gt;
0x3f800000 // -MaxFloat, finite
V_COS_F32(0x80000000) =&gt; 0x3f800000 //
cos(-0.0) = 1 V_COS_F32(0x3e800000) =&gt;
0x00000000 // cos(0.25) = 0
V_COS_F32(0x7f800000) =&gt; 0xffc00000 //
cos(+INF) = NAN</td>
</tr>
<tr class="row-even"><td>43</td>
<td>V_NOT_B32</td>
<td>D.u = ~S0.u. Bitwise negation. Input and output
modifiers not supported.</td>
</tr>
<tr class="row-odd"><td>44</td>
<td>V_BFREV_B32</td>
<td>D.u[31:0] = S0.u[0:31]. Bitfield reverse. Input
and output modifiers not supported.</td>
</tr>
<tr class="row-even"><td>45</td>
<td>V_FFBH_U32</td>
<td>D.i = -1; // Set if no ones are found for i in 0
… 31 do // Note: search is from the MSB if
S0.u[31 - i] == 1 then D.i = i; break for; endif;
endfor. Counts how many zeros before the first
one starting from the MSB. Returns -1 if there
are no ones. Examples: V_FFBH_U32(0x00000000)
=&gt; 0xffffffff V_FFBH_U32(0x800000ff) =&gt; 0
V_FFBH_U32(0x100000ff) =&gt; 3
V_FFBH_U32(0x0000ffff) =&gt; 16
V_FFBH_U32(0x00000001) =&gt; 31</td>
</tr>
<tr class="row-odd"><td>46</td>
<td>V_FFBL_B32</td>
<td>D.i = -1; // Set if no ones are found for i in 0
… 31 do // Search from LSB if S0.u[i] == 1 then
D.i = i; break for; endif; endfor. Returns the
bit position of the first one from the LSB, or -1
if there are no ones. Examples:
V_FFBL_B32(0x00000000) =&gt; 0xffffffff
V_FFBL_B32(0xff000001) =&gt; 0
V_FFBL_B32(0xff000008) =&gt; 3
V_FFBL_B32(0xffff0000) =&gt; 16
V_FFBL_B32(0x80000000) =&gt; 31</td>
</tr>
<tr class="row-even"><td>47</td>
<td>V_FFBH_I32</td>
<td>D.i = -1; // Set if all bits are the same for i
in 1 … 31 do // Note: search is from the MSB if
S0.i[31 - i] != S0.i[31] then D.i = i; break for;
endif; endfor. Counts how many bits in a row
(from MSB to LSB) are the same as the sign bit.
Returns -1 if all bits are the same. Examples:
V_FFBH_I32(0x00000000) =&gt; 0xffffffff
V_FFBH_I32(0x40000000) =&gt; 1
V_FFBH_I32(0x80000000) =&gt; 1
V_FFBH_I32(0x0fffffff) =&gt; 4
V_FFBH_I32(0xffff0000) =&gt; 16
V_FFBH_I32(0xfffffffe) =&gt; 31
V_FFBH_I32(0xffffffff) =&gt; 0xffffffff</td>
</tr>
<tr class="row-odd"><td>48</td>
<td>V_FREXP_EXP_
I32_F64</td>
<td>if(S0.d == +-INF || S0.d == NAN) then D.i = 0;
else D.i = TwosComplement(Exponent(S0.d) - 1023 +
1); endif. Returns exponent of single precision
float input, such that S0.d = significand * (2
** exponent). See also V_FREXP_MANT_F64,
which returns the significand. See the C library
function frexp() for more information.</td>
</tr>
<tr class="row-even"><td>49</td>
<td>V_FREXP_MANT_F64</td>
<td>if(S0.d == +-INF || S0.d == NAN) then D.d =
S0.d; else D.d = Mantissa(S0.d); endif. Result
range is in (-1.0,-0.5][0.5,1.0) in typical
cases. Returns binary significand of double
precision float input, such that S0.d =
significand * (2 ** exponent). See also
V_FREXP_EXP_I32_F64, which returns integer
exponent. See the C library function frexp() for
more information.</td>
</tr>
<tr class="row-odd"><td>50</td>
<td>V_FRACT_F64</td>
<td>D.d = S0.d + -floor(S0.d). Return fractional
portion of a number. 0.5ULP accuracy, denormals
are accepted.</td>
</tr>
<tr class="row-even"><td>51</td>
<td>V_FREXP_EXP_
I32_F32</td>
<td>if(S0.f == +-INF || S0.f == NAN) then D.i = 0;
else D.i = TwosComplement(Exponent(S0.f) - 127 +
1); endif. Returns exponent of single precision
float input, such that S0.f = significand * (2
** exponent). See also V_FREXP_MANT_F32,
which returns the significand. See the C library
function frexp() for more information.</td>
</tr>
<tr class="row-odd"><td>52</td>
<td>V_FREXP_MANT_F32</td>
<td>if(S0.f == +-INF || S0.f == NAN) then D.f =
S0.f; else D.f = Mantissa(S0.f); endif. Result
range is in (-1.0,-0.5][0.5,1.0) in typical
cases. Returns binary significand of single
precision float input, such that S0.f =
significand * (2 ** exponent). See also
V_FREXP_EXP_I32_F32, which returns integer
exponent. See the C library function frexp() for
more information.</td>
</tr>
<tr class="row-even"><td>53</td>
<td>V_CLREXCP</td>
<td>Clear wave’s exception state in SIMD (SP).</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>V_SCREEN_PART
ITION_4SE_B32</td>
<td>D.u = TABLE[S0.u[7:0]]. TABLE: 0x1, 0x3, 0x7,
0xf, 0x5, 0xf, 0xf, 0xf, 0x7, 0xf, 0xf, 0xf, 0xf,
0xf, 0xf, 0xf, 0xf, 0x2, 0x6, 0xe, 0xf, 0xa, 0xf,
0xf, 0xf, 0xb, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xd,
0xf, 0x4, 0xc, 0xf, 0xf, 0x5, 0xf, 0xf, 0xf, 0xd,
0xf, 0xf, 0xf, 0xf, 0xf, 0x9, 0xb, 0xf, 0x8, 0xf,
0xf, 0xf, 0xa, 0xf, 0xf, 0xf, 0xe, 0xf, 0xf, 0xf,
0xf, 0xf, 0xf, 0xf, 0xf, 0x4, 0xc, 0xd, 0xf, 0x6,
0xf, 0xf, 0xf, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
0xf, 0xf, 0x8, 0x9, 0xb, 0xf, 0x9, 0x9, 0xf, 0xf,
0xd, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0xf, 0x1,
0x3, 0xf, 0xf, 0x9, 0xf, 0xf, 0xf, 0xb, 0xf, 0xf,
0xf, 0xf, 0xf, 0x6, 0xe, 0xf, 0x2, 0x6, 0xf, 0xf,
0x6, 0xf, 0xf, 0xf, 0x7, 0xb, 0xf, 0xf, 0xf, 0xf,
0xf, 0xf, 0xf, 0x2, 0x3, 0xb, 0xf, 0xa, 0xf, 0xf,
0xf, 0xf, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
0x1, 0x9, 0xd, 0xf, 0x5, 0xf, 0xf, 0xf, 0xf, 0xe,
0xf, 0xf, 0xf, 0xf, 0xf, 0xe, 0xf, 0x8, 0xc, 0xf,
0xf, 0xa, 0xf, 0xf, 0xf, 0xf, 0xd, 0xf, 0xf, 0xf,
0xf, 0x6, 0x7, 0xf, 0x4, 0xf, 0xf, 0xf, 0x5, 0x9,
0xf, 0xf, 0xf, 0xd, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
0xf, 0x8, 0xc, 0xe, 0xf, 0xf, 0x6, 0x6, 0xf, 0xf,
0xe, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x4, 0x6,
0x7, 0xf, 0xf, 0x6, 0xf, 0xf, 0xf, 0x7, 0xf, 0xf,
0xf, 0xf, 0xf, 0xb, 0xf, 0x2, 0x3, 0x9, 0xf, 0xf,
0x9, 0xf, 0xf, 0xf, 0xb, 0xf, 0xf, 0xf, 0xf, 0x9,
0xd, 0xf, 0x1 4SE version of LUT instruction for
screen partitioning/filtering. This opcode is
intended to accelerate screen partitioning in the
4SE case only. 2SE and 1SE cases use normal ALU
instructions. This opcode returns a 4-bit bitmask
indicating which SE backends are covered by a
rectangle from (x_min, y_min) to (x_max,
y_max). With 32-pixel tiles the SE for (x, y) is
given by { x[5] ^ y[6], y[5] ^ x[6] } . Using
this formula we can determine which SEs are
covered by a larger rectangle. The primitive
shader must perform the following operation
before the opcode is called. 1. Compute the
bounding box of the primitive (x_min, y_min)
(upper left) and (x_max, y_max) (lower right),
in pixels. 2. Check for any extents that do not
need to use the opcode — if ((x_max/32 -
x_min/32 &gt;= 3) OR ((y_max/32 - y_min/32 &gt;= 3)
(tile size of 32) then all backends are covered.
3. Call the opcode with this 8 bit select: {
x_min[6:5], y_min[6:5], x_max[6:5],
y_max[6:5] } . 4. The opcode will return a 4 bit
mask indicating which backends are covered, where
bit 0 indicates SE0 is covered and bit 3
indicates SE3 is covered. Example: 1. The
calculated bounding box is (0, 0) to (25, 35). 2.
Observe the bounding box is not large enough to
trivially cover all backends. 3. Divide by tile
size 32 and concatenate bits to produce a
selector of binary 00000001. 4. Opcode will
return 0x3 which means backend 0 and 1 are
covered.</td>
</tr>
<tr class="row-even"><td>57</td>
<td>V_CVT_F16_U1
6</td>
<td>D.f16 = uint16_to_flt16(S.u16). 0.5ULP
accuracy, supports denormals, rounding, exception
flags and saturation.</td>
</tr>
<tr class="row-odd"><td>58</td>
<td>V_CVT_F16_I1
6</td>
<td>D.f16 = int16_to_flt16(S.i16). 0.5ULP accuracy,
supports denormals, rounding, exception flags and
saturation.</td>
</tr>
<tr class="row-even"><td>59</td>
<td>V_CVT_U16_F1
6</td>
<td>D.u16 = flt16_to_uint16(S.f16). 1ULP accuracy,
supports rounding, exception flags and
saturation. FP16 denormals are accepted.
Conversion is done with truncation. Generation of
the INEXACT exception is controlled by the CLAMP
bit. INEXACT exceptions are enabled for this
conversion iff CLAMP == 1.</td>
</tr>
<tr class="row-odd"><td>60</td>
<td>V_CVT_I16_F1
6</td>
<td>D.i16 = flt16_to_int16(S.f16). 1ULP accuracy,
supports rounding, exception flags and
saturation. FP16 denormals are accepted.
Conversion is done with truncation. Generation of
the INEXACT exception is controlled by the CLAMP
bit. INEXACT exceptions are enabled for this
conversion iff CLAMP == 1.</td>
</tr>
<tr class="row-even"><td>61</td>
<td>V_RCP_F16</td>
<td>D.f16 = 1.0 / S0.f16. Reciprocal with IEEE rules
and 0.51ULP accuracy. Examples:
V_RCP_F16(0xfc00) =&gt; 0x8000 // rcp(-INF) = -0
V_RCP_F16(0xc000) =&gt; 0xb800 // rcp(-2.0) = -0.5
V_RCP_F16(0x8000) =&gt; 0xfc00 // rcp(-0.0) = -INF
V_RCP_F16(0x0000) =&gt; 0x7c00 // rcp(+0.0) = +INF
V_RCP_F16(0x7c00) =&gt; 0x0000 // rcp(+INF) = +0</td>
</tr>
<tr class="row-odd"><td>62</td>
<td>V_SQRT_F16</td>
<td>D.f16 = sqrt(S0.f16). Square root. 0.51ULP
accuracy, denormals are supported. Examples:
V_SQRT_F16(0xfc00) =&gt; 0xfe00 // sqrt(-INF) =
NAN V_SQRT_F16(0x8000) =&gt; 0x8000 // sqrt(-0.0)
= -0 V_SQRT_F16(0x0000) =&gt; 0x0000 // sqrt(+0.0)
= +0 V_SQRT_F16(0x4400) =&gt; 0x4000 // sqrt(+4.0)
= +2.0 V_SQRT_F16(0x7c00) =&gt; 0x7c00 //
sqrt(+INF) = +INF</td>
</tr>
<tr class="row-even"><td>63</td>
<td>V_RSQ_F16</td>
<td>D.f16 = 1.0 / sqrt(S0.f16). Reciprocal square
root with IEEE rules. 0.51ULP accuracy, denormals
are supported. Examples: V_RSQ_F16(0xfc00) =&gt;
0xfe00 // rsq(-INF) = NAN V_RSQ_F16(0x8000) =&gt;
0xfc00 // rsq(-0.0) = -INF V_RSQ_F16(0x0000) =&gt;
0x7c00 // rsq(+0.0) = +INF V_RSQ_F16(0x4400) =&gt;
0x3800 // rsq(+4.0) = +0.5 V_RSQ_F16(0x7c00) =&gt;
0x0000 // rsq(+INF) = +0</td>
</tr>
<tr class="row-odd"><td>64</td>
<td>V_LOG_F16</td>
<td>D.f16 = log2(S0.f). Base 2 logarithm. 0.51ULP
accuracy, denormals are supported. Examples:
V_LOG_F16(0xfc00) =&gt; 0xfe00 // log(-INF) = NAN
V_LOG_F16(0xbc00) =&gt; 0xfe00 // log(-1.0) = NAN
V_LOG_F16(0x8000) =&gt; 0xfc00 // log(-0.0) = -INF
V_LOG_F16(0x0000) =&gt; 0xfc00 // log(+0.0) = -INF
V_LOG_F16(0x3c00) =&gt; 0x0000 // log(+1.0) = 0
V_LOG_F16(0x7c00) =&gt; 0x7c00 // log(+INF) = +INF</td>
</tr>
<tr class="row-even"><td>65</td>
<td>V_EXP_F16</td>
<td>D.f16 = pow(2.0, S0.f16). Base 2 exponentiation.
0.51ULP accuracy, denormals are supported.
Examples: V_EXP_F16(0xfc00) =&gt; 0x0000 //
exp(-INF) = 0 V_EXP_F16(0x8000) =&gt; 0x3c00 //
exp(-0.0) = 1 V_EXP_F16(0x7c00) =&gt; 0x7c00 //
exp(+INF) = +INF</td>
</tr>
<tr class="row-odd"><td>66</td>
<td>V_FREXP_MANT_F16</td>
<td>if(S0.f16 == +-INF || S0.f16 == NAN) then D.f16
= S0.f16; else D.f16 = Mantissa(S0.f16); endif.
Result range is in (-1.0,-0.5][0.5,1.0) in
typical cases. Returns binary significand of half
precision float input, such that S0.f16 =
significand * (2 ** exponent). See also
V_FREXP_EXP_I16_F16, which returns integer
exponent. See the C library function frexp() for
more information.</td>
</tr>
<tr class="row-even"><td>67</td>
<td>V_FREXP_EXP_
I16_F16</td>
<td>if(S0.f16 == +-INF || S0.f16 == NAN) then D.i =
0; else D.i = TwosComplement(Exponent(S0.f16) -
15 + 1); endif. Returns exponent of half
precision float input, such that S0.f16 =
significand * (2 ** exponent). See also
V_FREXP_MANT_F16, which returns the
significand. See the C library function frexp()
for more information.</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>V_FLOOR_F16</td>
<td>D.f16 = trunc(S0.f16); if(S0.f16 &lt; 0.0f &amp;&amp; S0.f16
!= D.f16) then D.f16 -= 1.0; endif. Round down to
previous whole integer.</td>
</tr>
<tr class="row-even"><td>69</td>
<td>V_CEIL_F16</td>
<td>D.f16 = trunc(S0.f16); if(S0.f16 &gt; 0.0f &amp;&amp; S0.f16
!= D.f16) then D.f16 += 1.0; endif. Round up to
next whole integer.</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>V_TRUNC_F16</td>
<td>D.f16 = trunc(S0.f16). Return integer part of
S0.f16, round-to-zero semantics.</td>
</tr>
<tr class="row-even"><td>71</td>
<td>V_RNDNE_F16</td>
<td>D.f16 = floor(S0.f16 + 0.5); if(floor(S0.f16) is
even &amp;&amp; fract(S0.f16) == 0.5) then D.f16 -= 1.0;
endif. Round-to-nearest-even semantics.</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>V_FRACT_F16</td>
<td>D.f16 = S0.f16 + -floor(S0.f16). Return
fractional portion of a number. 0.5ULP accuracy,
denormals are accepted.</td>
</tr>
<tr class="row-even"><td>73</td>
<td>V_SIN_F16</td>
<td>D.f16 = sin(S0.f16 * 2 * PI). Trigonometric
sine. Denormals are supported. Examples:
V_SIN_F16(0xfc00) =&gt; 0xfe00 // sin(-INF) = NAN
V_SIN_F16(0xfbff) =&gt; 0x0000 // Most negative
finite FP16 V_SIN_F16(0x8000) =&gt; 0x8000 //
sin(-0.0) = -0 V_SIN_F16(0x3400) =&gt; 0x3c00 //
sin(0.25) = 1 V_SIN_F16(0x7bff) =&gt; 0x0000 //
Most positive finite FP16 V_SIN_F16(0x7c00) =&gt;
0xfe00 // sin(+INF) = NAN</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>V_COS_F16</td>
<td>D.f16 = cos(S0.f16 * 2 * PI). Trigonometric
cosine. Denormals are supported. Examples:
V_COS_F16(0xfc00) =&gt; 0xfe00 // cos(-INF) = NAN
V_COS_F16(0xfbff) =&gt; 0x3c00 // Most negative
finite FP16 V_COS_F16(0x8000) =&gt; 0x3c00 //
cos(-0.0) = 1 V_COS_F16(0x3400) =&gt; 0x0000 //
cos(0.25) = 0 V_COS_F16(0x7bff) =&gt; 0x3c00 //
Most positive finite FP16 V_COS_F16(0x7c00) =&gt;
0xfe00 // cos(+INF) = NAN</td>
</tr>
<tr class="row-even"><td>75</td>
<td>V_EXP_LEGACY_F32</td>
<td>D.f = pow(2.0, S0.f). Power with legacy
semantics.</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>V_LOG_LEGACY_F32</td>
<td>D.f = log2(S0.f). Base 2 logarithm with legacy
semantics.</td>
</tr>
<tr class="row-even"><td>77</td>
<td>V_CVT_NORM_I
16_F16</td>
<td>D.i16 = flt16_to_snorm16(S.f16). 0.5ULP
accuracy, supports rounding, exception flags and
saturation, denormals are supported.</td>
</tr>
<tr class="row-odd"><td>78</td>
<td>V_CVT_NORM_U
16_F16</td>
<td>D.u16 = flt16_to_unorm16(S.f16). 0.5ULP
accuracy, supports rounding, exception flags and
saturation, denormals are supported.</td>
</tr>
<tr class="row-even"><td>79</td>
<td>V_SAT_PK_U8_I16</td>
<td>D.u32 = {16’b0, sat8(S.u[31:16]),
sat8(S.u[15:0])}.</td>
</tr>
<tr class="row-odd"><td>81</td>
<td>V_SWAP_B32</td>
<td>tmp = D.u; D.u = S0.u; S0.u = tmp. Swap operands.
Input and output modifiers not supported; this is
an untyped operation.</td>
</tr>
</tbody>
</table>
<div class="section" id="vop1-using-vop3-encoding">
<h4>VOP1 using VOP3 encoding<a class="headerlink" href="#vop1-using-vop3-encoding" title="Permalink to this headline">¶</a></h4>
<p>Instructions in this format may also be encoded as VOP3. This allows
access to the extra control bits (e.g. ABS, OMOD) in exchange for not
being able to use a literal constant. The VOP3 opcode is: VOP2 opcode +
0x140.</p>
<p><img alt="microcode vop3a" src="../_images/microcode_vop3a.png" /></p>
<p><img alt="microcode vop3b" src="../_images/microcode_vop3b.png" /></p>
</div>
</div>
<div class="section" id="vopc-instructions">
<h3>VOPC Instructions<a class="headerlink" href="#vopc-instructions" title="Permalink to this headline">¶</a></h3>
<p>The bitfield map for VOPC is:</p>
<p><img alt="microcode vopc" src="../_images/microcode_vopc.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">where</span><span class="p">:</span>

<span class="n">SRC0</span>  <span class="o">=</span> <span class="n">First</span> <span class="n">operand</span> <span class="k">for</span> <span class="n">instruction</span><span class="o">.</span>
<span class="n">VSRC1</span> <span class="o">=</span> <span class="n">Second</span> <span class="n">operand</span> <span class="k">for</span> <span class="n">instruction</span><span class="o">.</span>
<span class="n">OP</span>    <span class="o">=</span> <span class="n">Instructions</span><span class="o">.</span>
<span class="n">All</span> <span class="n">VOPC</span> <span class="n">instructions</span> <span class="n">are</span> <span class="n">also</span> <span class="n">part</span> <span class="n">of</span> <span class="n">VOP3a</span> <span class="n">microcode</span> <span class="nb">format</span><span class="p">,</span>
<span class="k">for</span> <span class="n">which</span> <span class="n">the</span> <span class="n">bitfield</span> <span class="ow">is</span><span class="p">:</span>
</pre></div>
</div>
<p>Compare instructions perform the same compare operation on each lane
(workItem or thread) using that lane’s private data, and producing a 1
bit result per lane into VCC or EXEC.</p>
<p>Instructions in this format may use a 32-bit literal constant which
occurs immediately after the instruction.</p>
<p>Most compare instructions fall into one of two categories:</p>
<ul class="simple">
<li>Those which can use one of 16 compare operations (floating point
types). “{COMPF}”</li>
<li>Those which can use one of 8 compare operations (integer types).
“{COMPI}”</li>
</ul>
<p>The opcode number is such that for these the opcode number can be
calculated from a base opcode number for the data type, plus an offset
for the specific compare operation.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Compare Operation</th>
<th class="head">Opcode Offset</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>F</td>
<td>0</td>
<td>D.u = 0</td>
</tr>
<tr class="row-odd"><td>LT</td>
<td>1</td>
<td>D.u = (S0 &lt; S1)</td>
</tr>
<tr class="row-even"><td>EQ</td>
<td>2</td>
<td>D.u = (S0 == S1)</td>
</tr>
<tr class="row-odd"><td>LE</td>
<td>3</td>
<td>D.u = (S0 &lt;= S1)</td>
</tr>
<tr class="row-even"><td>GT</td>
<td>4</td>
<td>D.u = (S0 &gt; S1)</td>
</tr>
<tr class="row-odd"><td>LG</td>
<td>5</td>
<td>D.u = (S0 &lt;&gt; S1)</td>
</tr>
<tr class="row-even"><td>GE</td>
<td>6</td>
<td>D.u = (S0 &gt;= S1)</td>
</tr>
<tr class="row-odd"><td>O</td>
<td>7</td>
<td>D.u = (!isNaN(S0) &amp;&amp;
!isNaN(S1))</td>
</tr>
<tr class="row-even"><td>U</td>
<td>8</td>
<td>D.u = (!isNaN(S0) ||
!isNaN(S1))</td>
</tr>
<tr class="row-odd"><td>NGE</td>
<td>9</td>
<td>D.u = !(S0 &gt;= S1)</td>
</tr>
<tr class="row-even"><td>NLG</td>
<td>10</td>
<td>D.u = !(S0 &lt;&gt; S1)</td>
</tr>
<tr class="row-odd"><td>NGT</td>
<td>11</td>
<td>D.u = !(S0 &gt; S1)</td>
</tr>
<tr class="row-even"><td>NLE</td>
<td>12</td>
<td>D.u = !(S0 &lt;= S1)</td>
</tr>
<tr class="row-odd"><td>NEQ</td>
<td>13</td>
<td>D.u = !(S0 == S1)</td>
</tr>
<tr class="row-even"><td>NLT</td>
<td>14</td>
<td>D.u = !(S0 &lt; S1)</td>
</tr>
<tr class="row-odd"><td>TRU</td>
<td>15</td>
<td>D.u = 1</td>
</tr>
</tbody>
</table>
<p>Table: Instructions with Sixteen Compare Operations</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Description</th>
<th class="head">Hex Range</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>V_CMP_{COMPF}_F16</td>
<td>16-bit float compare.</td>
<td>0x20 to 0x2F</td>
</tr>
<tr class="row-odd"><td>V_CMPX_{COMPF}_F16</td>
<td>16-bit float compare.
Also writes EXEC.</td>
<td>0x30 to 0x3F</td>
</tr>
<tr class="row-even"><td>V_CMP_{COMPF}_F32</td>
<td>32-bit float compare.</td>
<td>0x40 to 0x4F</td>
</tr>
<tr class="row-odd"><td>V_CMPX_{COMPF}_F32</td>
<td>32-bit float compare.
Also writes EXEC.</td>
<td>0x50 to 0x5F</td>
</tr>
<tr class="row-even"><td>V_CMPS_{COMPF}_F64</td>
<td>64-bit float compare.</td>
<td>0x60 to 0x6F</td>
</tr>
<tr class="row-odd"><td>V_CMPSX_{COMPF}_F64</td>
<td>64-bit float compare.
Also writes EXEC.</td>
<td>0x70 to 0x7F</td>
</tr>
</tbody>
</table>
<p>Table: Instructions with Sixteen Compare Operations</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Compare Operation</th>
<th class="head">Opcode Offset</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>F</td>
<td>0</td>
<td>D.u = 0</td>
</tr>
<tr class="row-odd"><td>LT</td>
<td>1</td>
<td>D.u = (S0 &lt; S1)</td>
</tr>
<tr class="row-even"><td>EQ</td>
<td>2</td>
<td>D.u = (S0 == S1)</td>
</tr>
<tr class="row-odd"><td>LE</td>
<td>3</td>
<td>D.u = (S0 &lt;= S1)</td>
</tr>
<tr class="row-even"><td>GT</td>
<td>4</td>
<td>D.u = (S0 &gt; S1)</td>
</tr>
<tr class="row-odd"><td>LG</td>
<td>5</td>
<td>D.u = (S0 &lt;&gt; S1)</td>
</tr>
<tr class="row-even"><td>GE</td>
<td>6</td>
<td>D.u = (S0 &gt;= S1)</td>
</tr>
<tr class="row-odd"><td>TRU</td>
<td>7</td>
<td>D.u = 1</td>
</tr>
</tbody>
</table>
<p>Table: Instructions with Sixteen Compare Operations</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head">Description</th>
<th class="head">Hex Range</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>V_CMP_{COMPI}_I16</td>
<td>16-bit signed integer
compare.</td>
<td>0xA0 - 0xA7</td>
</tr>
<tr class="row-odd"><td>V_CMP_{COMPI}_U16</td>
<td>16-bit signed integer
compare. Also writes
EXEC.</td>
<td>0xA8 - 0xAF</td>
</tr>
<tr class="row-even"><td>V_CMPX_{COMPI}_I16</td>
<td>16-bit unsigned integer
compare.</td>
<td>0xB0 - 0xB7</td>
</tr>
<tr class="row-odd"><td>V_CMPX_{COMPI}_U16</td>
<td>16-bit unsigned integer
compare. Also writes
EXEC.</td>
<td>0xB8 - 0xBF</td>
</tr>
<tr class="row-even"><td>V_CMP_{COMPI}_I32</td>
<td>32-bit signed integer
compare.</td>
<td>0xC0 - 0xC7</td>
</tr>
<tr class="row-odd"><td>V_CMP_{COMPI}_U32</td>
<td>32-bit signed integer
compare. Also writes
EXEC.</td>
<td>0xC8 - 0xCF</td>
</tr>
<tr class="row-even"><td>V_CMPX_{COMPI}_I32</td>
<td>32-bit unsigned integer
compare.</td>
<td>0xD0 - 0xD7</td>
</tr>
<tr class="row-odd"><td>V_CMPX_{COMPI}_U32</td>
<td>32-bit unsigned integer
compare. Also writes
EXEC.</td>
<td>0xD8 - 0xDF</td>
</tr>
<tr class="row-even"><td>V_CMP_{COMPI}_I64</td>
<td>64-bit signed integer
compare.</td>
<td>0xE0 - 0xE7</td>
</tr>
<tr class="row-odd"><td>V_CMP_{COMPI}_U64</td>
<td>64-bit signed integer
compare. Also writes
EXEC.</td>
<td>0xE8 - 0xEF</td>
</tr>
<tr class="row-even"><td>V_CMPX_{COMPI}_I64</td>
<td>64-bit unsigned integer
compare.</td>
<td>0xF0 - 0xF7</td>
</tr>
<tr class="row-odd"><td>V_CMPX_{COMPI}_U64</td>
<td>64-bit unsigned integer
compare. Also writes
EXEC.</td>
<td>0xF8 - 0xFF</td>
</tr>
</tbody>
</table>
<p>Table: Instructions with Eight Compare Operations</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>V_CMP_CLASS_F32</td>
<td>VCC = IEEE numeric class function specified in
S1.u, performed on S0.f The function reports true
if the floating point value is *any* of the
numeric types selected in S1.u according to the
following list: S1.u[0] – value is a signaling
NaN. S1.u[1] – value is a quiet NaN. S1.u[2] –
value is negative infinity. S1.u[3] – value is a
negative normal value. S1.u[4] – value is a
negative denormal value. S1.u[5] – value is
negative zero. S1.u[6] – value is positive zero.
S1.u[7] – value is a positive denormal value.
S1.u[8] – value is a positive normal value.
S1.u[9] – value is positive infinity.</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>V_CMPX_CLASS
_F32</td>
<td>EXEC = VCC = IEEE numeric class function specified
in S1.u, performed on S0.f The function reports
true if the floating point value is *any* of the
numeric types selected in S1.u according to the
following list: S1.u[0] – value is a signaling
NaN. S1.u[1] – value is a quiet NaN. S1.u[2] –
value is negative infinity. S1.u[3] – value is a
negative normal value. S1.u[4] – value is a
negative denormal value. S1.u[5] – value is
negative zero. S1.u[6] – value is positive zero.
S1.u[7] – value is a positive denormal value.
S1.u[8] – value is a positive normal value.
S1.u[9] – value is positive infinity.</td>
</tr>
<tr class="row-even"><td>18</td>
<td>V_CMP_CLASS_F64</td>
<td>VCC = IEEE numeric class function specified in
S1.u, performed on S0.d The function reports true
if the floating point value is *any* of the
numeric types selected in S1.u according to the
following list: S1.u[0] – value is a signaling
NaN. S1.u[1] – value is a quiet NaN. S1.u[2] –
value is negative infinity. S1.u[3] – value is a
negative normal value. S1.u[4] – value is a
negative denormal value. S1.u[5] – value is
negative zero. S1.u[6] – value is positive zero.
S1.u[7] – value is a positive denormal value.
S1.u[8] – value is a positive normal value.
S1.u[9] – value is positive infinity.</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>V_CMPX_CLASS
_F64</td>
<td>EXEC = VCC = IEEE numeric class function specified
in S1.u, performed on S0.d The function reports
true if the floating point value is *any* of the
numeric types selected in S1.u according to the
following list: S1.u[0] – value is a signaling
NaN. S1.u[1] – value is a quiet NaN. S1.u[2] –
value is negative infinity. S1.u[3] – value is a
negative normal value. S1.u[4] – value is a
negative denormal value. S1.u[5] – value is
negative zero. S1.u[6] – value is positive zero.
S1.u[7] – value is a positive denormal value.
S1.u[8] – value is a positive normal value.
S1.u[9] – value is positive infinity.</td>
</tr>
<tr class="row-even"><td>20</td>
<td>V_CMP_CLASS_F16</td>
<td>VCC = IEEE numeric class function specified in
S1.u, performed on S0.f16. Note that the S1 has a
format of f16 since floating point literal
constants are interpreted as 16 bit value for this
opcode The function reports true if the floating
point value is *any* of the numeric types
selected in S1.u according to the following list:
S1.u[0] – value is a signaling NaN. S1.u[1] –
value is a quiet NaN. S1.u[2] – value is negative
infinity. S1.u[3] – value is a negative normal
value. S1.u[4] – value is a negative denormal
value. S1.u[5] – value is negative zero. S1.u[6]
– value is positive zero. S1.u[7] – value is a
positive denormal value. S1.u[8] – value is a
positive normal value. S1.u[9] – value is
positive infinity.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>V_CMPX_CLASS
_F16</td>
<td>EXEC = VCC = IEEE numeric class function specified
in S1.u, performed on S0.f16 Note that the S1 has
a format of f16 since floating point literal
constants are interpreted as 16 bit value for this
opcode The function reports true if the floating
point value is *any* of the numeric types
selected in S1.u according to the following list:
S1.u[0] – value is a signaling NaN. S1.u[1] –
value is a quiet NaN. S1.u[2] – value is negative
infinity. S1.u[3] – value is a negative normal
value. S1.u[4] – value is a negative denormal
value. S1.u[5] – value is negative zero. S1.u[6]
– value is positive zero. S1.u[7] – value is a
positive denormal value. S1.u[8] – value is a
positive normal value. S1.u[9] – value is
positive infinity.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>V_CMP_F_F16</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>V_CMP_LT_F1
6</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>34</td>
<td>V_CMP_EQ_F1
6</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>V_CMP_LE_F1
6</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>36</td>
<td>V_CMP_GT_F1
6</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>V_CMP_LG_F1
6</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>38</td>
<td>V_CMP_GE_F1
6</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>V_CMP_O_F16</td>
<td>D.u64[threadId] = (!isNan(S0) &amp;&amp; !isNan(S1)).</td>
</tr>
<tr class="row-even"><td>40</td>
<td>V_CMP_U_F16</td>
<td>D.u64[threadId] = (isNan(S0) || isNan(S1)).</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>V_CMP_NGE_F
16</td>
<td>D.u64[threadId] = !(S0 &gt;= S1) // With NAN inputs
this is not the same operation as &lt;.</td>
</tr>
<tr class="row-even"><td>42</td>
<td>V_CMP_NLG_F
16</td>
<td>D.u64[threadId] = !(S0 &lt;&gt; S1) // With NAN inputs
this is not the same operation as ==.</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>V_CMP_NGT_F
16</td>
<td>D.u64[threadId] = !(S0 &gt; S1) // With NAN inputs
this is not the same operation as &lt;=.</td>
</tr>
<tr class="row-even"><td>44</td>
<td>V_CMP_NLE_F
16</td>
<td>D.u64[threadId] = !(S0 &lt;= S1) // With NAN inputs
this is not the same operation as &gt;.</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>V_CMP_NEQ_F
16</td>
<td>D.u64[threadId] = !(S0 == S1) // With NAN inputs
this is not the same operation as !=.</td>
</tr>
<tr class="row-even"><td>46</td>
<td>V_CMP_NLT_F
16</td>
<td>D.u64[threadId] = !(S0 &lt; S1) // With NAN inputs
this is not the same operation as &gt;=.</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>V_CMP_TRU_F
16</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>48</td>
<td>V_CMPX_F_F1
6</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>V_CMPX_LT_F
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>50</td>
<td>V_CMPX_EQ_F
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>V_CMPX_LE_F
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>52</td>
<td>V_CMPX_GT_F
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>V_CMPX_LG_F
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>54</td>
<td>V_CMPX_GE_F
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>V_CMPX_O_F1
6</td>
<td>EXEC[threadId] = D.u64[threadId] = (!isNan(S0) &amp;&amp;
!isNan(S1)).</td>
</tr>
<tr class="row-even"><td>56</td>
<td>V_CMPX_U_F1
6</td>
<td>EXEC[threadId] = D.u64[threadId] = (isNan(S0) ||
isNan(S1)).</td>
</tr>
<tr class="row-odd"><td>57</td>
<td>V_CMPX_NGE_
F16</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &gt;= S1) //
With NAN inputs this is not the same operation as
&lt;.</td>
</tr>
<tr class="row-even"><td>58</td>
<td>V_CMPX_NLG_
F16</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt;&gt; S1) //
With NAN inputs this is not the same operation as
==.</td>
</tr>
<tr class="row-odd"><td>59</td>
<td>V_CMPX_NGT_
F16</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &gt; S1) //
With NAN inputs this is not the same operation as
&lt;=.</td>
</tr>
<tr class="row-even"><td>60</td>
<td>V_CMPX_NLE_
F16</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt;= S1) //
With NAN inputs this is not the same operation as
&gt;.</td>
</tr>
<tr class="row-odd"><td>61</td>
<td>V_CMPX_NEQ_
F16</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 == S1) //
With NAN inputs this is not the same operation as
!=.</td>
</tr>
<tr class="row-even"><td>62</td>
<td>V_CMPX_NLT_
F16</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt; S1) //
With NAN inputs this is not the same operation as
&gt;=.</td>
</tr>
<tr class="row-odd"><td>63</td>
<td>V_CMPX_TRU_
F16</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>64</td>
<td>V_CMP_F_F32</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>V_CMP_LT_F3
2</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>66</td>
<td>V_CMP_EQ_F3
2</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>V_CMP_LE_F3
2</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>68</td>
<td>V_CMP_GT_F3
2</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>V_CMP_LG_F3
2</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>70</td>
<td>V_CMP_GE_F3
2</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>V_CMP_O_F32</td>
<td>D.u64[threadId] = (!isNan(S0) &amp;&amp; !isNan(S1)).</td>
</tr>
<tr class="row-even"><td>72</td>
<td>V_CMP_U_F32</td>
<td>D.u64[threadId] = (isNan(S0) || isNan(S1)).</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>V_CMP_NGE_F
32</td>
<td>D.u64[threadId] = !(S0 &gt;= S1) // With NAN inputs
this is not the same operation as &lt;.</td>
</tr>
<tr class="row-even"><td>74</td>
<td>V_CMP_NLG_F
32</td>
<td>D.u64[threadId] = !(S0 &lt;&gt; S1) // With NAN inputs
this is not the same operation as ==.</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>V_CMP_NGT_F
32</td>
<td>D.u64[threadId] = !(S0 &gt; S1) // With NAN inputs
this is not the same operation as &lt;=.</td>
</tr>
<tr class="row-even"><td>76</td>
<td>V_CMP_NLE_F
32</td>
<td>D.u64[threadId] = !(S0 &lt;= S1) // With NAN inputs
this is not the same operation as &gt;.</td>
</tr>
<tr class="row-odd"><td>77</td>
<td>V_CMP_NEQ_F
32</td>
<td>D.u64[threadId] = !(S0 == S1) // With NAN inputs
this is not the same operation as !=.</td>
</tr>
<tr class="row-even"><td>78</td>
<td>V_CMP_NLT_F
32</td>
<td>D.u64[threadId] = !(S0 &lt; S1) // With NAN inputs
this is not the same operation as &gt;=.</td>
</tr>
<tr class="row-odd"><td>79</td>
<td>V_CMP_TRU_F
32</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>80</td>
<td>V_CMPX_F_F3
2</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>81</td>
<td>V_CMPX_LT_F
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>82</td>
<td>V_CMPX_EQ_F
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>83</td>
<td>V_CMPX_LE_F
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>84</td>
<td>V_CMPX_GT_F
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>85</td>
<td>V_CMPX_LG_F
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>86</td>
<td>V_CMPX_GE_F
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>87</td>
<td>V_CMPX_O_F3
2</td>
<td>EXEC[threadId] = D.u64[threadId] = (!isNan(S0) &amp;&amp;
!isNan(S1)).</td>
</tr>
<tr class="row-even"><td>88</td>
<td>V_CMPX_U_F3
2</td>
<td>EXEC[threadId] = D.u64[threadId] = (isNan(S0) ||
isNan(S1)).</td>
</tr>
<tr class="row-odd"><td>89</td>
<td>V_CMPX_NGE_
F32</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &gt;= S1) //
With NAN inputs this is not the same operation as
&lt;.</td>
</tr>
<tr class="row-even"><td>90</td>
<td>V_CMPX_NLG_
F32</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt;&gt; S1) //
With NAN inputs this is not the same operation as
==.</td>
</tr>
<tr class="row-odd"><td>91</td>
<td>V_CMPX_NGT_
F32</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &gt; S1) //
With NAN inputs this is not the same operation as
&lt;=.</td>
</tr>
<tr class="row-even"><td>92</td>
<td>V_CMPX_NLE_
F32</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt;= S1) //
With NAN inputs this is not the same operation as
&gt;.</td>
</tr>
<tr class="row-odd"><td>93</td>
<td>V_CMPX_NEQ_
F32</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 == S1) //
With NAN inputs this is not the same operation as
!=.</td>
</tr>
<tr class="row-even"><td>94</td>
<td>V_CMPX_NLT_
F32</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt; S1) //
With NAN inputs this is not the same operation as
&gt;=.</td>
</tr>
<tr class="row-odd"><td>95</td>
<td>V_CMPX_TRU_
F32</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>96</td>
<td>V_CMP_F_F64</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>97</td>
<td>V_CMP_LT_F6
4</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>98</td>
<td>V_CMP_EQ_F6
4</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>99</td>
<td>V_CMP_LE_F6
4</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>100</td>
<td>V_CMP_GT_F6
4</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>101</td>
<td>V_CMP_LG_F6
4</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>102</td>
<td>V_CMP_GE_F6
4</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>103</td>
<td>V_CMP_O_F64</td>
<td>D.u64[threadId] = (!isNan(S0) &amp;&amp; !isNan(S1)).</td>
</tr>
<tr class="row-even"><td>104</td>
<td>V_CMP_U_F64</td>
<td>D.u64[threadId] = (isNan(S0) || isNan(S1)).</td>
</tr>
<tr class="row-odd"><td>105</td>
<td>V_CMP_NGE_F
64</td>
<td>D.u64[threadId] = !(S0 &gt;= S1) // With NAN inputs
this is not the same operation as &lt;.</td>
</tr>
<tr class="row-even"><td>106</td>
<td>V_CMP_NLG_F
64</td>
<td>D.u64[threadId] = !(S0 &lt;&gt; S1) // With NAN inputs
this is not the same operation as ==.</td>
</tr>
<tr class="row-odd"><td>107</td>
<td>V_CMP_NGT_F
64</td>
<td>D.u64[threadId] = !(S0 &gt; S1) // With NAN inputs
this is not the same operation as &lt;=.</td>
</tr>
<tr class="row-even"><td>108</td>
<td>V_CMP_NLE_F
64</td>
<td>D.u64[threadId] = !(S0 &lt;= S1) // With NAN inputs
this is not the same operation as &gt;.</td>
</tr>
<tr class="row-odd"><td>109</td>
<td>V_CMP_NEQ_F
64</td>
<td>D.u64[threadId] = !(S0 == S1) // With NAN inputs
this is not the same operation as !=.</td>
</tr>
<tr class="row-even"><td>110</td>
<td>V_CMP_NLT_F
64</td>
<td>D.u64[threadId] = !(S0 &lt; S1) // With NAN inputs
this is not the same operation as &gt;=.</td>
</tr>
<tr class="row-odd"><td>111</td>
<td>V_CMP_TRU_F
64</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>112</td>
<td>V_CMPX_F_F6
4</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>113</td>
<td>V_CMPX_LT_F
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>114</td>
<td>V_CMPX_EQ_F
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>115</td>
<td>V_CMPX_LE_F
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>116</td>
<td>V_CMPX_GT_F
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>117</td>
<td>V_CMPX_LG_F
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>118</td>
<td>V_CMPX_GE_F
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>119</td>
<td>V_CMPX_O_F6
4</td>
<td>EXEC[threadId] = D.u64[threadId] = (!isNan(S0) &amp;&amp;
!isNan(S1)).</td>
</tr>
<tr class="row-even"><td>120</td>
<td>V_CMPX_U_F6
4</td>
<td>EXEC[threadId] = D.u64[threadId] = (isNan(S0) ||
isNan(S1)).</td>
</tr>
<tr class="row-odd"><td>121</td>
<td>V_CMPX_NGE_
F64</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &gt;= S1) //
With NAN inputs this is not the same operation as
&lt;.</td>
</tr>
<tr class="row-even"><td>122</td>
<td>V_CMPX_NLG_
F64</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt;&gt; S1) //
With NAN inputs this is not the same operation as
==.</td>
</tr>
<tr class="row-odd"><td>123</td>
<td>V_CMPX_NGT_
F64</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &gt; S1) //
With NAN inputs this is not the same operation as
&lt;=.</td>
</tr>
<tr class="row-even"><td>124</td>
<td>V_CMPX_NLE_
F64</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt;= S1) //
With NAN inputs this is not the same operation as
&gt;.</td>
</tr>
<tr class="row-odd"><td>125</td>
<td>V_CMPX_NEQ_
F64</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 == S1) //
With NAN inputs this is not the same operation as
!=.</td>
</tr>
<tr class="row-even"><td>126</td>
<td>V_CMPX_NLT_
F64</td>
<td>EXEC[threadId] = D.u64[threadId] = !(S0 &lt; S1) //
With NAN inputs this is not the same operation as
&gt;=.</td>
</tr>
<tr class="row-odd"><td>127</td>
<td>V_CMPX_TRU_
F64</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>160</td>
<td>V_CMP_F_I16</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>161</td>
<td>V_CMP_LT_I1
6</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>162</td>
<td>V_CMP_EQ_I1
6</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>163</td>
<td>V_CMP_LE_I1
6</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>164</td>
<td>V_CMP_GT_I1
6</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>165</td>
<td>V_CMP_NE_I1
6</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>166</td>
<td>V_CMP_GE_I1
6</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>167</td>
<td>V_CMP_T_I16</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>168</td>
<td>V_CMP_F_U16</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>169</td>
<td>V_CMP_LT_U1
6</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>170</td>
<td>V_CMP_EQ_U1
6</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>171</td>
<td>V_CMP_LE_U1
6</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>172</td>
<td>V_CMP_GT_U1
6</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>173</td>
<td>V_CMP_NE_U1
6</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>174</td>
<td>V_CMP_GE_U1
6</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>175</td>
<td>V_CMP_T_U16</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>176</td>
<td>V_CMPX_F_I1
6</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>177</td>
<td>V_CMPX_LT_I
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>178</td>
<td>V_CMPX_EQ_I
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>179</td>
<td>V_CMPX_LE_I
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>180</td>
<td>V_CMPX_GT_I
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>181</td>
<td>V_CMPX_NE_I
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>182</td>
<td>V_CMPX_GE_I
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>183</td>
<td>V_CMPX_T_I1
6</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>184</td>
<td>V_CMPX_F_U1
6</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>185</td>
<td>V_CMPX_LT_U
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>186</td>
<td>V_CMPX_EQ_U
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>187</td>
<td>V_CMPX_LE_U
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>188</td>
<td>V_CMPX_GT_U
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>189</td>
<td>V_CMPX_NE_U
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>190</td>
<td>V_CMPX_GE_U
16</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>191</td>
<td>V_CMPX_T_U1
6</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>192</td>
<td>V_CMP_F_I32</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>193</td>
<td>V_CMP_LT_I3
2</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>194</td>
<td>V_CMP_EQ_I3
2</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>195</td>
<td>V_CMP_LE_I3
2</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>196</td>
<td>V_CMP_GT_I3
2</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>197</td>
<td>V_CMP_NE_I3
2</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>198</td>
<td>V_CMP_GE_I3
2</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>199</td>
<td>V_CMP_T_I32</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>200</td>
<td>V_CMP_F_U32</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>201</td>
<td>V_CMP_LT_U3
2</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>202</td>
<td>V_CMP_EQ_U3
2</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>203</td>
<td>V_CMP_LE_U3
2</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>204</td>
<td>V_CMP_GT_U3
2</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>205</td>
<td>V_CMP_NE_U3
2</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>206</td>
<td>V_CMP_GE_U3
2</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>207</td>
<td>V_CMP_T_U32</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>208</td>
<td>V_CMPX_F_I3
2</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>209</td>
<td>V_CMPX_LT_I
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>210</td>
<td>V_CMPX_EQ_I
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>211</td>
<td>V_CMPX_LE_I
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>212</td>
<td>V_CMPX_GT_I
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>213</td>
<td>V_CMPX_NE_I
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>214</td>
<td>V_CMPX_GE_I
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>215</td>
<td>V_CMPX_T_I3
2</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>216</td>
<td>V_CMPX_F_U3
2</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>217</td>
<td>V_CMPX_LT_U
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>218</td>
<td>V_CMPX_EQ_U
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>219</td>
<td>V_CMPX_LE_U
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>220</td>
<td>V_CMPX_GT_U
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>221</td>
<td>V_CMPX_NE_U
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>222</td>
<td>V_CMPX_GE_U
32</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>223</td>
<td>V_CMPX_T_U3
2</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>224</td>
<td>V_CMP_F_I64</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>225</td>
<td>V_CMP_LT_I6
4</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>226</td>
<td>V_CMP_EQ_I6
4</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>227</td>
<td>V_CMP_LE_I6
4</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>228</td>
<td>V_CMP_GT_I6
4</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>229</td>
<td>V_CMP_NE_I6
4</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>230</td>
<td>V_CMP_GE_I6
4</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>231</td>
<td>V_CMP_T_I64</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>232</td>
<td>V_CMP_F_U64</td>
<td>D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>233</td>
<td>V_CMP_LT_U6
4</td>
<td>D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>234</td>
<td>V_CMP_EQ_U6
4</td>
<td>D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>235</td>
<td>V_CMP_LE_U6
4</td>
<td>D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>236</td>
<td>V_CMP_GT_U6
4</td>
<td>D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>237</td>
<td>V_CMP_NE_U6
4</td>
<td>D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>238</td>
<td>V_CMP_GE_U6
4</td>
<td>D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>239</td>
<td>V_CMP_T_U64</td>
<td>D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>240</td>
<td>V_CMPX_F_I6
4</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>241</td>
<td>V_CMPX_LT_I
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>242</td>
<td>V_CMPX_EQ_I
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>243</td>
<td>V_CMPX_LE_I
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>244</td>
<td>V_CMPX_GT_I
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>245</td>
<td>V_CMPX_NE_I
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>246</td>
<td>V_CMPX_GE_I
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>247</td>
<td>V_CMPX_T_I6
4</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
<tr class="row-even"><td>248</td>
<td>V_CMPX_F_U6
4</td>
<td>EXEC[threadId] = D.u64[threadId] = 0.</td>
</tr>
<tr class="row-odd"><td>249</td>
<td>V_CMPX_LT_U
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt; S1).</td>
</tr>
<tr class="row-even"><td>250</td>
<td>V_CMPX_EQ_U
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 == S1).</td>
</tr>
<tr class="row-odd"><td>251</td>
<td>V_CMPX_LE_U
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;= S1).</td>
</tr>
<tr class="row-even"><td>252</td>
<td>V_CMPX_GT_U
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt; S1).</td>
</tr>
<tr class="row-odd"><td>253</td>
<td>V_CMPX_NE_U
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &lt;&gt; S1).</td>
</tr>
<tr class="row-even"><td>254</td>
<td>V_CMPX_GE_U
64</td>
<td>EXEC[threadId] = D.u64[threadId] = (S0 &gt;= S1).</td>
</tr>
<tr class="row-odd"><td>255</td>
<td>V_CMPX_T_U6
4</td>
<td>EXEC[threadId] = D.u64[threadId] = 1.</td>
</tr>
</tbody>
</table>
<p>Table: VOPC Compare Opcodes</p>
<div class="section" id="vopc-using-vop3a-encoding">
<h4>VOPC using VOP3A encoding<a class="headerlink" href="#vopc-using-vop3a-encoding" title="Permalink to this headline">¶</a></h4>
<p>Instructions in this format may also be encoded as VOP3A. This allows
access to the extra control bits (e.g. ABS, OMOD) in exchange for not
being able to use a literal constant. The VOP3 opcode is: VOP2 opcode +
0x000.</p>
<p>When the CLAMP microcode bit is set to 1, these compare instructions
signal an exception when either of the inputs is NaN. When CLAMP is set
to zero, NaN does not signal an exception. The second eight VOPC
instructions have {OP8} embedded in them. This refers to each of the
compare operations listed below.</p>
<p><img alt="microcode vop3a" src="../_images/microcode_vop3a.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">where</span><span class="p">:</span>

  <span class="n">VDST</span> <span class="o">=</span> <span class="n">Destination</span> <span class="k">for</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">VGPR</span><span class="o">.</span>
  <span class="n">ABS</span> <span class="o">=</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">absolute</span> <span class="n">value</span><span class="o">.</span>
  <span class="n">CLMP</span> <span class="o">=</span> <span class="n">Clamp</span> <span class="n">output</span><span class="o">.</span>
  <span class="n">OP</span> <span class="o">=</span> <span class="n">Instructions</span><span class="o">.</span>
  <span class="n">SRC0</span> <span class="o">=</span> <span class="n">First</span> <span class="n">operand</span> <span class="k">for</span> <span class="n">instruction</span><span class="o">.</span>
  <span class="n">SRC1</span> <span class="o">=</span> <span class="n">Second</span> <span class="n">operand</span> <span class="k">for</span> <span class="n">instruction</span><span class="o">.</span>
  <span class="n">SRC2</span> <span class="o">=</span> <span class="n">Third</span> <span class="n">operand</span> <span class="k">for</span> <span class="n">instruction</span><span class="o">.</span> <span class="n">Unused</span> <span class="ow">in</span> <span class="n">VOPC</span> <span class="n">instructions</span><span class="o">.</span>
  <span class="n">OMOD</span> <span class="o">=</span> <span class="n">Output</span> <span class="n">modifier</span> <span class="k">for</span> <span class="n">instruction</span><span class="o">.</span> <span class="n">Unused</span> <span class="ow">in</span> <span class="n">VOPC</span> <span class="n">instructions</span><span class="o">.</span>
  <span class="n">NEG</span> <span class="o">=</span> <span class="n">Floating</span><span class="o">-</span><span class="n">point</span> <span class="n">negation</span><span class="o">.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="vop3p-instructions">
<h3>VOP3P Instructions<a class="headerlink" href="#vop3p-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode vop3p" src="../_images/microcode_vop3p.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="22%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>V_PK_MAD_I16</td>
<td>D.i[31:16] = S0.i[31:16] * S1.i[31:16] +
S2.i[31:16] . D.i[15:0] = S0.i[15:0] *
S1.i[15:0] + S2.i[15:0] .</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>V_PK_MUL_LO_U16</td>
<td>D.u[31:16] = S0.u[31:16] * S1.u[31:16] .
D.u[15:0] = S0.u[15:0] * S1.u[15:0] .</td>
</tr>
<tr class="row-even"><td>2</td>
<td>V_PK_ADD_I16</td>
<td>D.i[31:16] = S0.i[31:16] + S1.i[31:16] .
D.i[15:0] = S0.i[15:0] + S1.i[15:0] .</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>V_PK_SUB_I16</td>
<td>D.i[31:16] = S0.i[31:16] - S1.i[31:16] .
D.i[15:0] = S0.i[15:0] - S1.i[15:0] .</td>
</tr>
<tr class="row-even"><td>4</td>
<td>V_PK_LSHLREV_B16</td>
<td>D.u[31:16] = S1.u[31:16] &lt;&lt; S0.u[19:16] .
D.u[15:0] = S1.u[15:0] &lt;&lt; S0.u[3:0] .</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>V_PK_LSHRREV_B16</td>
<td>D.u[31:16] = S1.u[31:16] &gt;&gt; S0.u[19:16] .
D.u[15:0] = S1.u[15:0] &gt;&gt; S0.u[3:0] .</td>
</tr>
<tr class="row-even"><td>6</td>
<td>V_PK_ASHRREV_I16</td>
<td>D.i[31:16] = S1.i[31:16] &gt;&gt; S0.i[19:16] .
D.i[15:0] = S1.i[15:0] &gt;&gt; S0.i[3:0] .</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>V_PK_MAX_I16</td>
<td>D.i[31:16] = (S0.i[31:16] &gt;= S1.i[31:16]) ?
S0.i[31:16] : S1.i[31:16] . D.i[15:0] =
(S0.i[15:0] &gt;= S1.i[15:0]) ? S0.i[15:0] :
S1.i[15:0] .</td>
</tr>
<tr class="row-even"><td>8</td>
<td>V_PK_MIN_I16</td>
<td>D.i[31:16] = (S0.i[31:16] &lt; S1.i[31:16]) ?
S0.i[31:16] : S1.i[31:16] . D.i[15:0] =
(S0.i[15:0] &lt; S1.i[15:0]) ? S0.i[15:0] :
S1.i[15:0]</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>V_PK_MAD_U16</td>
<td>D.u[31:16] = S0.u[31:16] * S1.u[31:16] +
S2.u[31:16] . D.u[15:0] = S0.u[15:0] *
S1.u[15:0] + S2.u[15:0] .</td>
</tr>
<tr class="row-even"><td>10</td>
<td>V_PK_ADD_U16</td>
<td>D.u[31:16] = S0.u[31:16] + S1.u[31:16] .
D.u[15:0] = S0.u[15:0] + S1.u[15:0] .</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>V_PK_SUB_U16</td>
<td>D.u[31:16] = S0.u[31:16] - S1.u[31:16] .
D.u[15:0] = S0.u[15:0] - S1.u[15:0] .</td>
</tr>
<tr class="row-even"><td>12</td>
<td>V_PK_MAX_U16</td>
<td>D.u[31:16] = (S0.u[31:16] &gt;= S1.u[31:16]) ?
S0.u[31:16] : S1.u[31:16] . D.u[15:0] =
(S0.u[15:0] &gt;= S1.u[15:0]) ? S0.u[15:0] :
S1.u[15:0] .</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>V_PK_MIN_U16</td>
<td>D.u[31:16] = (S0.u[31:16] &lt; S1.u[31:16]) ?
S0.u[31:16] : S1.u[31:16] . D.u[15:0] =
(S0.u[15:0] &lt; S1.u[15:0]) ? S0.u[15:0] :
S1.u[15:0] .</td>
</tr>
<tr class="row-even"><td>14</td>
<td>V_PK_FMA_F16</td>
<td>D.f[31:16] = S0.f[31:16] * S1.f[31:16] +
S2.f[31:16] . D.f[15:0] = S0.f[15:0] *
S1.f[15:0] + S2.f[15:0] . Fused half-precision
multiply add.</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>V_PK_ADD_F16</td>
<td>D.f[31:16] = S0.f[31:16] + S1.f[31:16] .
D.f[15:0] = S0.f[15:0] + S1.f[15:0] .</td>
</tr>
<tr class="row-even"><td>16</td>
<td>V_PK_MUL_F16</td>
<td>D.f[31:16] = S0.f[31:16] * S1.f[31:16] .
D.f[15:0] = S0.f[15:0] * S1.f[15:0] .</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>V_PK_MIN_F16</td>
<td>D.f[31:16] = min(S0.f[31:16], S1.f[31:16]) .
D.f[15:0] = min(S0.f[15:0], S1.u[15:0]) .</td>
</tr>
<tr class="row-even"><td>18</td>
<td>V_PK_MAX_F16</td>
<td>D.f[31:16] = max(S0.f[31:16], S1.f[31:16]) .
D.f[15:0] = max(S0.f[15:0], S1.f[15:0]) .</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>V_MAD_MIX_F3
2</td>
<td>D.f[31:0] = S0.f * S1.f + S2.f. Size and
location of S0, S1 and S2 controlled by OPSEL:
0=src[31:0], 1=src[31:0], 2=src[15:0],
3=src[31:16]. Also, for MAD_MIX, the NEG_HI
field acts instead as an absolute-value modifier.</td>
</tr>
<tr class="row-even"><td>33</td>
<td>V_MAD_MIXLO_
F16</td>
<td>D.f[15:0] = S0.f * S1.f + S2.f. Size and
location of S0, S1 and S2 controlled by OPSEL:
0=src[31:0], 1=src[31:0], 2=src[15:0],
3=src[31:16]. Also, for MAD_MIX, the NEG_HI
field acts instead as an absolute-value modifier.</td>
</tr>
<tr class="row-odd"><td>34</td>
<td>V_MAD_MIXHI_
F16</td>
<td>D.f[31:16] = S0.f * S1.f + S2.f. Size and
location of S0, S1 and S2 controlled by OPSEL:
0=src[31:0], 1=src[31:0], 2=src[15:0],
3=src[31:16]. Also, for MAD_MIX, the NEG_HI
field acts instead as an absolute-value modifier.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="vinterp-instructions">
<h3>VINTERP Instructions<a class="headerlink" href="#vinterp-instructions" title="Permalink to this headline">¶</a></h3>
<p><img alt="microcode vintrp" src="../_images/microcode_vintrp.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>V_INTERP_P1_F32</td>
<td>D.f = P10 * S.f + P0. Parameter interpolation.
CAUTION: when in HALF_LDS mode, D must not be the
same GPR as S; if D == S then data corruption will
occur. NOTE: In textual representations the I/J
VGPR is the first source and the attribute is the
second source; however in the VOP3 encoding the
attribute is stored in the src0 field and the VGPR
is stored in the src1 field.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>V_INTERP_P2_F32</td>
<td>D.f = P20 * S.f + D.f. Parameter interpolation.
NOTE: In textual representations the I/J VGPR is
the first source and the attribute is the second
source; however in the VOP3 encoding the attribute
is stored in the src0 field and the VGPR is stored
in the src1 field.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>V_INTERP_MOV
_F32</td>
<td>D.f = {P10,P20,P0}[S.u]. Parameter load. Used for
custom interpolation in the shader.</td>
</tr>
</tbody>
</table>
<div class="section" id="vinterp-using-vop3-encoding">
<h4>VINTERP using VOP3 encoding<a class="headerlink" href="#vinterp-using-vop3-encoding" title="Permalink to this headline">¶</a></h4>
<p>Instructions in this format may also be encoded as VOP3A. This allows
access to the extra control bits (e.g. ABS, OMOD) in exchange for not
being able to use a literal constant. The VOP3 opcode is: VOP2 opcode +
0x270.</p>
<p><img alt="microcode vop3a" src="../_images/microcode_vop3a.png" /></p>
</div>
</div>
<div class="section" id="vop3a-vop3b-instructions">
<h3>VOP3A &amp; VOP3B Instructions<a class="headerlink" href="#vop3a-vop3b-instructions" title="Permalink to this headline">¶</a></h3>
<p>VOP3 instructions use one of two encodings:</p>
<p><img alt="microcode vop3a" src="../_images/microcode_vop3a.png" /></p>
<p><img alt="microcode vop3b" src="../_images/microcode_vop3b.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>VOP3B</td>
<td><div class="first last line-block">
<div class="line">this encoding allows specifying a unique scalar
destination, and is used only for:</div>
<div class="line">V_ADD_CO_U32</div>
<div class="line">V_SUB_CO_U32</div>
<div class="line">V_SUBREV_CO_U32</div>
<div class="line">V_ADDC_CO_U32</div>
<div class="line">V_SUBB_CO_U32</div>
<div class="line">V_SUBBREV_CO_U32</div>
<div class="line">V_DIV_SCALE_F32</div>
<div class="line">V_DIV_SCALE_F64</div>
<div class="line">V_MAD_U64_U32</div>
<div class="line">V_MAD_I64_I32</div>
</div>
</td>
</tr>
<tr class="row-even"><td>VOP3A</td>
<td>all other VALU instructions use this encoding</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>448</td>
<td>V_MAD_LEGACY
_F32</td>
<td>D.f = S0.f * S1.f + S2.f. // DX9 rules, 0.0 * x
= 0.0</td>
</tr>
<tr class="row-odd"><td>449</td>
<td>V_MAD_F32</td>
<td>D.f = S0.f * S1.f + S2.f. 1ULP accuracy,
denormals are flushed.</td>
</tr>
<tr class="row-even"><td>450</td>
<td>V_MAD_I32_I
24</td>
<td>D.i = S0.i[23:0] * S1.i[23:0] + S2.i.</td>
</tr>
<tr class="row-odd"><td>451</td>
<td>V_MAD_U32_U
24</td>
<td>D.u = S0.u[23:0] * S1.u[23:0] + S2.u.</td>
</tr>
<tr class="row-even"><td>452</td>
<td>V_CUBEID_F32</td>
<td>D.f = cubemap face ID ({0.0, 1.0, …, 5.0}). XYZ
coordinate is given in (S0.f, S1.f, S2.f). Cubemap
Face ID determination. Result is a floating point
face ID. S0.f = x S1.f = y S2.f = z If (Abs(S2.f)
&gt;= Abs(S0.f) &amp;&amp; Abs(S2.f) &gt;= Abs(S1.f)) If (S2.f &lt;
0) D.f = 5.0 Else D.f = 4.0 Else if (Abs(S1.f) &gt;=
Abs(S0.f)) If (S1.f &lt; 0) D.f = 3.0 Else D.f = 2.0
Else If (S0.f &lt; 0) D.f = 1.0 Else D.f = 0.0</td>
</tr>
<tr class="row-odd"><td>453</td>
<td>V_CUBESC_F32</td>
<td>D.f = cubemap S coordinate. XYZ coordinate is
given in (S0.f, S1.f, S2.f). S0.f = x S1.f = y
S2.f = z If (Abs(S2.f) &gt;= Abs(S0.f) &amp;&amp; Abs(S2.f)
&gt;= Abs(S1.f)) If (S2.f &lt; 0) D.f = -S0.f Else D.f =
S0.f Else if (Abs(S1.f) &gt;= Abs(S0.f)) D.f = S0.f
Else If (S0.f &lt; 0) D.f = S2.f Else D.f = -S2.f</td>
</tr>
<tr class="row-even"><td>454</td>
<td>V_CUBETC_F32</td>
<td>D.f = cubemap T coordinate. XYZ coordinate is
given in (S0.f, S1.f, S2.f). S0.f = x S1.f = y
S2.f = z If (Abs(S2.f) &gt;= Abs(S0.f) &amp;&amp; Abs(S2.f)
&gt;= Abs(S1.f)) D.f = -S1.f Else if (Abs(S1.f) &gt;=
Abs(S0.f)) If (S1.f &lt; 0) D.f = -S2.f Else D.f =
S2.f Else D.f = -S1.f</td>
</tr>
<tr class="row-odd"><td>455</td>
<td>V_CUBEMA_F32</td>
<td>D.f = 2.0 * cubemap major axis. XYZ coordinate is
given in (S0.f, S1.f, S2.f). S0.f = x S1.f = y
S2.f = z If (Abs(S2.f) &gt;= Abs(S0.f) &amp;&amp; Abs(S2.f)
&gt;= Abs(S1.f)) D.f = 2.0*S2.f Else if (Abs(S1.f)
&gt;= Abs(S0.f)) D.f = 2.0 * S1.f Else D.f = 2.0 *
S0.f</td>
</tr>
<tr class="row-even"><td>456</td>
<td>V_BFE_U32</td>
<td>D.u = (S0.u &gt;&gt; S1.u[4:0]) &amp; ((1 &lt;&lt; S2.u[4:0]) -
1). Bitfield extract with S0 = data, S1 =
field_offset, S2 = field_width.</td>
</tr>
<tr class="row-odd"><td>457</td>
<td>V_BFE_I32</td>
<td>D.i = (S0.i &gt;&gt; S1.u[4:0]) &amp; ((1 &lt;&lt; S2.u[4:0]) -
1). Bitfield extract with S0 = data, S1 =
field_offset, S2 = field_width.</td>
</tr>
<tr class="row-even"><td>458</td>
<td>V_BFI_B32</td>
<td>D.u = (S0.u &amp; S1.u) | (~S0.u &amp; S2.u). Bitfield
insert.</td>
</tr>
<tr class="row-odd"><td>459</td>
<td>V_FMA_F32</td>
<td>D.f = S0.f * S1.f + S2.f. Fused single precision
multiply add. 0.5ULP accuracy, denormals are
supported.</td>
</tr>
<tr class="row-even"><td>460</td>
<td>V_FMA_F64</td>
<td>D.d = S0.d * S1.d + S2.d. Fused double precision
multiply add. 0.5ULP precision, denormals are
supported.</td>
</tr>
<tr class="row-odd"><td>461</td>
<td>V_LERP_U8</td>
<td>D.u = ((S0.u[31:24] + S1.u[31:24] + S2.u[24]) &gt;&gt;
1) &lt;&lt; 24 D.u += ((S0.u[23:16] + S1.u[23:16] +
S2.u[16]) &gt;&gt; 1) &lt;&lt; 16; D.u += ((S0.u[15:8] +
S1.u[15:8] + S2.u[8]) &gt;&gt; 1) &lt;&lt; 8; D.u +=
((S0.u[7:0] + S1.u[7:0] + S2.u[0]) &gt;&gt; 1). Unsigned
8-bit pixel average on packed unsigned bytes
(linear interpolation). S2 acts as a round mode;
if set, 0.5 rounds up, otherwise 0.5 truncates.</td>
</tr>
<tr class="row-even"><td>462</td>
<td>V_ALIGNBIT_B
32</td>
<td>D.u = ({S0,S1} &gt;&gt; S2.u[4:0]) &amp; 0xffffffff.</td>
</tr>
<tr class="row-odd"><td>463</td>
<td>V_ALIGNBYTE_
B32</td>
<td>D.u = ({S0,S1} &gt;&gt; (8*S2.u[4:0])) &amp; 0xffffffff.</td>
</tr>
<tr class="row-even"><td>464</td>
<td>V_MIN3_F32</td>
<td>D.f = V_MIN_F32(V_MIN_F32(S0.f, S1.f), S2.f).</td>
</tr>
<tr class="row-odd"><td>465</td>
<td>V_MIN3_I32</td>
<td>D.i = V_MIN_I32(V_MIN_I32(S0.i, S1.i), S2.i).</td>
</tr>
<tr class="row-even"><td>466</td>
<td>V_MIN3_U32</td>
<td>D.u = V_MIN_U32(V_MIN_U32(S0.u, S1.u), S2.u).</td>
</tr>
<tr class="row-odd"><td>467</td>
<td>V_MAX3_F32</td>
<td>D.f = V_MAX_F32(V_MAX_F32(S0.f, S1.f), S2.f).</td>
</tr>
<tr class="row-even"><td>468</td>
<td>V_MAX3_I32</td>
<td>D.i = V_MAX_I32(V_MAX_I32(S0.i, S1.i), S2.i).</td>
</tr>
<tr class="row-odd"><td>469</td>
<td>V_MAX3_U32</td>
<td>D.u = V_MAX_U32(V_MAX_U32(S0.u, S1.u), S2.u).</td>
</tr>
<tr class="row-even"><td>470</td>
<td>V_MED3_F32</td>
<td>if (isNan(S0.f) || isNan(S1.f) || isNan(S2.f))
D.f = V_MIN3_F32(S0.f, S1.f, S2.f); else if
(V_MAX3_F32(S0.f, S1.f, S2.f) == S0.f) D.f =
V_MAX_F32(S1.f, S2.f); else if
(V_MAX3_F32(S0.f, S1.f, S2.f) == S1.f) D.f =
V_MAX_F32(S0.f, S2.f); else D.f =
V_MAX_F32(S0.f, S1.f); endif.</td>
</tr>
<tr class="row-odd"><td>471</td>
<td>V_MED3_I32</td>
<td>if (V_MAX3_I32(S0.i, S1.i, S2.i) == S0.i) D.i =
V_MAX_I32(S1.i, S2.i); else if
(V_MAX3_I32(S0.i, S1.i, S2.i) == S1.i) D.i =
V_MAX_I32(S0.i, S2.i); else D.i =
V_MAX_I32(S0.i, S1.i); endif.</td>
</tr>
<tr class="row-even"><td>472</td>
<td>V_MED3_U32</td>
<td>if (V_MAX3_U32(S0.u, S1.u, S2.u) == S0.u) D.u =
V_MAX_U32(S1.u, S2.u); else if
(V_MAX3_U32(S0.u, S1.u, S2.u) == S1.u) D.u =
V_MAX_U32(S0.u, S2.u); else D.u =
V_MAX_U32(S0.u, S1.u); endif.</td>
</tr>
<tr class="row-odd"><td>473</td>
<td>V_SAD_U8</td>
<td>D.u = abs(S0.i[31:24] - S1.i[31:24]); D.u +=
abs(S0.i[23:16] - S1.i[23:16]); D.u +=
abs(S0.i[15:8] - S1.i[15:8]); D.u += abs(S0.i[7:0]
- S1.i[7:0]) + S2.u. Sum of absolute differences
with accumulation, overflow into upper bits is
allowed.</td>
</tr>
<tr class="row-even"><td>474</td>
<td>V_SAD_HI_U8</td>
<td>D.u = (SAD_U8(S0, S1, 0) &lt;&lt; 16) + S2.u. Sum of
absolute differences with accumulation, overflow
is lost.</td>
</tr>
<tr class="row-odd"><td>475</td>
<td>V_SAD_U16</td>
<td>D.u = abs(S0.i[31:16] - S1.i[31:16]) +
abs(S0.i[15:0] - S1.i[15:0]) + S2.u. Word SAD with
accumulation.</td>
</tr>
<tr class="row-even"><td>476</td>
<td>V_SAD_U32</td>
<td>D.u = abs(S0.i - S1.i) + S2.u. Dword SAD with
accumulation.</td>
</tr>
<tr class="row-odd"><td>477</td>
<td>V_CVT_PK_U8
_F32</td>
<td>D.u = (S2.u &amp; ~(0xff &lt;&lt; (8 * S1.u[1:0]))); D.u =
D.u | ((flt32_to_uint8(S0.f) &amp; 0xff) &lt;&lt; (8 *
S1.u[1:0])). Convert floating point value S0 to
8-bit unsigned integer and pack the result into
byte S1 of dword S2.</td>
</tr>
<tr class="row-even"><td>478</td>
<td>V_DIV_FIXUP_F32</td>
<td>sign_out = sign(S1.f)^sign(S2.f); if (S2.f ==
NAN) D.f = Quiet(S2.f); else if (S1.f == NAN) D.f
= Quiet(S1.f); else if (S1.f == S2.f == 0) // 0/0
D.f = 0xffc0_0000; else if (abs(S1.f) ==
abs(S2.f) == +-INF) // inf/inf D.f = 0xffc0_0000;
else if (S1.f == 0 || abs(S2.f) == +-INF) //
x/0, or inf/y D.f = sign_out ? -INF : +INF; else
if (abs(S1.f) == +-INF || S2.f == 0) // x/inf,
0/y D.f = sign_out ? -0 : 0; else if
((exponent(S2.f) - exponent(S1.f)) &lt; -150) D.f =
sign_out ? -underflow : underflow; else if
(exponent(S1.f) == 255) D.f = sign_out ?
-overflow : overflow; else D.f = sign_out ?
-abs(S0.f) : abs(S0.f); endif. Single precision
division fixup. S0 = Quotient, S1 = Denominator,
S2 = Numerator. Given a numerator, denominator,
and quotient from a divide, this opcode will
detect and apply special case numerics, touching
up the quotient if necessary. This opcode also
generates invalid, denorm and divide by zero
exceptions caused by the division.</td>
</tr>
<tr class="row-odd"><td>479</td>
<td>V_DIV_FIXUP_F64</td>
<td>sign_out = sign(S1.d)^sign(S2.d); if (S2.d ==
NAN) D.d = Quiet(S2.d); else if (S1.d == NAN) D.d
= Quiet(S1.d); else if (S1.d == S2.d == 0) // 0/0
D.d = 0xfff8_0000_0000_0000; else if (abs(S1.d)
== abs(S2.d) == +-INF) // inf/inf D.d =
0xfff8_0000_0000_0000; else if (S1.d == 0 ||
abs(S2.d) == +-INF) // x/0, or inf/y D.d =
sign_out ? -INF : +INF; else if (abs(S1.d) ==
+-INF || S2.d == 0) // x/inf, 0/y D.d =
sign_out ? -0 : 0; else if ((exponent(S2.d) -
exponent(S1.d)) &lt; -1075) D.d = sign_out ?
-underflow : underflow; else if (exponent(S1.d) ==
2047) D.d = sign_out ? -overflow : overflow; else
D.d = sign_out ? -abs(S0.d) : abs(S0.d); endif.
Double precision division fixup. S0 = Quotient, S1
= Denominator, S2 = Numerator. Given a numerator,
denominator, and quotient from a divide, this
opcode will detect and apply special case
numerics, touching up the quotient if necessary.
This opcode also generates invalid, denorm and
divide by zero exceptions caused by the division.</td>
</tr>
<tr class="row-even"><td>480</td>
<td>V_DIV_SCALE_F32</td>
<td>VCC = 0; if (S2.f == 0 || S1.f == 0) D.f = NAN
else if (exponent(S2.f) - exponent(S1.f) &gt;= 96) //
N/D near MAX_FLOAT VCC = 1; if (S0.f == S1.f) //
Only scale the denominator D.f = ldexp(S0.f, 64);
end if else if (S1.f == DENORM) D.f = ldexp(S0.f,
64); else if (1 / S1.f == DENORM &amp;&amp; S2.f / S1.f ==
DENORM) VCC = 1; if (S0.f == S1.f) // Only scale
the denominator D.f = ldexp(S0.f, 64); end if else
if (1 / S1.f == DENORM) D.f = ldexp(S0.f, -64);
else if (S2.f / S1.f==DENORM) VCC = 1; if (S0.f ==
S2.f) // Only scale the numerator D.f =
ldexp(S0.f, 64); end if else if (exponent(S2.f) &lt;=
23) // Numerator is tiny D.f = ldexp(S0.f, 64);
end if. Single precision division pre-scale. S0 =
Input to scale (either denominator or numerator),
S1 = Denominator, S2 = Numerator. Given a
numerator and denominator, this opcode will
appropriately scale inputs for division to avoid
subnormal terms during Newton-Raphson correction
algorithm. S0 must be the same value as either S1
or S2. This opcode producses a VCC flag for
post-scaling of the quotient (using
V_DIV_FMAS_F32).</td>
</tr>
<tr class="row-odd"><td>481</td>
<td>V_DIV_SCALE_F64</td>
<td>VCC = 0; if (S2.d == 0 || S1.d == 0) D.d = NAN
else if (exponent(S2.d) - exponent(S1.d) &gt;= 768)
// N/D near MAX_FLOAT VCC = 1; if (S0.d == S1.d)
// Only scale the denominator D.d = ldexp(S0.d,
128); end if else if (S1.d == DENORM) D.d =
ldexp(S0.d, 128); else if (1 / S1.d == DENORM &amp;&amp;
S2.d / S1.d == DENORM) VCC = 1; if (S0.d == S1.d)
// Only scale the denominator D.d = ldexp(S0.d,
128); end if else if (1 / S1.d == DENORM) D.d =
ldexp(S0.d, -128); else if (S2.d / S1.d==DENORM)
VCC = 1; if (S0.d == S2.d) // Only scale the
numerator D.d = ldexp(S0.d, 128); end if else if
(exponent(S2.d) &lt;= 53) // Numerator is tiny D.d =
ldexp(S0.d, 128); end if. Double precision
division pre-scale. S0 = Input to scale (either
denominator or numerator), S1 = Denominator, S2 =
Numerator. Given a numerator and denominator, this
opcode will appropriately scale inputs for
division to avoid subnormal terms during
Newton-Raphson correction algorithm. S0 must be
the same value as either S1 or S2. This opcode
producses a VCC flag for post-scaling of the
quotient (using V_DIV_FMAS_F64).</td>
</tr>
<tr class="row-even"><td>482</td>
<td>V_DIV_FMAS_
F32</td>
<td>if (VCC[threadId]) D.f = 2**32 * (S0.f * S1.f
+ S2.f); else D.f = S0.f * S1.f + S2.f; end if.
Single precision FMA with fused scale. This opcode
performs a standard Fused Multiply-Add operation
and will conditionally scale the resulting
exponent if VCC is set. Input denormals are not
flushed, but output flushing is allowed.</td>
</tr>
<tr class="row-odd"><td>483</td>
<td>V_DIV_FMAS_
F64</td>
<td>if (VCC[threadId]) D.d = 2**64 * (S0.d * S1.d
+ S2.d); else D.d = S0.d * S1.d + S2.d; end if.
Double precision FMA with fused scale. This opcode
performs a standard Fused Multiply-Add operation
and will conditionally scale the resulting
exponent if VCC is set. Input denormals are not
flushed, but output flushing is allowed.</td>
</tr>
<tr class="row-even"><td>484</td>
<td>V_MSAD_U8</td>
<td>D.u = Masked Byte SAD with accum_lo(S0.u, S1.u,
S2.u).</td>
</tr>
<tr class="row-odd"><td>485</td>
<td>V_QSAD_PK_U
16_U8</td>
<td>D.u = Quad-Byte SAD with 16-bit packed
accum_lo/hi(S0.u[63:0], S1.u[31:0], S2.u[63:0])</td>
</tr>
<tr class="row-even"><td>486</td>
<td>V_MQSAD_PK_
U16_U8</td>
<td>D.u = Masked Quad-Byte SAD with 16-bit packed
accum_lo/hi(S0.u[63:0], S1.u[31:0], S2.u[63:0])</td>
</tr>
<tr class="row-odd"><td>487</td>
<td>V_MQSAD_U32_U8</td>
<td>D.u128 = Masked Quad-Byte SAD with 32-bit
accum_lo/hi(S0.u[63:0], S1.u[31:0], S2.u[127:0])</td>
</tr>
<tr class="row-even"><td>488</td>
<td>V_MAD_U64_U
32</td>
<td>{vcc_out,D.u64} = S0.u32 * S1.u32 + S2.u64.</td>
</tr>
<tr class="row-odd"><td>489</td>
<td>V_MAD_I64_I
32</td>
<td>{vcc_out,D.i64} = S0.i32 * S1.i32 + S2.i64.</td>
</tr>
<tr class="row-even"><td>490</td>
<td>V_MAD_LEGACY
_F16</td>
<td>D.f16 = S0.f16 * S1.f16 + S2.f16. Supports round
mode, exception flags, saturation. If op_sel[3]
is 0 Result is written to 16 LSBs of destination
VGPR and hi 16 bits are written as 0 (this is
different from V_MAD_F16). If op_sel[3] is 1
Result is written to 16 MSBs of destination VGPR
and lo 16 bits are preserved.</td>
</tr>
<tr class="row-odd"><td>491</td>
<td>V_MAD_LEGACY
_U16</td>
<td>D.u16 = S0.u16 * S1.u16 + S2.u16. Supports
saturation (unsigned 16-bit integer domain). If
op_sel[3] is 0 Result is written to 16 LSBs of
destination VGPR and hi 16 bits are written as 0
(this is different from V_MAD_U16). If
op_sel[3] is 1 Result is written to 16 MSBs of
destination VGPR and lo 16 bits are preserved.</td>
</tr>
<tr class="row-even"><td>492</td>
<td>V_MAD_LEGACY
_I16</td>
<td>D.i16 = S0.i16 * S1.i16 + S2.i16. Supports
saturation (signed 16-bit integer domain). If
op_sel[3] is 0 Result is written to 16 LSBs of
destination VGPR and hi 16 bits are written as 0
(this is different from V_MAD_I16). If
op_sel[3] is 1 Result is written to 16 MSBs of
destination VGPR and lo 16 bits are preserved.</td>
</tr>
<tr class="row-odd"><td>493</td>
<td>V_PERM_B32</td>
<td>D.u[31:24] = byte_permute({S0.u, S1.u},
S2.u[31:24]); D.u[23:16] = byte_permute({S0.u,
S1.u}, S2.u[23:16]); D.u[15:8] =
byte_permute({S0.u, S1.u}, S2.u[15:8]); D.u[7:0]
= byte_permute({S0.u, S1.u}, S2.u[7:0]); byte
permute(byte in[8], byte sel) { if(sel&gt;=13) then
return 0xff; elsif(sel==12) then return 0x00;
elsif(sel==11) then return in[7][7] * 0xff;
elsif(sel==10) then return in[5][7] * 0xff;
elsif(sel==9) then return in[3][7] * 0xff;
elsif(sel==8) then return in[1][7] * 0xff; else
return in[sel]; } Byte permute.</td>
</tr>
<tr class="row-even"><td>494</td>
<td>V_FMA_LEGACY
_F16</td>
<td>D.f16 = S0.f16 * S1.f16 + S2.f16. Fused half
precision multiply add.</td>
</tr>
<tr class="row-odd"><td>495</td>
<td>V_DIV_FIXUP_LEGACY_F16</td>
<td>sign_out = sign(S1.f16)^sign(S2.f16); if (S2.f16
== NAN) D.f16 = Quiet(S2.f16); else if (S1.f16 ==
NAN) D.f16 = Quiet(S1.f16); else if (S1.f16 ==
S2.f16 == 0) // 0/0 D.f16 = 0xfe00; else if
(abs(S1.f16) == abs(S2.f16) == +-INF) // inf/inf
D.f16 = 0xfe00; else if (S1.f16 ==0 ||
abs(S2.f16) == +-INF) // x/0, or inf/y D.f16 =
sign_out ? -INF : +INF; else if (abs(S1.f16) ==
+-INF || S2.f16 == 0) // x/inf, 0/y D.f16 =
sign_out ? -0 : 0; else D.f16 = sign_out ?
-abs(S0.f16) : abs(S0.f16); end if. Half precision
division fixup. S0 = Quotient, S1 = Denominator,
S2 = Numerator. Given a numerator, denominator,
and quotient from a divide, this opcode will
detect and apply special case numerics, touching
up the quotient if necessary. This opcode also
generates invalid, denorm and divide by zero
exceptions caused by the division.</td>
</tr>
<tr class="row-even"><td>496</td>
<td>V_CVT_PKACCU
M_U8_F32</td>
<td>byte = S1.u[1:0]; bit = byte * 8; D.u[bit+7:bit]
= flt32_to_uint8(S0.f). Pack converted value of
S0.f into byte S1 of the destination. Note: this
opcode uses src_c to pass destination in as a
source.</td>
</tr>
<tr class="row-odd"><td>497</td>
<td>V_MAD_U32_U
16</td>
<td>D.u32 = S0.u16 * S1.u16 + S2.u32.</td>
</tr>
<tr class="row-even"><td>498</td>
<td>V_MAD_I32_I
16</td>
<td>D.i32 = S0.i16 * S1.i16 + S2.i32.</td>
</tr>
<tr class="row-odd"><td>499</td>
<td>V_XAD_U32</td>
<td>D.u32 = (S0.u32 ^ S1.u32) + S2.u32. No
carryin/carryout and no saturation. This opcode
exists to accelerate the SHA256 hash algorithm.</td>
</tr>
<tr class="row-even"><td>500</td>
<td>V_MIN3_F16</td>
<td>D.f16 = V_MIN_F16(V_MIN_F16(S0.f16, S1.f16),
S2.f16).</td>
</tr>
<tr class="row-odd"><td>501</td>
<td>V_MIN3_I16</td>
<td>D.i16 = V_MIN_I16(V_MIN_I16(S0.i16, S1.i16),
S2.i16).</td>
</tr>
<tr class="row-even"><td>502</td>
<td>V_MIN3_U16</td>
<td>D.u16 = V_MIN_U16(V_MIN_U16(S0.u16, S1.u16),
S2.u16).</td>
</tr>
<tr class="row-odd"><td>503</td>
<td>V_MAX3_F16</td>
<td>D.f16 = V_MAX_F16(V_MAX_F16(S0.f16, S1.f16),
S2.f16).</td>
</tr>
<tr class="row-even"><td>504</td>
<td>V_MAX3_I16</td>
<td>D.i16 = V_MAX_I16(V_MAX_I16(S0.i16, S1.i16),
S2.i16).</td>
</tr>
<tr class="row-odd"><td>505</td>
<td>V_MAX3_U16</td>
<td>D.u16 = V_MAX_U16(V_MAX_U16(S0.u16, S1.u16),
S2.u16).</td>
</tr>
<tr class="row-even"><td>506</td>
<td>V_MED3_F16</td>
<td>if (isNan(S0.f16) || isNan(S1.f16) ||
isNan(S2.f16)) D.f16 = V_MIN3_F16(S0.f16,
S1.f16, S2.f16); else if (V_MAX3_F16(S0.f16,
S1.f16, S2.f16) == S0.f16) D.f16 =
V_MAX_F16(S1.f16, S2.f16); else if
(V_MAX3_F16(S0.f16, S1.f16, S2.f16) == S1.f16)
D.f16 = V_MAX_F16(S0.f16, S2.f16); else D.f16 =
V_MAX_F16(S0.f16, S1.f16); endif.</td>
</tr>
<tr class="row-odd"><td>507</td>
<td>V_MED3_I16</td>
<td>if (V_MAX3_I16(S0.i16, S1.i16, S2.i16) ==
S0.i16) D.i16 = V_MAX_I16(S1.i16, S2.i16); else
if (V_MAX3_I16(S0.i16, S1.i16, S2.i16) ==
S1.i16) D.i16 = V_MAX_I16(S0.i16, S2.i16); else
D.i16 = V_MAX_I16(S0.i16, S1.i16); endif.</td>
</tr>
<tr class="row-even"><td>508</td>
<td>V_MED3_U16</td>
<td>if (V_MAX3_U16(S0.u16, S1.u16, S2.u16) ==
S0.u16) D.u16 = V_MAX_U16(S1.u16, S2.u16); else
if (V_MAX3_U16(S0.u16, S1.u16, S2.u16) ==
S1.u16) D.u16 = V_MAX_U16(S0.u16, S2.u16); else
D.u16 = V_MAX_U16(S0.u16, S1.u16); endif.</td>
</tr>
<tr class="row-odd"><td>509</td>
<td>V_LSHL_ADD_
U32</td>
<td>D.u = (S0.u &lt;&lt; S1.u[4:0]) + S2.u.</td>
</tr>
<tr class="row-even"><td>510</td>
<td>V_ADD_LSHL_
U32</td>
<td>D.u = (S0.u + S1.u) &lt;&lt; S2.u[4:0].</td>
</tr>
<tr class="row-odd"><td>511</td>
<td>V_ADD3_U32</td>
<td>D.u = S0.u + S1.u + S2.u.</td>
</tr>
<tr class="row-even"><td>512</td>
<td>V_LSHL_OR_B
32</td>
<td>D.u = (S0.u &lt;&lt; S1.u[4:0]) | S2.u.</td>
</tr>
<tr class="row-odd"><td>513</td>
<td>V_AND_OR_B3
2</td>
<td>D.u = (S0.u &amp; S1.u) | S2.u.</td>
</tr>
<tr class="row-even"><td>514</td>
<td>V_OR3_B32</td>
<td>D.u = S0.u | S1.u | S2.u.</td>
</tr>
<tr class="row-odd"><td>515</td>
<td>V_MAD_F16</td>
<td>D.f16 = S0.f16 * S1.f16 + S2.f16. Supports round
mode, exception flags, saturation. 1ULP accuracy,
denormals are flushed. If op_sel[3] is 0 Result
is written to 16 LSBs of destination VGPR and hi
16 bits are preserved. If op_sel[3] is 1 Result
is written to 16 MSBs of destination VGPR and lo
16 bits are preserved.</td>
</tr>
<tr class="row-even"><td>516</td>
<td>V_MAD_U16</td>
<td>D.u16 = S0.u16 * S1.u16 + S2.u16. Supports
saturation (unsigned 16-bit integer domain). If
op_sel[3] is 0 Result is written to 16 LSBs of
destination VGPR and hi 16 bits are preserved. If
op_sel[3] is 1 Result is written to 16 MSBs of
destination VGPR and lo 16 bits are preserved.</td>
</tr>
<tr class="row-odd"><td>517</td>
<td>V_MAD_I16</td>
<td>D.i16 = S0.i16 * S1.i16 + S2.i16. Supports
saturation (signed 16-bit integer domain). If
op_sel[3] is 0 Result is written to 16 LSBs of
destination VGPR and hi 16 bits are preserved. If
op_sel[3] is 1 Result is written to 16 MSBs of
destination VGPR and lo 16 bits are preserved.</td>
</tr>
<tr class="row-even"><td>518</td>
<td>V_FMA_F16</td>
<td>D.f16 = S0.f16 * S1.f16 + S2.f16. Fused half
precision multiply add. 0.5ULP accuracy, denormals
are supported. If op_sel[3] is 0 Result is
written to 16 LSBs of destination VGPR and hi 16
bits are preserved. If op_sel[3] is 1 Result is
written to 16 MSBs of destination VGPR and lo 16
bits are preserved.</td>
</tr>
<tr class="row-odd"><td>519</td>
<td>V_DIV_FIXUP_F16</td>
<td>sign_out = sign(S1.f16)^sign(S2.f16); if (S2.f16
== NAN) D.f16 = Quiet(S2.f16); else if (S1.f16 ==
NAN) D.f16 = Quiet(S1.f16); else if (S1.f16 ==
S2.f16 == 0) // 0/0 D.f16 = 0xfe00; else if
(abs(S1.f16) == abs(S2.f16) == +-INF) // inf/inf
D.f16 = 0xfe00; else if (S1.f16 ==0 ||
abs(S2.f16) == +-INF) // x/0, or inf/y D.f16 =
sign_out ? -INF : +INF; else if (abs(S1.f16) ==
+-INF || S2.f16 == 0) // x/inf, 0/y D.f16 =
sign_out ? -0 : 0; else D.f16 = sign_out ?
-abs(S0.f16) : abs(S0.f16); end if. Half precision
division fixup. S0 = Quotient, S1 = Denominator,
S2 = Numerator. Given a numerator, denominator,
and quotient from a divide, this opcode will
detect and apply special case numerics, touching
up the quotient if necessary. This opcode also
generates invalid, denorm and divide by zero
exceptions caused by the division. If op_sel[3]
is 0 Result is written to 16 LSBs of destination
VGPR and hi 16 bits are preserved. If op_sel[3]
is 1 Result is written to 16 MSBs of destination
VGPR and lo 16 bits are preserved.</td>
</tr>
<tr class="row-even"><td>628</td>
<td>V_INTERP_P1L
L_F16</td>
<td>D.f32 = P10.f16 * S0.f32 + P0.f16. `LL’ stands
for `two LDS arguments’. attr_word selects the
high or low half 16 bits of each LDS dword
accessed. This opcode is available for 32-bank LDS
only. NOTE: In textual representations the I/J
VGPR is the first source and the attribute is the
second source; however in the VOP3 encoding the
attribute is stored in the src0 field and the VGPR
is stored in the src1 field.</td>
</tr>
<tr class="row-odd"><td>629</td>
<td>V_INTERP_P1L
V_F16</td>
<td>D.f32 = P10.f16 * S0.f32 + (S2.u32 &gt;&gt; (attr_word
* 16)).f16. `LV’ stands for `One LDS and one
VGPR argument’. S2 holds two parameters,
attr_word selects the high or low word of the
VGPR for this calculation, as well as the high or
low half of the LDS data. Meant for use with
16-bank LDS. NOTE: In textual representations the
I/J VGPR is the first source and the attribute is
the second source; however in the VOP3 encoding
the attribute is stored in the src0 field and the
VGPR is stored in the src1 field.</td>
</tr>
<tr class="row-even"><td>630</td>
<td>V_INTERP_P2_LEGACY_F16</td>
<td>D.f16 = P20.f16 * S0.f32 + S2.f32. Final
computation. attr_word selects LDS high or low
16bits. Used for both 16- and 32-bank LDS. Result
is written to the 16 LSBs of the destination VGPR.
NOTE: In textual representations the I/J VGPR is
the first source and the attribute is the second
source; however in the VOP3 encoding the attribute
is stored in the src0 field and the VGPR is stored
in the src1 field.</td>
</tr>
<tr class="row-odd"><td>631</td>
<td>V_INTERP_P2_F16</td>
<td>D.f16 = P20.f16 * S0.f32 + S2.f32. Final
computation. attr_word selects LDS high or low
16bits. Used for both 16- and 32-bank LDS. NOTE:
In textual representations the I/J VGPR is the
first source and the attribute is the second
source; however in the VOP3 encoding the attribute
is stored in the src0 field and the VGPR is stored
in the src1 field. If op_sel[3] is 0 Result is
written to 16 LSBs of destination VGPR and hi 16
bits are preserved. If op_sel[3] is 1 Result is
written to 16 MSBs of destination VGPR and lo 16
bits are preserved.</td>
</tr>
<tr class="row-even"><td>640</td>
<td>V_ADD_F64</td>
<td>D.d = S0.d + S1.d. 0.5ULP precision, denormals are
supported.</td>
</tr>
<tr class="row-odd"><td>641</td>
<td>V_MUL_F64</td>
<td>D.d = S0.d * S1.d. 0.5ULP precision, denormals
are supported.</td>
</tr>
<tr class="row-even"><td>642</td>
<td>V_MIN_F64</td>
<td>if (IEEE_MODE &amp;&amp; S0.d == sNaN) D.d = Quiet(S0.d);
else if (IEEE_MODE &amp;&amp; S1.d == sNaN) D.d =
Quiet(S1.d); else if (S0.d == NaN) D.d = S1.d;
else if (S1.d == NaN) D.d = S0.d; else if (S0.d ==
+0.0 &amp;&amp; S1.d == -0.0) D.d = S1.d; else if (S0.d ==
-0.0 &amp;&amp; S1.d == +0.0) D.d = S0.d; else // Note:
there’s no IEEE special case here like there is
for V_MAX_F64. D.d = (S0.d &lt; S1.d ? S0.d :
S1.d); endif.</td>
</tr>
<tr class="row-odd"><td>643</td>
<td>V_MAX_F64</td>
<td>if (IEEE_MODE &amp;&amp; S0.d == sNaN) D.d = Quiet(S0.d);
else if (IEEE_MODE &amp;&amp; S1.d == sNaN) D.d =
Quiet(S1.d); else if (S0.d == NaN) D.d = S1.d;
else if (S1.d == NaN) D.d = S0.d; else if (S0.d ==
+0.0 &amp;&amp; S1.d == -0.0) D.d = S0.d; else if (S0.d ==
-0.0 &amp;&amp; S1.d == +0.0) D.d = S1.d; else if
(IEEE_MODE) D.d = (S0.d &gt;= S1.d ? S0.d : S1.d);
else D.d = (S0.d &gt; S1.d ? S0.d : S1.d); endif.</td>
</tr>
<tr class="row-even"><td>644</td>
<td>V_LDEXP_F64</td>
<td>D.d = S0.d * (2 ** S1.i).</td>
</tr>
<tr class="row-odd"><td>645</td>
<td>V_MUL_LO_U3
2</td>
<td>D.u = S0.u * S1.u.</td>
</tr>
<tr class="row-even"><td>646</td>
<td>V_MUL_HI_U3
2</td>
<td>D.u = (S0.u * S1.u) &gt;&gt; 32.</td>
</tr>
<tr class="row-odd"><td>647</td>
<td>V_MUL_HI_I3
2</td>
<td>D.i = (S0.i * S1.i) &gt;&gt; 32.</td>
</tr>
<tr class="row-even"><td>648</td>
<td>V_LDEXP_F32</td>
<td>D.f = S0.f * (2 ** S1.i).</td>
</tr>
<tr class="row-odd"><td>649</td>
<td>V_READLANE_B
32</td>
<td>Copy one VGPR value to one SGPR. D = SGPR-dest, S0
= Source Data (VGPR# or M0(lds-direct)), S1 = Lane
Select (SGPR or M0). Ignores exec mask. Input and
output modifiers not supported; this is an untyped
operation.</td>
</tr>
<tr class="row-even"><td>650</td>
<td>V_WRITELANE_
B32</td>
<td>Write value into one VGPR in one lane. D =
VGPR-dest, S0 = Source Data (sgpr, m0, exec or
constants), S1 = Lane Select (SGPR or M0). Ignores
exec mask. Input and output modifiers not
supported; this is an untyped operation.</td>
</tr>
<tr class="row-odd"><td>651</td>
<td>V_BCNT_U32_
B32</td>
<td>D.u = 0; for i in 0 … 31 do D.u += (S0.u[i] == 1
? 1 : 0); endfor. Bit count.</td>
</tr>
<tr class="row-even"><td>652</td>
<td>V_MBCNT_LO_
U32_B32</td>
<td>ThreadMask = (1LL &lt;&lt; ThreadPosition) - 1;
MaskedValue = (S0.u &amp; ThreadMask[31:0]); D.u =
S1.u; for i in 0 … 31 do D.u += (MaskedValue[i]
== 1 ? 1 : 0); endfor. Masked bit count,
ThreadPosition is the position of this thread in
the wavefront (in 0..63). See also
V_MBCNT_HI_U32_B32.</td>
</tr>
<tr class="row-odd"><td>653</td>
<td>V_MBCNT_HI_
U32_B32</td>
<td>ThreadMask = (1LL &lt;&lt; ThreadPosition) - 1;
MaskedValue = (S0.u &amp; ThreadMask[63:32]); D.u =
S1.u; for i in 0 … 31 do D.u += (MaskedValue[i]
== 1 ? 1 : 0); endfor. Masked bit count,
ThreadPosition is the position of this thread in
the wavefront (in 0..63). See also
V_MBCNT_LO_U32_B32. Example to compute each
thread’s position in 0..63: v_mbcnt_lo_u32_b32
v0, -1, 0 v_mbcnt_hi_u32_b32 v0, -1, v0 // v0
now contains ThreadPosition</td>
</tr>
<tr class="row-even"><td>655</td>
<td>V_LSHLREV_B6
4</td>
<td>D.u64 = S1.u64 &lt;&lt; S0.u[5:0].</td>
</tr>
<tr class="row-odd"><td>656</td>
<td>V_LSHRREV_B6
4</td>
<td>D.u64 = S1.u64 &gt;&gt; S0.u[5:0].</td>
</tr>
<tr class="row-even"><td>657</td>
<td>V_ASHRREV_I6
4</td>
<td>D.u64 = signext(S1.u64) &gt;&gt; S0.u[5:0].</td>
</tr>
<tr class="row-odd"><td>658</td>
<td>V_TRIG_PREOP
_F64</td>
<td>shift = S1.u * 53; if exponent(S0.d) &gt; 1077 then
shift += exponent(S0.d) - 1077; endif result =
(double) ((2/PI[1200:0] &lt;&lt; shift) &amp;
0x1fffff_ffffffff); scale = (-53 - shift); if
exponent(S0.d) &gt;= 1968 then scale += 128; endif
D.d = ldexp(result, scale). Look Up 2/PI (S0.d)
with segment select S1.u[4:0]. This operation
returns an aligned, double precision segment of
2/PI needed to do range reduction on S0.d
(double-precision value). Multiple segments can be
specified through S1.u[4:0]. Rounding uses
round-to-zero. Large inputs (exp &gt; 1968) are
scaled to avoid loss of precision through
denormalization.</td>
</tr>
<tr class="row-even"><td>659</td>
<td>V_BFM_B32</td>
<td>D.u = ((1&lt;&lt;S0.u[4:0])-1) &lt;&lt; S1.u[4:0]. Bitfield
modify. S0 is the bitfield width and S1 is the
bitfield offset.</td>
</tr>
<tr class="row-odd"><td>660</td>
<td>V_CVT_PKNORM
_I16_F32</td>
<td>D = {(snorm)S1.f, (snorm)S0.f}.</td>
</tr>
<tr class="row-even"><td>661</td>
<td>V_CVT_PKNORM
_U16_F32</td>
<td>D = {(unorm)S1.f, (unorm)S0.f}.</td>
</tr>
<tr class="row-odd"><td>662</td>
<td>V_CVT_PKRTZ_F16_F32</td>
<td>D =
{flt32_to_flt16(S1.f),flt32_to_flt16(S0.f)}.
// Round-toward-zero regardless of current round
mode setting in hardware. This opcode is intended
for use with 16-bit compressed exports. See
V_CVT_F16_F32 for a version that respects the
current rounding mode.</td>
</tr>
<tr class="row-even"><td>663</td>
<td>V_CVT_PK_U1
6_U32</td>
<td>D = {uint32_to_uint16(S1.u),
uint32_to_uint16(S0.u)}.</td>
</tr>
<tr class="row-odd"><td>664</td>
<td>V_CVT_PK_I1
6_I32</td>
<td>D = {int32_to_int16(S1.i),
int32_to_int16(S0.i)}.</td>
</tr>
<tr class="row-even"><td>665</td>
<td>V_CVT_PKNORM
_I16_F16</td>
<td>D = {(snorm)S1.f16, (snorm)S0.f16}.</td>
</tr>
<tr class="row-odd"><td>666</td>
<td>V_CVT_PKNORM
_U16_F16</td>
<td>D = {(unorm)S1.f16, (unorm)S0.f16}.</td>
</tr>
<tr class="row-even"><td>668</td>
<td>V_ADD_I32</td>
<td>D.i = S0.i + S1.i. Supports saturation (signed
32-bit integer domain).</td>
</tr>
<tr class="row-odd"><td>669</td>
<td>V_SUB_I32</td>
<td>D.i = S0.i - S1.i. Supports saturation (signed
32-bit integer domain).</td>
</tr>
<tr class="row-even"><td>670</td>
<td>V_ADD_I16</td>
<td>D.i16 = S0.i16 + S1.i16. Supports saturation
(signed 16-bit integer domain).</td>
</tr>
<tr class="row-odd"><td>671</td>
<td>V_SUB_I16</td>
<td>D.i16 = S0.i16 - S1.i16. Supports saturation
(signed 16-bit integer domain).</td>
</tr>
<tr class="row-even"><td>672</td>
<td>V_PACK_B32_
F16</td>
<td>D[31:16].f16 = S1.f16; D[15:0].f16 = S0.f16.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="lds-gds-instructions">
<h3>LDS &amp; GDS Instructions<a class="headerlink" href="#lds-gds-instructions" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">This suite of instructions operates on data stored within the data
share memory. The instructions transfer data between VGPRs and data
share memory.</div>
<div class="line">The bitfield map for the LDS/GDS is:</div>
</div>
<p><img alt="microcode ds" src="../_images/microcode_ds.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">where</span><span class="p">:</span>
<span class="n">OFFSET0</span> <span class="o">=</span> <span class="n">Unsigned</span> <span class="n">byte</span> <span class="n">offset</span> <span class="n">added</span> <span class="n">to</span> <span class="n">the</span> <span class="n">address</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">ADDR</span> <span class="n">VGPR</span><span class="o">.</span>
<span class="n">OFFSET1</span> <span class="o">=</span> <span class="n">Unsigned</span> <span class="n">byte</span> <span class="n">offset</span> <span class="n">added</span> <span class="n">to</span> <span class="n">the</span> <span class="n">address</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">ADDR</span> <span class="n">VGPR</span><span class="o">.</span>
<span class="n">GDS</span> <span class="o">=</span> <span class="n">Set</span> <span class="k">if</span> <span class="n">GDS</span><span class="p">,</span> <span class="n">cleared</span> <span class="k">if</span> <span class="n">LDS</span><span class="o">.</span>
<span class="n">OP</span> <span class="o">=</span> <span class="n">DS</span> <span class="n">instructions</span><span class="o">.</span>
<span class="n">ADDR</span> <span class="o">=</span> <span class="n">Source</span> <span class="n">LDS</span> <span class="n">address</span> <span class="n">VGPR</span> <span class="mi">0</span> <span class="o">-</span> <span class="mf">255.</span>
<span class="n">DATA0</span> <span class="o">=</span> <span class="n">Source</span> <span class="n">data0</span> <span class="n">VGPR</span> <span class="mi">0</span> <span class="o">-</span> <span class="mf">255.</span>
<span class="n">DATA1</span> <span class="o">=</span> <span class="n">Source</span> <span class="n">data1</span> <span class="n">VGPR</span> <span class="mi">0</span> <span class="o">-</span> <span class="mf">255.</span>
<span class="n">VDST</span> <span class="o">=</span> <span class="n">Destination</span> <span class="n">VGPR</span> <span class="mi">0</span><span class="o">-</span> <span class="mf">255.</span>

<span class="o">**</span><span class="n">Note</span><span class="o">**</span>

<span class="n">All</span> <span class="n">instructions</span> <span class="k">with</span> <span class="n">RTN</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">name</span> <span class="k">return</span> <span class="n">the</span> <span class="n">value</span> <span class="n">that</span> <span class="n">was</span> <span class="ow">in</span>
<span class="n">memory</span> <span class="n">before</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">was</span> <span class="n">performed</span><span class="o">.</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="25%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>DS_ADD_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>DS_SUB_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>DS_RSUB_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA -
MEM[ADDR]; RETURN_DATA = tmp. Subtraction with
reversed operands.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>DS_INC_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>DS_DEC_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0
|| tmp &gt; DATA) ? DATA : tmp - 1; // unsigned
compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>DS_MIN_I32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>DS_MAX_I32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>DS_MIN_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>DS_MAX_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>DS_AND_B32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>DS_OR_B32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>DS_XOR_B32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>12</td>
<td>DS_MSKOR_B32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR]
&amp; ~DATA) | DATA2; RETURN_DATA = tmp. Masked
dword OR, D0 contains the mask and D1 contains
the new value.</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>DS_WRITE_B32</td>
<td>// 32bit MEM[ADDR] = DATA. Write dword.</td>
</tr>
<tr class="row-even"><td>14</td>
<td>DS_WRITE2_B32</td>
<td>// 32bit MEM[ADDR_BASE + OFFSET0 * 4] = DATA;
MEM[ADDR_BASE + OFFSET1 * 4] = DATA2. Write 2
dwords.</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>DS_WRITE2ST64_B
32</td>
<td>// 32bit MEM[ADDR_BASE + OFFSET0 * 4 * 64] =
DATA; MEM[ADDR_BASE + OFFSET1 * 4 * 64] =
DATA2. Write 2 dwords.</td>
</tr>
<tr class="row-even"><td>16</td>
<td>DS_CMPST_B32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Compare and store.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_CMPSWAP
opcode.</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>DS_CMPST_F32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Floating point compare
and store that handles NaN/INF/denormal values.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_FCMPSWAP
opcode.</td>
</tr>
<tr class="row-even"><td>18</td>
<td>DS_MIN_F32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (cmp &lt; tmp) ? src : tmp.
Floating point minimum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMIN.</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>DS_MAX_F32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (tmp &gt; cmp) ? src : tmp.
Floating point maximum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMAX.</td>
</tr>
<tr class="row-even"><td>20</td>
<td>DS_NOP</td>
<td>Do nothing.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>DS_ADD_F32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA;
RETURN_DATA = tmp. Floating point add that
handles NaN/INF/denormal values.</td>
</tr>
<tr class="row-even"><td>29</td>
<td>DS_WRITE_ADDTID
_B32</td>
<td>// 32bit MEM[ADDR_BASE + OFFSET + M0.OFFSET +
TID*4] = DATA. Write dword.</td>
</tr>
<tr class="row-odd"><td>30</td>
<td>DS_WRITE_B8</td>
<td>MEM[ADDR] = DATA[7:0]. Byte write.</td>
</tr>
<tr class="row-even"><td>31</td>
<td>DS_WRITE_B16</td>
<td>MEM[ADDR] = DATA[15:0]. Short write.</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>DS_ADD_RTN_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>33</td>
<td>DS_SUB_RTN_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>34</td>
<td>DS_RSUB_RTN_U3
2</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA -
MEM[ADDR]; RETURN_DATA = tmp. Subtraction with
reversed operands.</td>
</tr>
<tr class="row-even"><td>35</td>
<td>DS_INC_RTN_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>36</td>
<td>DS_DEC_RTN_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0
|| tmp &gt; DATA) ? DATA : tmp - 1; // unsigned
compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>37</td>
<td>DS_MIN_RTN_I32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>38</td>
<td>DS_MAX_RTN_I32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>39</td>
<td>DS_MIN_RTN_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &lt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>40</td>
<td>DS_MAX_RTN_U32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA &gt;
tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>41</td>
<td>DS_AND_RTN_B32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>42</td>
<td>DS_OR_RTN_B32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>43</td>
<td>DS_XOR_RTN_B32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^= DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>44</td>
<td>DS_MSKOR_RTN_B
32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR]
&amp; ~DATA) | DATA2; RETURN_DATA = tmp. Masked
dword OR, D0 contains the mask and D1 contains
the new value.</td>
</tr>
<tr class="row-even"><td>45</td>
<td>DS_WRXCHG_RTN_
B32</td>
<td>tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA
= tmp. Write-exchange operation.</td>
</tr>
<tr class="row-odd"><td>46</td>
<td>DS_WRXCHG2_RTN_B32</td>
<td>Write-exchange 2 separate dwords.</td>
</tr>
<tr class="row-even"><td>47</td>
<td>DS_WRXCHG2ST64_
RTN_B32</td>
<td>Write-exchange 2 separate dwords with a stride
of 64 dwords.</td>
</tr>
<tr class="row-odd"><td>48</td>
<td>DS_CMPST_RTN_B
32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Compare and store.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_CMPSWAP
opcode.</td>
</tr>
<tr class="row-even"><td>49</td>
<td>DS_CMPST_RTN_F
32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Floating point compare
and store that handles NaN/INF/denormal values.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_FCMPSWAP
opcode.</td>
</tr>
<tr class="row-odd"><td>50</td>
<td>DS_MIN_RTN_F32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (cmp &lt; tmp) ? src : tmp.
Floating point minimum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMIN.</td>
</tr>
<tr class="row-even"><td>51</td>
<td>DS_MAX_RTN_F32</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (tmp &gt; cmp) ? src : tmp.
Floating point maximum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMAX.</td>
</tr>
<tr class="row-odd"><td>52</td>
<td>DS_WRAP_RTN_B3
2</td>
<td>tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;= DATA) ? tmp
- DATA : tmp + DATA2; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>53</td>
<td>DS_ADD_RTN_F32</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] += DATA;
RETURN_DATA = tmp. Floating point add that
handles NaN/INF/denormal values.</td>
</tr>
<tr class="row-odd"><td>54</td>
<td>DS_READ_B32</td>
<td>RETURN_DATA = MEM[ADDR]. Dword read.</td>
</tr>
<tr class="row-even"><td>55</td>
<td>DS_READ2_B32</td>
<td>RETURN_DATA[0] = MEM[ADDR_BASE + OFFSET0 *
4]; RETURN_DATA[1] = MEM[ADDR_BASE + OFFSET1
* 4]. Read 2 dwords.</td>
</tr>
<tr class="row-odd"><td>56</td>
<td>DS_READ2ST64_B3
2</td>
<td>RETURN_DATA[0] = MEM[ADDR_BASE + OFFSET0 * 4
* 64]; RETURN_DATA[1] = MEM[ADDR_BASE +
OFFSET1 * 4 * 64]. Read 2 dwords.</td>
</tr>
<tr class="row-even"><td>57</td>
<td>DS_READ_I8</td>
<td>RETURN_DATA = signext(MEM[ADDR][7:0]). Signed
byte read.</td>
</tr>
<tr class="row-odd"><td>58</td>
<td>DS_READ_U8</td>
<td>RETURN_DATA = {24’h0,MEM[ADDR][7:0]}. Unsigned
byte read.</td>
</tr>
<tr class="row-even"><td>59</td>
<td>DS_READ_I16</td>
<td>RETURN_DATA = signext(MEM[ADDR][15:0]). Signed
short read.</td>
</tr>
<tr class="row-odd"><td>60</td>
<td>DS_READ_U16</td>
<td>RETURN_DATA = {16’h0,MEM[ADDR][15:0]}. Unsigned
short read.</td>
</tr>
<tr class="row-even"><td>61</td>
<td>DS_SWIZZLE_B32</td>
<td>RETURN_DATA = swizzle(vgpr_data,
offset1:offset0). Dword swizzle, no data is
written to LDS memory.</td>
</tr>
<tr class="row-odd"><td>62</td>
<td>DS_PERMUTE_B32</td>
<td>// VGPR[index][thread_id] is the VGPR RAM //
VDST, ADDR and DATA0 are from the microcode DS
encoding tmp[0..63] = 0 for i in 0..63 do // If
a source thread is disabled, it will not
propagate data. next if !EXEC[i] // ADDR needs
to be divided by 4. // High-order bits are
ignored. dst_lane = floor((VGPR[ADDR][i] +
OFFSET) / 4) mod 64 tmp[dst_lane] =
VGPR[DATA0][i] endfor // Copy data into
destination VGPRs. If multiple sources // select
the same destination thread, the
highest-numbered // source thread wins. for i in
0..63 do next if !EXEC[i] VGPR[VDST][i] = tmp[i]
endfor Forward permute. This does not access LDS
memory and may be called even if no LDS memory
is allocated to the wave. It uses LDS hardware
to implement an arbitrary swizzle across threads
in a wavefront. Note the address passed in is
the thread ID multiplied by 4. This is due to a
limitation in the DS hardware design. If
multiple sources map to the same destination
lane, standard LDS arbitration rules determine
which write wins. See also DS_BPERMUTE_B32.
Examples (simplified 4-thread wavefronts):
VGPR[SRC0] = { A, B, C, D } VGPR[ADDR] = { 0, 0,
12, 4 } EXEC = 0xF, OFFSET = 0 VGPR[VDST] := {
B, D, 0, C } VGPR[SRC0] = { A, B, C, D }
VGPR[ADDR] = { 0, 0, 12, 4 } EXEC = 0xA, OFFSET
= 0 VGPR[VDST] := { -, D, -, 0 }</td>
</tr>
<tr class="row-even"><td>63</td>
<td>DS_BPERMUTE_B32</td>
<td>// VGPR[index][thread_id] is the VGPR RAM //
VDST, ADDR and DATA0 are from the microcode DS
encoding tmp[0..63] = 0 for i in 0..63 do //
ADDR needs to be divided by 4. // High-order
bits are ignored. src_lane =
floor((VGPR[ADDR][i] + OFFSET) / 4) mod 64 //
EXEC is applied to the source VGPR reads. next
if !EXEC[src_lane] tmp[i] =
VGPR[DATA0][src_lane] endfor // Copy data into
destination VGPRs. Some source // data may be
broadcast to multiple lanes. for i in 0..63 do
next if !EXEC[i] VGPR[VDST][i] = tmp[i] endfor
Backward permute. This does not access LDS
memory and may be called even if no LDS memory
is allocated to the wave. It uses LDS hardware
to implement an arbitrary swizzle across threads
in a wavefront. Note the address passed in is
the thread ID multiplied by 4. This is due to a
limitation in the DS hardware design. Note that
EXEC mask is applied to both VGPR read and
write. If src_lane selects a disabled thread,
zero will be returned. See also
DS_PERMUTE_B32. Examples (simplified 4-thread
wavefronts): VGPR[SRC0] = { A, B, C, D }
VGPR[ADDR] = { 0, 0, 12, 4 } EXEC = 0xF, OFFSET
= 0 VGPR[VDST] := { A, A, D, B } VGPR[SRC0] = {
A, B, C, D } VGPR[ADDR] = { 0, 0, 12, 4 } EXEC =
0xA, OFFSET = 0 VGPR[VDST] := { -, 0, -, B }</td>
</tr>
<tr class="row-odd"><td>64</td>
<td>DS_ADD_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>65</td>
<td>DS_SUB_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>66</td>
<td>DS_RSUB_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA -
MEM[ADDR]; RETURN_DATA = tmp. Subtraction with
reversed operands.</td>
</tr>
<tr class="row-even"><td>67</td>
<td>DS_INC_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA[0:1]) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>DS_DEC_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0
|| tmp &gt; DATA[0:1]) ? DATA[0:1] : tmp - 1; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>69</td>
<td>DS_MIN_I64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; // signed
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>DS_MAX_I64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; // signed
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>71</td>
<td>DS_MIN_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; // unsigned
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>DS_MAX_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; // unsigned
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>73</td>
<td>DS_AND_B64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>DS_OR_B64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>75</td>
<td>DS_XOR_B64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>DS_MSKOR_B64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR]
&amp; ~DATA) | DATA2; RETURN_DATA = tmp. Masked
dword OR, D0 contains the mask and D1 contains
the new value.</td>
</tr>
<tr class="row-even"><td>77</td>
<td>DS_WRITE_B64</td>
<td>// 64bit MEM[ADDR] = DATA. Write qword.</td>
</tr>
<tr class="row-odd"><td>78</td>
<td>DS_WRITE2_B64</td>
<td>// 64bit MEM[ADDR_BASE + OFFSET0 * 8] = DATA;
MEM[ADDR_BASE + OFFSET1 * 8] = DATA2. Write 2
qwords.</td>
</tr>
<tr class="row-even"><td>79</td>
<td>DS_WRITE2ST64_B
64</td>
<td>// 64bit MEM[ADDR_BASE + OFFSET0 * 8 * 64] =
DATA; MEM[ADDR_BASE + OFFSET1 * 8 * 64] =
DATA2. Write 2 qwords.</td>
</tr>
<tr class="row-odd"><td>80</td>
<td>DS_CMPST_B64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Compare and store.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_CMPSWAP_X2
opcode.</td>
</tr>
<tr class="row-even"><td>81</td>
<td>DS_CMPST_F64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Floating point compare
and store that handles NaN/INF/denormal values.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_FCMPSWAP_X2
opcode.</td>
</tr>
<tr class="row-odd"><td>82</td>
<td>DS_MIN_F64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (cmp &lt; tmp) ? src : tmp.
Floating point minimum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMIN_X2.</td>
</tr>
<tr class="row-even"><td>83</td>
<td>DS_MAX_F64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (tmp &gt; cmp) ? src : tmp.
Floating point maximum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMAX_X2.</td>
</tr>
<tr class="row-odd"><td>84</td>
<td>DS_WRITE_B8_D1
6_HI</td>
<td>MEM[ADDR] = DATA[23:16]. Byte write in to high
word.</td>
</tr>
<tr class="row-even"><td>85</td>
<td>DS_WRITE_B16_D
16_HI</td>
<td>MEM[ADDR] = DATA[31:16]. Short write in to high
word.</td>
</tr>
<tr class="row-odd"><td>86</td>
<td>DS_READ_U8_D16</td>
<td>RETURN_DATA[15:0] = {8’h0,MEM[ADDR][7:0]}.
Unsigned byte read with masked return to lower
word.</td>
</tr>
<tr class="row-even"><td>87</td>
<td>DS_READ_U8_D16
_HI</td>
<td>RETURN_DATA[31:16] = {8’h0,MEM[ADDR][7:0]}.
Unsigned byte read with masked return to upper
word.</td>
</tr>
<tr class="row-odd"><td>88</td>
<td>DS_READ_I8_D16</td>
<td>RETURN_DATA[15:0] = signext(MEM[ADDR][7:0]).
Signed byte read with masked return to lower
word.</td>
</tr>
<tr class="row-even"><td>89</td>
<td>DS_READ_I8_D16
_HI</td>
<td>RETURN_DATA[31:16] = signext(MEM[ADDR][7:0]).
Signed byte read with masked return to upper
word.</td>
</tr>
<tr class="row-odd"><td>90</td>
<td>DS_READ_U16_D1
6</td>
<td>RETURN_DATA[15:0] = MEM[ADDR][15:0]. Unsigned
short read with masked return to lower word.</td>
</tr>
<tr class="row-even"><td>91</td>
<td>DS_READ_U16_D1
6_HI</td>
<td>RETURN_DATA[31:0] = MEM[ADDR][15:0]. Unsigned
short read with masked return to upper word.</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>DS_ADD_RTN_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>97</td>
<td>DS_SUB_RTN_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>DS_RSUB_RTN_U6
4</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = DATA -
MEM[ADDR]; RETURN_DATA = tmp. Subtraction with
reversed operands.</td>
</tr>
<tr class="row-even"><td>99</td>
<td>DS_INC_RTN_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp &gt;=
DATA[0:1]) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>DS_DEC_RTN_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp == 0
|| tmp &gt; DATA[0:1]) ? DATA[0:1] : tmp - 1; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>101</td>
<td>DS_MIN_RTN_I64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; // signed
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>DS_MAX_RTN_I64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; // signed
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>103</td>
<td>DS_MIN_RTN_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; // unsigned
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>DS_MAX_RTN_U64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; // unsigned
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>105</td>
<td>DS_AND_RTN_B64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>DS_OR_RTN_B64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>107</td>
<td>DS_XOR_RTN_B64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>DS_MSKOR_RTN_B
64</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (MEM[ADDR]
&amp; ~DATA) | DATA2; RETURN_DATA = tmp. Masked
dword OR, D0 contains the mask and D1 contains
the new value.</td>
</tr>
<tr class="row-even"><td>109</td>
<td>DS_WRXCHG_RTN_
B64</td>
<td>tmp = MEM[ADDR]; MEM[ADDR] = DATA; RETURN_DATA
= tmp. Write-exchange operation.</td>
</tr>
<tr class="row-odd"><td>110</td>
<td>DS_WRXCHG2_RTN_B64</td>
<td>Write-exchange 2 separate qwords.</td>
</tr>
<tr class="row-even"><td>111</td>
<td>DS_WRXCHG2ST64_
RTN_B64</td>
<td>Write-exchange 2 qwords with a stride of 64
qwords.</td>
</tr>
<tr class="row-odd"><td>112</td>
<td>DS_CMPST_RTN_B
64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Compare and store.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_CMPSWAP_X2
opcode.</td>
</tr>
<tr class="row-even"><td>113</td>
<td>DS_CMPST_RTN_F
64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA2; cmp =
DATA; MEM[ADDR] = (tmp == cmp) ? src : tmp;
RETURN_DATA[0] = tmp. Floating point compare
and store that handles NaN/INF/denormal values.
Caution, the order of src and cmp are the
*opposite* of the BUFFER_ATOMIC_FCMPSWAP_X2
opcode.</td>
</tr>
<tr class="row-odd"><td>114</td>
<td>DS_MIN_RTN_F64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (cmp &lt; tmp) ? src : tmp.
Floating point minimum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMIN_X2.</td>
</tr>
<tr class="row-even"><td>115</td>
<td>DS_MAX_RTN_F64</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA; cmp =
DATA2; MEM[ADDR] = (tmp &gt; cmp) ? src : tmp.
Floating point maximum that handles
NaN/INF/denormal values. Note that this opcode
is slightly more general-purpose than
BUFFER_ATOMIC_FMAX_X2.</td>
</tr>
<tr class="row-odd"><td>118</td>
<td>DS_READ_B64</td>
<td>RETURN_DATA = MEM[ADDR]. Read 1 qword.</td>
</tr>
<tr class="row-even"><td>119</td>
<td>DS_READ2_B64</td>
<td>RETURN_DATA[0] = MEM[ADDR_BASE + OFFSET0 *
8]; RETURN_DATA[1] = MEM[ADDR_BASE + OFFSET1
* 8]. Read 2 qwords.</td>
</tr>
<tr class="row-odd"><td>120</td>
<td>DS_READ2ST64_B6
4</td>
<td>RETURN_DATA[0] = MEM[ADDR_BASE + OFFSET0 * 8
* 64]; RETURN_DATA[1] = MEM[ADDR_BASE +
OFFSET1 * 8 * 64]. Read 2 qwords.</td>
</tr>
<tr class="row-even"><td>126</td>
<td>DS_CONDXCHG32_R
TN_B64</td>
<td>Conditional write exchange.</td>
</tr>
<tr class="row-odd"><td>128</td>
<td>DS_ADD_SRC2_U3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] + MEM[B].</td>
</tr>
<tr class="row-even"><td>129</td>
<td>DS_SUB_SRC2_U3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] - MEM[B].</td>
</tr>
<tr class="row-odd"><td>130</td>
<td>DS_RSUB_SRC2_U
32</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[B] - MEM[A].</td>
</tr>
<tr class="row-even"><td>131</td>
<td>DS_INC_SRC2_U3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[A] &gt;= MEM[B] ? 0 : MEM[A] + 1).</td>
</tr>
<tr class="row-odd"><td>132</td>
<td>DS_DEC_SRC2_U3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[A] == 0 || MEM[A] &gt; MEM[B] ? MEM[B] :
MEM[A] - 1). Uint decrement.</td>
</tr>
<tr class="row-even"><td>133</td>
<td>DS_MIN_SRC2_I3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
min(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-odd"><td>134</td>
<td>DS_MAX_SRC2_I3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
max(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-even"><td>135</td>
<td>DS_MIN_SRC2_U3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
min(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-odd"><td>136</td>
<td>DS_MAX_SRC2_U3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
max(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-even"><td>137</td>
<td>DS_AND_SRC2_B3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] &amp; MEM[B].</td>
</tr>
<tr class="row-odd"><td>138</td>
<td>DS_OR_SRC2_B32</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] | MEM[B].</td>
</tr>
<tr class="row-even"><td>139</td>
<td>DS_XOR_SRC2_B3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] ^ MEM[B].</td>
</tr>
<tr class="row-odd"><td>141</td>
<td>DS_WRITE_SRC2_
B32</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[B]. Write dword.</td>
</tr>
<tr class="row-even"><td>146</td>
<td>DS_MIN_SRC2_F3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[B] &lt; MEM[A]) ? MEM[B] : MEM[A]. Float,
handles NaN/INF/denorm.</td>
</tr>
<tr class="row-odd"><td>147</td>
<td>DS_MAX_SRC2_F3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[B] &gt; MEM[A]) ? MEM[B] : MEM[A]. Float,
handles NaN/INF/denorm.</td>
</tr>
<tr class="row-even"><td>149</td>
<td>DS_ADD_SRC2_F3
2</td>
<td>//32bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[B] + MEM[A]. Float, handles NaN/INF/denorm.</td>
</tr>
<tr class="row-odd"><td>152</td>
<td>DS_GWS_SEMA_RE
LEASE_ALL</td>
<td>GDS Only: The GWS resource (rid) indicated will
process this opcode by updating the counter and
labeling the specified resource as a semaphore.
// Determine the GWS resource to work on
rid[5:0] = SH_SX_EXPCMD.gds_base[5:0] +
offset0[5:0]; // Incr the state counter of the
resource state.counter[rid] =
state.wave_in_queue; state.type = SEMAPHORE;
return rd_done; //release calling wave This
action will release ALL queued waves; it Will
have no effect if no waves are present.</td>
</tr>
<tr class="row-even"><td>153</td>
<td>DS_GWS_INIT</td>
<td>GDS Only: Initialize a barrier or semaphore
resource. // Determine the GWS resource to work
on rid[5:0] = SH_SX_EXPCMD.gds_base[5:0] +
offset0[5:0]; // Get the value to use in init
index = find_first_valid(vector mask) value =
DATA[thread: index] // Set the state of the
resource state.counter[rid] = lsb(value);
//limit #waves state.flag[rid] = 0; return
rd_done; //release calling wave</td>
</tr>
<tr class="row-odd"><td>154</td>
<td>DS_GWS_SEMA_V</td>
<td>GDS Only: The GWS resource indicated will
process this opcode by updating the counter and
labeling the resource as a semaphore.
//Determine the GWS resource to work on rid[5:0]
= SH_SX_EXPCMD.gds_base[5:0] + offset0[5:0];
//Incr the state counter of the resource
state.counter[rid] += 1; state.type = SEMAPHORE;
return rd_done; //release calling wave This
action will release one waved if any are queued
in this resource.</td>
</tr>
<tr class="row-even"><td>155</td>
<td>DS_GWS_SEMA_BR</td>
<td>GDS Only: The GWS resource indicated will
process this opcode by updating the counter by
the bulk release delivered count and labeling
the resource as a semaphore. //Determine the GWS
resource to work on rid[5:0] =
SH_SX_EXPCMD.gds_base[5:0] + offset0[5:0];
index = find first valid (vector mask) count =
DATA[thread: index]; //Add count to the resource
state counter state.counter[rid] += count;
state.type = SEMAPHORE; return rd_done;
//release calling wave This action will release
count number of waves, immediately if queued, or
as they arrive from the noted resource.</td>
</tr>
<tr class="row-odd"><td>156</td>
<td>DS_GWS_SEMA_P</td>
<td>GDS Only: The GWS resource indicated will
process this opcode by queueing it until counter
enables a release and then decrementing the
counter of the resource as a semaphore.
//Determine the GWS resource to work on rid[5:0]
= SH_SX_EXPCMD.gds_base[5:0] + offset0[5:0];
state.type = SEMAPHORE; ENQUEUE
until(state[rid].counter &gt; 0) state[rid].counter
-= 1; return rd_done;</td>
</tr>
<tr class="row-even"><td>157</td>
<td>DS_GWS_BARRIER</td>
<td>GDS Only: The GWS resource indicated will
process this opcode by queueing it until barrier
is satisfied. The number of waves needed is
passed in as DATA of first valid thread.
//Determine the GWS resource to work on rid[5:0]
= SH_SX_EXPCMD.gds_base[5:0] + OFFSET0[5:0];
index = find first valid (vector mask); value =
DATA[thread: index]; // Input Decision Machine
state.type[rid] = BARRIER; if(state[rid].counter
&lt;= 0) then thread[rid].flag = state[rid].flag;
ENQUEUE; state[rid].flag = !state.flag;
state[rid].counter = value; return rd_done;
else state[rid].counter -= 1; thread.flag =
state[rid].flag; ENQUEUE; endif. Since the waves
deliver the count for the next barrier, this
function can have a different size barrier for
each occurrence. // Release Machine
if(state.type == BARRIER) then if(state.flag !=
thread.flag) then return rd_done; endif; endif.</td>
</tr>
<tr class="row-odd"><td>182</td>
<td>DS_READ_ADDTID_B32</td>
<td>RETURN_DATA = MEM[ADDR_BASE + OFFSET +
M0.OFFSET + TID*4]. Dword read.</td>
</tr>
<tr class="row-even"><td>189</td>
<td>DS_CONSUME</td>
<td>LDS &amp; GDS. Subtract (count_bits(exec_mask))
from the value stored in DS memory at (M0.base +
instr_offset). Return the pre-operation value
to VGPRs.</td>
</tr>
<tr class="row-odd"><td>190</td>
<td>DS_APPEND</td>
<td>LDS &amp; GDS. Add (count_bits(exec_mask)) to the
value stored in DS memory at (M0.base +
instr_offset). Return the pre-operation value
to VGPRs.</td>
</tr>
<tr class="row-even"><td>191</td>
<td>DS_ORDERED_COUN
T</td>
<td>GDS-only. Add (count_bits(exec_mask)) to one
of 4 dedicated ordered-count counters (aka
‘packers’). Additional bits of instr.offset
field are overloaded to hold packer-id, ‘last’.</td>
</tr>
<tr class="row-odd"><td>192</td>
<td>DS_ADD_SRC2_U6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] + MEM[B].</td>
</tr>
<tr class="row-even"><td>193</td>
<td>DS_SUB_SRC2_U6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] - MEM[B].</td>
</tr>
<tr class="row-odd"><td>194</td>
<td>DS_RSUB_SRC2_U
64</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[B] - MEM[A].</td>
</tr>
<tr class="row-even"><td>195</td>
<td>DS_INC_SRC2_U6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[A] &gt;= MEM[B] ? 0 : MEM[A] + 1).</td>
</tr>
<tr class="row-odd"><td>196</td>
<td>DS_DEC_SRC2_U6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[A] == 0 || MEM[A] &gt; MEM[B] ? MEM[B] :
MEM[A] - 1). Uint decrement.</td>
</tr>
<tr class="row-even"><td>197</td>
<td>DS_MIN_SRC2_I6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
min(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-odd"><td>198</td>
<td>DS_MAX_SRC2_I6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
max(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-even"><td>199</td>
<td>DS_MIN_SRC2_U6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
min(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-odd"><td>200</td>
<td>DS_MAX_SRC2_U6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
max(MEM[A], MEM[B]).</td>
</tr>
<tr class="row-even"><td>201</td>
<td>DS_AND_SRC2_B6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] &amp; MEM[B].</td>
</tr>
<tr class="row-odd"><td>202</td>
<td>DS_OR_SRC2_B64</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] | MEM[B].</td>
</tr>
<tr class="row-even"><td>203</td>
<td>DS_XOR_SRC2_B6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[A] ^ MEM[B].</td>
</tr>
<tr class="row-odd"><td>205</td>
<td>DS_WRITE_SRC2_
B64</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
MEM[B]. Write qword.</td>
</tr>
<tr class="row-even"><td>210</td>
<td>DS_MIN_SRC2_F6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[B] &lt; MEM[A]) ? MEM[B] : MEM[A]. Float,
handles NaN/INF/denorm.</td>
</tr>
<tr class="row-odd"><td>211</td>
<td>DS_MAX_SRC2_F6
4</td>
<td>//64bit A = ADDR_BASE; B = A + 4*(offset1[7] ?
{A[31],A[31:17]} :
{offset1[6],offset1[6:0],offset0}); MEM[A] =
(MEM[B] &gt; MEM[A]) ? MEM[B] : MEM[A]. Float,
handles NaN/INF/denorm.</td>
</tr>
<tr class="row-even"><td>222</td>
<td>DS_WRITE_B96</td>
<td>{MEM[ADDR + 8], MEM[ADDR + 4], MEM[ADDR]} =
DATA[95:0]. Tri-dword write.</td>
</tr>
<tr class="row-odd"><td>223</td>
<td>DS_WRITE_B128</td>
<td>{MEM[ADDR + 12], MEM[ADDR + 8], MEM[ADDR + 4],
MEM[ADDR]} = DATA[127:0]. Quad-dword write.</td>
</tr>
<tr class="row-even"><td>254</td>
<td>DS_READ_B96</td>
<td>Tri-dword read.</td>
</tr>
<tr class="row-odd"><td>255</td>
<td>DS_READ_B128</td>
<td>Quad-dword read.</td>
</tr>
</tbody>
</table>
<div class="section" id="lds-instruction-limitations">
<h4>LDS Instruction Limitations<a class="headerlink" href="#lds-instruction-limitations" title="Permalink to this headline">¶</a></h4>
<p>Some of the DS instructions are available only to GDS, not LDS. These
are:</p>
<ul class="simple">
<li>DS_GWS_SEMA_RELEASE_ALL</li>
<li>DS_GWS_INIT</li>
<li>DS_GWS_SEMA_V</li>
<li>DS_GWS_SEMA_BR</li>
<li>DS_GWS_SEMA_P</li>
<li>DS_GWS_BARRIER</li>
<li>DS_ORDERED_COUNT</li>
</ul>
</div>
</div>
<div class="section" id="mubuf-instructions">
<h3>MUBUF Instructions<a class="headerlink" href="#mubuf-instructions" title="Permalink to this headline">¶</a></h3>
<p>The bitfield map of the MUBUF format is:</p>
<p><img alt="microcode mubuf" src="../_images/microcode_mubuf.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">where</span><span class="p">:</span>

<span class="n">OFFSET</span>  <span class="o">=</span> <span class="n">Unsigned</span> <span class="n">immediate</span> <span class="n">byte</span> <span class="n">offset</span><span class="o">.</span>
<span class="n">OFFEN</span>   <span class="o">=</span> <span class="n">Send</span> <span class="n">offset</span> <span class="n">either</span> <span class="k">as</span> <span class="n">VADDR</span> <span class="ow">or</span> <span class="k">as</span> <span class="n">zero</span><span class="o">..</span>
<span class="n">IDXEN</span>   <span class="o">=</span> <span class="n">Send</span> <span class="n">index</span> <span class="n">either</span> <span class="k">as</span> <span class="n">VADDR</span> <span class="ow">or</span> <span class="k">as</span> <span class="n">zero</span><span class="o">.</span>
<span class="n">GLC</span>     <span class="o">=</span> <span class="n">Global</span> <span class="n">coherency</span><span class="o">.</span>
<span class="n">ADDR64</span>  <span class="o">=</span> <span class="n">Buffer</span> <span class="n">address</span> <span class="n">of</span> <span class="mi">64</span> <span class="n">bits</span><span class="o">.</span>
<span class="n">LDS</span>     <span class="o">=</span> <span class="n">Data</span> <span class="n">read</span> <span class="n">from</span><span class="o">/</span><span class="n">written</span> <span class="n">to</span> <span class="n">LDS</span> <span class="ow">or</span> <span class="n">VGPR</span><span class="o">.</span>
<span class="n">OP</span>      <span class="o">=</span> <span class="n">Opcode</span> <span class="n">instructions</span><span class="o">.</span>
<span class="n">VADDR</span>   <span class="o">=</span> <span class="n">VGPR</span> <span class="n">address</span> <span class="n">source</span><span class="o">.</span>
<span class="n">VDATA</span>   <span class="o">=</span> <span class="n">Destination</span> <span class="n">vector</span> <span class="n">GPR</span><span class="o">.</span>
<span class="n">SRSRC</span>   <span class="o">=</span> <span class="n">Scalar</span> <span class="n">GPR</span> <span class="n">that</span> <span class="n">specifies</span> <span class="n">resource</span> <span class="n">constant</span><span class="o">.</span>
<span class="n">SLC</span>     <span class="o">=</span> <span class="n">System</span> <span class="n">level</span> <span class="n">coherent</span><span class="o">.</span>
<span class="n">TFE</span>     <span class="o">=</span> <span class="n">Texture</span> <span class="n">fail</span> <span class="n">enable</span><span class="o">.</span>
<span class="n">SOFFSET</span> <span class="o">=</span> <span class="n">Byte</span> <span class="n">offset</span> <span class="n">added</span> <span class="n">to</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">of</span> <span class="n">an</span> <span class="n">SGPR</span><span class="o">.</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="33%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>BUFFER_LOAD_FORMAT_X</td>
<td>Untyped buffer load 1 dword with format
conversion.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>BUFFER_LOAD_FORMAT_X
Y</td>
<td>Untyped buffer load 2 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>BUFFER_LOAD_FORMAT_X
YZ</td>
<td>Untyped buffer load 3 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>BUFFER_LOAD_FORMAT_X
YZW</td>
<td>Untyped buffer load 4 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>BUFFER_STORE_FORMAT_
X</td>
<td>Untyped buffer store 1 dword with format
conversion.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>BUFFER_STORE_FORMAT_
XY</td>
<td>Untyped buffer store 2 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>BUFFER_STORE_FORMAT_
XYZ</td>
<td>Untyped buffer store 3 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>BUFFER_STORE_FORMAT_
XYZW</td>
<td>Untyped buffer store 4 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>BUFFER_LOAD_FORMAT_D
16_X</td>
<td>Untyped buffer load 1 dword with format
conversion. D0[15:0] = {8’h0, MEM[ADDR]}.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>BUFFER_LOAD_FORMAT_D
16_XY</td>
<td>Untyped buffer load 1 dword with format
conversion.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>BUFFER_LOAD_FORMAT_D
16_XYZ</td>
<td>Untyped buffer load 2 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>BUFFER_LOAD_FORMAT_D
16_XYZW</td>
<td>Untyped buffer load 2 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>12</td>
<td>BUFFER_STORE_FORMAT_
D16_X</td>
<td>Untyped buffer store 1 dword with format
conversion.</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>BUFFER_STORE_FORMAT_
D16_XY</td>
<td>Untyped buffer store 1 dword with format
conversion.</td>
</tr>
<tr class="row-even"><td>14</td>
<td>BUFFER_STORE_FORMAT_
D16_XYZ</td>
<td>Untyped buffer store 2 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>BUFFER_STORE_FORMAT_
D16_XYZW</td>
<td>Untyped buffer store 2 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>16</td>
<td>BUFFER_LOAD_UBYTE</td>
<td>Untyped buffer load unsigned byte (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>BUFFER_LOAD_SBYTE</td>
<td>Untyped buffer load signed byte (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>18</td>
<td>BUFFER_LOAD_USHORT</td>
<td>Untyped buffer load unsigned short (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>BUFFER_LOAD_SSHORT</td>
<td>Untyped buffer load signed short (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>20</td>
<td>BUFFER_LOAD_DWORD</td>
<td>Untyped buffer load dword.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>BUFFER_LOAD_DWORDX2</td>
<td>Untyped buffer load 2 dwords.</td>
</tr>
<tr class="row-even"><td>22</td>
<td>BUFFER_LOAD_DWORDX3</td>
<td>Untyped buffer load 3 dwords.</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>BUFFER_LOAD_DWORDX4</td>
<td>Untyped buffer load 4 dwords.</td>
</tr>
<tr class="row-even"><td>24</td>
<td>BUFFER_STORE_BYTE</td>
<td>Untyped buffer store byte. Stores
S0[7:0].</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>BUFFER_STORE_BYTE_D1
6_HI</td>
<td>Untyped buffer store byte. Stores
S0[23:16].</td>
</tr>
<tr class="row-even"><td>26</td>
<td>BUFFER_STORE_SHORT</td>
<td>Untyped buffer store short. Stores
S0[15:0].</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>BUFFER_STORE_SHORT_D
16_HI</td>
<td>Untyped buffer store short. Stores
S0[31:16].</td>
</tr>
<tr class="row-even"><td>28</td>
<td>BUFFER_STORE_DWORD</td>
<td>Untyped buffer store dword.</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>BUFFER_STORE_DWORDX2</td>
<td>Untyped buffer store 2 dwords.</td>
</tr>
<tr class="row-even"><td>30</td>
<td>BUFFER_STORE_DWORDX3</td>
<td>Untyped buffer store 3 dwords.</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>BUFFER_STORE_DWORDX4</td>
<td>Untyped buffer store 4 dwords.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>BUFFER_LOAD_UBYTE_D1
6</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>BUFFER_LOAD_UBYTE_D1
6_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-even"><td>34</td>
<td>BUFFER_LOAD_SBYTE_D1
6</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>BUFFER_LOAD_SBYTE_D1
6_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>BUFFER_LOAD_SHORT_D1
6</td>
<td>D0[15:0] = MEM[ADDR]. Untyped buffer load
short.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>BUFFER_LOAD_SHORT_D1
6_HI</td>
<td>D0[31:16] = MEM[ADDR]. Untyped buffer
load short.</td>
</tr>
<tr class="row-even"><td>38</td>
<td>BUFFER_LOAD_FORMAT_D
16_HI_X</td>
<td>D0[31:16] = MEM[ADDR]. Untyped buffer
load 1 dword with format conversion.</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>BUFFER_STORE_FORMAT_
D16_HI_X</td>
<td>Untyped buffer store 1 dword with format
conversion.</td>
</tr>
<tr class="row-even"><td>61</td>
<td>BUFFER_STORE_LDS_DWO
RD</td>
<td>Store one DWORD from LDS memory to system
memory without utilizing VGPRs.</td>
</tr>
<tr class="row-odd"><td>62</td>
<td>BUFFER_WBINVL1</td>
<td>Write back and invalidate the shader L1.
Returns ACK to shader.</td>
</tr>
<tr class="row-even"><td>63</td>
<td>BUFFER_WBINVL1_VOL</td>
<td>Write back and invalidate the shader L1
only for lines that are marked volatile.
Returns ACK to shader.</td>
</tr>
<tr class="row-odd"><td>64</td>
<td>BUFFER_ATOMIC_SWAP</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] =
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>65</td>
<td>BUFFER_ATOMIC_CMPSWAP</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA[0];
cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0] = tmp.</td>
</tr>
<tr class="row-odd"><td>66</td>
<td>BUFFER_ATOMIC_ADD</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>67</td>
<td>BUFFER_ATOMIC_SUB</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>BUFFER_ATOMIC_SMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] =
(DATA &lt; tmp) ? DATA : tmp; // signed
compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>69</td>
<td>BUFFER_ATOMIC_UMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] =
(DATA &lt; tmp) ? DATA : tmp; // unsigned
compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>BUFFER_ATOMIC_SMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] =
(DATA &gt; tmp) ? DATA : tmp; // signed
compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>71</td>
<td>BUFFER_ATOMIC_UMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] =
(DATA &gt; tmp) ? DATA : tmp; // unsigned
compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>BUFFER_ATOMIC_AND</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>73</td>
<td>BUFFER_ATOMIC_OR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>BUFFER_ATOMIC_XOR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>75</td>
<td>BUFFER_ATOMIC_INC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] =
(tmp &gt;= DATA) ? 0 : tmp + 1; // unsigned
compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>BUFFER_ATOMIC_DEC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] =
(tmp == 0 || tmp &gt; DATA) ? DATA : tmp -
1; // unsigned compare RETURN_DATA =
tmp.</td>
</tr>
<tr class="row-even"><td>96</td>
<td>BUFFER_ATOMIC_SWAP_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] =
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>97</td>
<td>BUFFER_ATOMIC_CMPSWAP
_X2</td>
<td>// 64bit tmp = MEM[ADDR]; src =
DATA[0:1]; cmp = DATA[2:3]; MEM[ADDR] =
(tmp == cmp) ? src : tmp;
RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>98</td>
<td>BUFFER_ATOMIC_ADD_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>99</td>
<td>BUFFER_ATOMIC_SUB_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>100</td>
<td>BUFFER_ATOMIC_SMIN_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>101</td>
<td>BUFFER_ATOMIC_UMIN_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>102</td>
<td>BUFFER_ATOMIC_SMAX_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>103</td>
<td>BUFFER_ATOMIC_UMAX_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>104</td>
<td>BUFFER_ATOMIC_AND_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>105</td>
<td>BUFFER_ATOMIC_OR_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>106</td>
<td>BUFFER_ATOMIC_XOR_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>107</td>
<td>BUFFER_ATOMIC_INC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] =
(tmp &gt;= DATA[0:1]) ? 0 : tmp + 1; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>108</td>
<td>BUFFER_ATOMIC_DEC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] =
(tmp == 0 || tmp &gt; DATA[0:1]) ?
DATA[0:1] : tmp - 1; // unsigned compare
RETURN_DATA[0:1] = tmp.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="mtbuf-instructions">
<h3>MTBUF Instructions<a class="headerlink" href="#mtbuf-instructions" title="Permalink to this headline">¶</a></h3>
<p>The bitfield map of the MTBUF format is:</p>
<p><img alt="microcode mtbuf" src="GCN_ISA_Manuals/images/microcode/microcode_mtbuf.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">where</span><span class="p">:</span>

<span class="n">OFFSET</span>  <span class="o">=</span> <span class="n">Unsigned</span> <span class="n">immediate</span> <span class="n">byte</span> <span class="n">offset</span><span class="o">.</span>
<span class="n">OFFEN</span>   <span class="o">=</span> <span class="n">Send</span> <span class="n">offset</span> <span class="n">either</span> <span class="k">as</span> <span class="n">VADDR</span> <span class="ow">or</span> <span class="k">as</span> <span class="n">zero</span><span class="o">.</span>
<span class="n">IDXEN</span>   <span class="o">=</span> <span class="n">Send</span> <span class="n">index</span> <span class="n">either</span> <span class="k">as</span> <span class="n">VADDR</span> <span class="ow">or</span> <span class="k">as</span> <span class="n">zero</span><span class="o">.</span>
<span class="n">GLC</span>     <span class="o">=</span> <span class="n">Global</span> <span class="n">coherency</span><span class="o">.</span>
<span class="n">ADDR64</span>  <span class="o">=</span> <span class="n">Buffer</span> <span class="n">address</span> <span class="n">of</span> <span class="mi">64</span> <span class="n">bits</span><span class="o">.</span>
<span class="n">OP</span>      <span class="o">=</span> <span class="n">Opcode</span> <span class="n">instructions</span><span class="o">.</span>
<span class="n">DFMT</span>    <span class="o">=</span> <span class="n">Data</span> <span class="nb">format</span> <span class="k">for</span> <span class="n">typed</span> <span class="n">buffer</span><span class="o">.</span>
<span class="n">NFMT</span>    <span class="o">=</span> <span class="n">Number</span> <span class="nb">format</span> <span class="k">for</span> <span class="n">typed</span> <span class="n">buffer</span><span class="o">.</span>
<span class="n">VADDR</span>   <span class="o">=</span> <span class="n">VGPR</span> <span class="n">address</span> <span class="n">source</span><span class="o">.</span>
<span class="n">VDATA</span>   <span class="o">=</span> <span class="n">Vector</span> <span class="n">GPR</span> <span class="k">for</span> <span class="n">read</span><span class="o">/</span><span class="n">write</span> <span class="n">result</span><span class="o">.</span>
<span class="n">SRSRC</span>   <span class="o">=</span> <span class="n">Scalar</span> <span class="n">GPR</span> <span class="n">that</span> <span class="n">specifies</span> <span class="n">resource</span> <span class="n">constant</span><span class="o">.</span>
<span class="n">SOFFSET</span> <span class="o">=</span> <span class="n">Unsigned</span> <span class="n">byte</span> <span class="n">offset</span> <span class="kn">from</span> <span class="nn">an</span> <span class="n">SGPR</span><span class="o">.</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="34%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>TBUFFER_LOAD_FORMAT_X</td>
<td>Typed buffer load 1 dword with format
conversion.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>TBUFFER_LOAD_FORMAT_X
Y</td>
<td>Typed buffer load 2 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>TBUFFER_LOAD_FORMAT_X
YZ</td>
<td>Typed buffer load 3 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>TBUFFER_LOAD_FORMAT_X
YZW</td>
<td>Typed buffer load 4 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>TBUFFER_STORE_FORMAT_
X</td>
<td>Typed buffer store 1 dword with format
conversion.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>TBUFFER_STORE_FORMAT_
XY</td>
<td>Typed buffer store 2 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>TBUFFER_STORE_FORMAT_
XYZ</td>
<td>Typed buffer store 3 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>TBUFFER_STORE_FORMAT_
XYZW</td>
<td>Typed buffer store 4 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>TBUFFER_LOAD_FORMAT_D
16_X</td>
<td>Typed buffer load 1 dword with format
conversion.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>TBUFFER_LOAD_FORMAT_D
16_XY</td>
<td>Typed buffer load 1 dword with format
conversion.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>TBUFFER_LOAD_FORMAT_D
16_XYZ</td>
<td>Typed buffer load 2 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>TBUFFER_LOAD_FORMAT_D
16_XYZW</td>
<td>Typed buffer load 2 dwords with format
conversion.</td>
</tr>
<tr class="row-even"><td>12</td>
<td>TBUFFER_STORE_FORMAT_
D16_X</td>
<td>Typed buffer store 1 dword with format
conversion.</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>TBUFFER_STORE_FORMAT_
D16_XY</td>
<td>Typed buffer store 1 dword with format
conversion.</td>
</tr>
<tr class="row-even"><td>14</td>
<td>TBUFFER_STORE_FORMAT_
D16_XYZ</td>
<td>Typed buffer store 2 dwords with format
conversion.</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>TBUFFER_STORE_FORMAT_
D16_XYZW</td>
<td>Typed buffer store 2 dwords with format
conversion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="mimg-instructions">
<h3>MIMG Instructions<a class="headerlink" href="#mimg-instructions" title="Permalink to this headline">¶</a></h3>
<p>The bitfield map of the MIMG format is:</p>
<p><img alt="microcode mimg" src="../_images/microcode_mimg.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">where</span><span class="p">:</span>

<span class="n">DMASK</span> <span class="o">=</span> <span class="n">Enable</span> <span class="n">mask</span> <span class="k">for</span> <span class="n">image</span> <span class="n">read</span><span class="o">/</span><span class="n">write</span> <span class="n">data</span> <span class="n">components</span><span class="o">.</span>
<span class="n">UNRM</span>  <span class="o">=</span> <span class="n">Force</span> <span class="n">address</span> <span class="n">to</span> <span class="n">be</span> <span class="n">unnormalized</span><span class="o">.</span>
<span class="n">GLC</span>   <span class="o">=</span> <span class="n">Global</span> <span class="n">coherency</span><span class="o">.</span>
<span class="n">DA</span>    <span class="o">=</span> <span class="n">Declare</span> <span class="n">an</span> <span class="n">array</span><span class="o">.</span>
<span class="n">A16</span>   <span class="o">=</span> <span class="n">Texture</span> <span class="n">address</span> <span class="n">component</span> <span class="n">size</span><span class="o">.</span>
<span class="n">TFE</span>   <span class="o">=</span> <span class="n">Texture</span> <span class="n">fail</span> <span class="n">enable</span><span class="o">.</span>
<span class="n">LWE</span>   <span class="o">=</span> <span class="n">LOD</span> <span class="n">warning</span> <span class="n">enable</span><span class="o">.</span>
<span class="n">OP</span>    <span class="o">=</span> <span class="n">Opcode</span> <span class="n">instructions</span><span class="o">.</span>
<span class="n">SLC</span>   <span class="o">=</span> <span class="n">System</span> <span class="n">level</span> <span class="n">coherent</span><span class="o">.</span>
<span class="n">VADDR</span> <span class="o">=</span> <span class="n">VGPR</span> <span class="n">address</span> <span class="n">source</span><span class="o">.</span>
<span class="n">VDATA</span> <span class="o">=</span> <span class="n">Vector</span> <span class="n">GPR</span> <span class="k">for</span> <span class="n">read</span><span class="o">/</span><span class="n">write</span> <span class="n">result</span><span class="o">.</span>
<span class="n">SRSRC</span> <span class="o">=</span> <span class="n">Scalar</span> <span class="n">GPR</span> <span class="n">that</span> <span class="n">specifies</span> <span class="n">resource</span> <span class="n">constant</span><span class="o">.</span>
<span class="n">SSAMP</span> <span class="o">=</span> <span class="n">Scalar</span> <span class="n">GPR</span> <span class="n">that</span> <span class="n">specifies</span> <span class="n">sampler</span> <span class="n">constant</span><span class="o">.</span>
<span class="n">D16</span>   <span class="o">=</span> <span class="n">Data</span> <span class="ow">in</span> <span class="n">VGPRs</span> <span class="ow">is</span> <span class="mi">16</span> <span class="n">bits</span><span class="p">,</span> <span class="ow">not</span> <span class="mi">32</span> <span class="n">bits</span><span class="o">.</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="30%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>IMAGE_LOAD</td>
<td>Image memory load with format conversion
specified in T#. No sampler.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>IMAGE_LOAD_MIP</td>
<td>Image memory load with user-supplied mip
level. No sampler.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>IMAGE_LOAD_PCK</td>
<td>Image memory load with no format
conversion. No sampler.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>IMAGE_LOAD_PCK_SGN</td>
<td>Image memory load with with no format
conversion and sign extension. No sampler.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>IMAGE_LOAD_MIP_PCK</td>
<td>Image memory load with user-supplied mip
level, no format conversion. No sampler.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>IMAGE_LOAD_MIP_PCK
_SGN</td>
<td>Image memory load with user-supplied mip
level, no format conversion and with sign
extension. No sampler.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>IMAGE_STORE</td>
<td>Image memory store with format conversion
specified in T#. No sampler.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>IMAGE_STORE_MIP</td>
<td>Image memory store with format conversion
specified in T# to user specified mip
level. No sampler.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>IMAGE_STORE_PCK</td>
<td>Image memory store of packed data without
format conversion . No sampler.</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>IMAGE_STORE_MIP_PC
K</td>
<td>Image memory store of packed data without
format conversion to user-supplied mip
level. No sampler.</td>
</tr>
<tr class="row-even"><td>14</td>
<td>IMAGE_GET_RESINFO</td>
<td>return resource info for a given mip level
specified in the address vgpr. No sampler.
Returns 4 integer values into VGPRs 3-0:
{num_mip_levels, depth, height, width}.</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>IMAGE_ATOMIC_SWAP</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>17</td>
<td>IMAGE_ATOMIC_CMPSWA
P</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA[0];
cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0] = tmp.</td>
</tr>
<tr class="row-odd"><td>18</td>
<td>IMAGE_ATOMIC_ADD</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>19</td>
<td>IMAGE_ATOMIC_SUB</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>20</td>
<td>IMAGE_ATOMIC_SMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&lt; tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>21</td>
<td>IMAGE_ATOMIC_UMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&lt; tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>22</td>
<td>IMAGE_ATOMIC_SMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&gt; tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>23</td>
<td>IMAGE_ATOMIC_UMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&gt; tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>IMAGE_ATOMIC_AND</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>25</td>
<td>IMAGE_ATOMIC_OR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>26</td>
<td>IMAGE_ATOMIC_XOR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>27</td>
<td>IMAGE_ATOMIC_INC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
&gt;= DATA) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>28</td>
<td>IMAGE_ATOMIC_DEC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
== 0 || tmp &gt; DATA) ? DATA : tmp - 1; //
unsigned compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>IMAGE_SAMPLE</td>
<td>sample texture map.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>IMAGE_SAMPLE_CL</td>
<td>sample texture map, with LOD clamp
specified in shader.</td>
</tr>
<tr class="row-even"><td>34</td>
<td>IMAGE_SAMPLE_D</td>
<td>sample texture map, with user derivatives</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>IMAGE_SAMPLE_D_CL</td>
<td>sample texture map, with LOD clamp
specified in shader, with user derivatives.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>IMAGE_SAMPLE_L</td>
<td>sample texture map, with user LOD.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>IMAGE_SAMPLE_B</td>
<td>sample texture map, with lod bias.</td>
</tr>
<tr class="row-even"><td>38</td>
<td>IMAGE_SAMPLE_B_CL</td>
<td>sample texture map, with LOD clamp
specified in shader, with lod bias.</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>IMAGE_SAMPLE_LZ</td>
<td>sample texture map, from level 0.</td>
</tr>
<tr class="row-even"><td>40</td>
<td>IMAGE_SAMPLE_C</td>
<td>sample texture map, with PCF.</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>IMAGE_SAMPLE_C_CL</td>
<td>SAMPLE_C, with LOD clamp specified in
shader.</td>
</tr>
<tr class="row-even"><td>42</td>
<td>IMAGE_SAMPLE_C_D</td>
<td>SAMPLE_C, with user derivatives.</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>IMAGE_SAMPLE_C_D_
CL</td>
<td>SAMPLE_C, with LOD clamp specified in
shader, with user derivatives.</td>
</tr>
<tr class="row-even"><td>44</td>
<td>IMAGE_SAMPLE_C_L</td>
<td>SAMPLE_C, with user LOD.</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>IMAGE_SAMPLE_C_B</td>
<td>SAMPLE_C, with lod bias.</td>
</tr>
<tr class="row-even"><td>46</td>
<td>IMAGE_SAMPLE_C_B_
CL</td>
<td>SAMPLE_C, with LOD clamp specified in
shader, with lod bias.</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>IMAGE_SAMPLE_C_LZ</td>
<td>SAMPLE_C, from level 0.</td>
</tr>
<tr class="row-even"><td>48</td>
<td>IMAGE_SAMPLE_O</td>
<td>sample texture map, with user offsets.</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>IMAGE_SAMPLE_CL_O</td>
<td>SAMPLE_O with LOD clamp specified in
shader.</td>
</tr>
<tr class="row-even"><td>50</td>
<td>IMAGE_SAMPLE_D_O</td>
<td>SAMPLE_O, with user derivatives.</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>IMAGE_SAMPLE_D_CL_O</td>
<td>SAMPLE_O, with LOD clamp specified in
shader, with user derivatives.</td>
</tr>
<tr class="row-even"><td>52</td>
<td>IMAGE_SAMPLE_L_O</td>
<td>SAMPLE_O, with user LOD.</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>IMAGE_SAMPLE_B_O</td>
<td>SAMPLE_O, with lod bias.</td>
</tr>
<tr class="row-even"><td>54</td>
<td>IMAGE_SAMPLE_B_CL_O</td>
<td>SAMPLE_O, with LOD clamp specified in
shader, with lod bias.</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>IMAGE_SAMPLE_LZ_O</td>
<td>SAMPLE_O, from level 0.</td>
</tr>
<tr class="row-even"><td>56</td>
<td>IMAGE_SAMPLE_C_O</td>
<td>SAMPLE_C with user specified offsets.</td>
</tr>
<tr class="row-odd"><td>57</td>
<td>IMAGE_SAMPLE_C_CL_O</td>
<td>SAMPLE_C_O, with LOD clamp specified in
shader.</td>
</tr>
<tr class="row-even"><td>58</td>
<td>IMAGE_SAMPLE_C_D_
O</td>
<td>SAMPLE_C_O, with user derivatives.</td>
</tr>
<tr class="row-odd"><td>59</td>
<td>IMAGE_SAMPLE_C_D_
CL_O</td>
<td>SAMPLE_C_O, with LOD clamp specified in
shader, with user derivatives.</td>
</tr>
<tr class="row-even"><td>60</td>
<td>IMAGE_SAMPLE_C_L_
O</td>
<td>SAMPLE_C_O, with user LOD.</td>
</tr>
<tr class="row-odd"><td>61</td>
<td>IMAGE_SAMPLE_C_B_
O</td>
<td>SAMPLE_C_O, with lod bias.</td>
</tr>
<tr class="row-even"><td>62</td>
<td>IMAGE_SAMPLE_C_B_
CL_O</td>
<td>SAMPLE_C_O, with LOD clamp specified in
shader, with lod bias.</td>
</tr>
<tr class="row-odd"><td>63</td>
<td>IMAGE_SAMPLE_C_LZ_O</td>
<td>SAMPLE_C_O, from level 0.</td>
</tr>
<tr class="row-even"><td>64</td>
<td>IMAGE_GATHER4</td>
<td>gather 4 single component elements (2x2).</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>IMAGE_GATHER4_CL</td>
<td>gather 4 single component elements (2x2)
with user LOD clamp.</td>
</tr>
<tr class="row-even"><td>66</td>
<td>IMAGE_GATHER4H</td>
<td>Same as Gather4, but fetches one component
per texel, from a 4x1 group of texels.</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>IMAGE_GATHER4_L</td>
<td>gather 4 single component elements (2x2)
with user LOD.</td>
</tr>
<tr class="row-even"><td>69</td>
<td>IMAGE_GATHER4_B</td>
<td>gather 4 single component elements (2x2)
with user bias.</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>IMAGE_GATHER4_B_CL</td>
<td>gather 4 single component elements (2x2)
with user bias and clamp.</td>
</tr>
<tr class="row-even"><td>71</td>
<td>IMAGE_GATHER4_LZ</td>
<td>gather 4 single component elements (2x2) at
level 0.</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>IMAGE_GATHER4_C</td>
<td>gather 4 single component elements (2x2)
with PCF.</td>
</tr>
<tr class="row-even"><td>73</td>
<td>IMAGE_GATHER4_C_CL</td>
<td>gather 4 single component elements (2x2)
with user LOD clamp and PCF.</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>IMAGE_GATHER4H_PCK</td>
<td>Same as GATHER4H, but fetched elements are
treated as a single component and packed
into GPR(s).</td>
</tr>
<tr class="row-even"><td>75</td>
<td>IMAGE_GATHER8H_PCK</td>
<td>Simliar to GATHER4H_PCK, but packs eight
elements from a 8x1 group of texels.</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>IMAGE_GATHER4_C_L</td>
<td>gather 4 single component elements (2x2)
with user LOD and PCF.</td>
</tr>
<tr class="row-even"><td>77</td>
<td>IMAGE_GATHER4_C_B</td>
<td>gather 4 single component elements (2x2)
with user bias and PCF.</td>
</tr>
<tr class="row-odd"><td>78</td>
<td>IMAGE_GATHER4_C_B_CL</td>
<td>gather 4 single component elements (2x2)
with user bias, clamp and PCF.</td>
</tr>
<tr class="row-even"><td>79</td>
<td>IMAGE_GATHER4_C_LZ</td>
<td>gather 4 single component elements (2x2) at
level 0, with PCF.</td>
</tr>
<tr class="row-odd"><td>80</td>
<td>IMAGE_GATHER4_O</td>
<td>GATHER4, with user offsets.</td>
</tr>
<tr class="row-even"><td>81</td>
<td>IMAGE_GATHER4_CL_O</td>
<td>GATHER4_CL, with user offsets.</td>
</tr>
<tr class="row-odd"><td>84</td>
<td>IMAGE_GATHER4_L_O</td>
<td>GATHER4_L, with user offsets.</td>
</tr>
<tr class="row-even"><td>85</td>
<td>IMAGE_GATHER4_B_O</td>
<td>GATHER4_B, with user offsets.</td>
</tr>
<tr class="row-odd"><td>86</td>
<td>IMAGE_GATHER4_B_CL
_O</td>
<td>GATHER4_B_CL, with user offsets.</td>
</tr>
<tr class="row-even"><td>87</td>
<td>IMAGE_GATHER4_LZ_O</td>
<td>GATHER4_LZ, with user offsets.</td>
</tr>
<tr class="row-odd"><td>88</td>
<td>IMAGE_GATHER4_C_O</td>
<td>GATHER4_C, with user offsets.</td>
</tr>
<tr class="row-even"><td>89</td>
<td>IMAGE_GATHER4_C_CL
_O</td>
<td>GATHER4_C_CL, with user offsets.</td>
</tr>
<tr class="row-odd"><td>92</td>
<td>IMAGE_GATHER4_C_L_O</td>
<td>GATHER4_C_L, with user offsets.</td>
</tr>
<tr class="row-even"><td>93</td>
<td>IMAGE_GATHER4_C_B_O</td>
<td>GATHER4_B, with user offsets.</td>
</tr>
<tr class="row-odd"><td>94</td>
<td>IMAGE_GATHER4_C_B_CL_O</td>
<td>GATHER4_B_CL, with user offsets.</td>
</tr>
<tr class="row-even"><td>95</td>
<td>IMAGE_GATHER4_C_LZ
_O</td>
<td>GATHER4_C_LZ, with user offsets.</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>IMAGE_GET_LOD</td>
<td>Return calculated LOD. Vdata gets 2 32bit
integer values: { rawLOD, clampedLOD }.</td>
</tr>
<tr class="row-even"><td>104</td>
<td>IMAGE_SAMPLE_CD</td>
<td>sample texture map, with user derivatives
(LOD per quad)</td>
</tr>
<tr class="row-odd"><td>105</td>
<td>IMAGE_SAMPLE_CD_CL</td>
<td>sample texture map, with LOD clamp
specified in shader, with user derivatives
(LOD per quad).</td>
</tr>
<tr class="row-even"><td>106</td>
<td>IMAGE_SAMPLE_C_CD</td>
<td>SAMPLE_C, with user derivatives (LOD per
quad).</td>
</tr>
<tr class="row-odd"><td>107</td>
<td>IMAGE_SAMPLE_C_CD_CL</td>
<td>SAMPLE_C, with LOD clamp specified in
shader, with user derivatives (LOD per
quad).</td>
</tr>
<tr class="row-even"><td>108</td>
<td>IMAGE_SAMPLE_CD_O</td>
<td>SAMPLE_O, with user derivatives (LOD per
quad).</td>
</tr>
<tr class="row-odd"><td>109</td>
<td>IMAGE_SAMPLE_CD_CL
_O</td>
<td>SAMPLE_O, with LOD clamp specified in
shader, with user derivatives (LOD per
quad).</td>
</tr>
<tr class="row-even"><td>110</td>
<td>IMAGE_SAMPLE_C_CD_O</td>
<td>SAMPLE_C_O, with user derivatives (LOD
per quad).</td>
</tr>
<tr class="row-odd"><td>111</td>
<td>IMAGE_SAMPLE_C_CD_CL_O</td>
<td>SAMPLE_C_O, with LOD clamp specified in
shader, with user derivatives (LOD per
quad).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="export-instructions">
<h3>EXPORT Instructions<a class="headerlink" href="#export-instructions" title="Permalink to this headline">¶</a></h3>
<p>Transfer vertex position, vertex parameter, pixel color, or pixel depth
information to the output buffer. Every pixel shader must do at least
one export to a color, depth or NULL target with the VM bit set to 1.
This communicates the pixel-valid mask to the color and depth buffers.
Every pixel does only one of the above export types with the DONE bit
set to 1. Vertex shaders must do one or more position exports, and at
least one parameter export. The final position export must have the DONE
bit set to 1.</p>
<p><img alt="microcode exp" src="../_images/microcode_exp.png" /></p>
</div>
<div class="section" id="flat-scratch-and-global-instructions">
<h3>FLAT, Scratch and Global Instructions<a class="headerlink" href="#flat-scratch-and-global-instructions" title="Permalink to this headline">¶</a></h3>
<p>The bitfield map of the FLAT format is:</p>
<p><img alt="microcode flat" src="../_images/microcode_flat.png" /></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">where</span><span class="p">:</span>

<span class="n">GLC</span>    <span class="o">=</span> <span class="n">Global</span> <span class="n">coherency</span><span class="o">.</span>
<span class="n">SLC</span>    <span class="o">=</span> <span class="n">System</span> <span class="n">level</span> <span class="n">coherency</span><span class="o">.</span>
<span class="n">OP</span>     <span class="o">=</span> <span class="n">Opcode</span> <span class="n">instructions</span><span class="o">.</span>
<span class="n">ADDR</span>   <span class="o">=</span> <span class="n">Source</span> <span class="n">of</span> <span class="n">flat</span> <span class="n">address</span> <span class="n">VGPR</span><span class="o">.</span>
<span class="n">DATA</span>   <span class="o">=</span> <span class="n">Source</span> <span class="n">data</span><span class="o">.</span>
<span class="n">VDST</span>   <span class="o">=</span> <span class="n">Destination</span> <span class="n">VGPR</span><span class="o">.</span>
<span class="n">NV</span>     <span class="o">=</span> <span class="n">Access</span> <span class="n">to</span> <span class="n">non</span><span class="o">-</span><span class="n">volatile</span> <span class="n">memory</span><span class="o">.</span>
<span class="n">SADDR</span>  <span class="o">=</span> <span class="n">SGPR</span> <span class="n">holding</span> <span class="n">address</span> <span class="ow">or</span> <span class="n">offset</span>
<span class="n">SEG</span>    <span class="o">=</span> <span class="n">Instruction</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Flat</span><span class="p">,</span> <span class="n">Scratch</span><span class="p">,</span> <span class="ow">or</span> <span class="n">Global</span>
<span class="n">LDS</span>    <span class="o">=</span> <span class="n">Data</span> <span class="ow">is</span> <span class="n">transferred</span> <span class="n">between</span> <span class="n">LDS</span> <span class="ow">and</span> <span class="n">Memory</span><span class="p">,</span> <span class="ow">not</span> <span class="n">VGPRs</span><span class="o">.</span>
<span class="n">OFFSET</span> <span class="o">=</span> <span class="n">Immediate</span> <span class="n">address</span> <span class="n">byte</span><span class="o">-</span><span class="n">offset</span><span class="o">.</span>
</pre></div>
</div>
<div class="section" id="flat-instructions">
<h4>Flat Instructions<a class="headerlink" href="#flat-instructions" title="Permalink to this headline">¶</a></h4>
<p>Flat instructions look at the per-workitem address and determine for
each work item if the target memory address is in global, private or
scratch memory.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="30%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>FLAT_LOAD_UBYTE</td>
<td>Untyped buffer load unsigned byte (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>FLAT_LOAD_SBYTE</td>
<td>Untyped buffer load signed byte (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>18</td>
<td>FLAT_LOAD_USHORT</td>
<td>Untyped buffer load unsigned short (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>FLAT_LOAD_SSHORT</td>
<td>Untyped buffer load signed short (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>20</td>
<td>FLAT_LOAD_DWORD</td>
<td>Untyped buffer load dword.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>FLAT_LOAD_DWORDX2</td>
<td>Untyped buffer load 2 dwords.</td>
</tr>
<tr class="row-even"><td>22</td>
<td>FLAT_LOAD_DWORDX3</td>
<td>Untyped buffer load 3 dwords.</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>FLAT_LOAD_DWORDX4</td>
<td>Untyped buffer load 4 dwords.</td>
</tr>
<tr class="row-even"><td>24</td>
<td>FLAT_STORE_BYTE</td>
<td>Untyped buffer store byte. Stores S0[7:0].</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>FLAT_STORE_BYTE_D1
6_HI</td>
<td>Untyped buffer store byte. Stores
S0[23:16].</td>
</tr>
<tr class="row-even"><td>26</td>
<td>FLAT_STORE_SHORT</td>
<td>Untyped buffer store short. Stores
S0[15:0].</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>FLAT_STORE_SHORT_D
16_HI</td>
<td>Untyped buffer store short. Stores
S0[31:16].</td>
</tr>
<tr class="row-even"><td>28</td>
<td>FLAT_STORE_DWORD</td>
<td>Untyped buffer store dword.</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>FLAT_STORE_DWORDX2</td>
<td>Untyped buffer store 2 dwords.</td>
</tr>
<tr class="row-even"><td>30</td>
<td>FLAT_STORE_DWORDX3</td>
<td>Untyped buffer store 3 dwords.</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>FLAT_STORE_DWORDX4</td>
<td>Untyped buffer store 4 dwords.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>FLAT_LOAD_UBYTE_D1
6</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>FLAT_LOAD_UBYTE_D1
6_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-even"><td>34</td>
<td>FLAT_LOAD_SBYTE_D1
6</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>FLAT_LOAD_SBYTE_D1
6_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>FLAT_LOAD_SHORT_D1
6</td>
<td>D0[15:0] = MEM[ADDR]. Untyped buffer load
short.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>FLAT_LOAD_SHORT_D1
6_HI</td>
<td>D0[31:16] = MEM[ADDR]. Untyped buffer load
short.</td>
</tr>
<tr class="row-even"><td>64</td>
<td>FLAT_ATOMIC_SWAP</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>FLAT_ATOMIC_CMPSWAP</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA[0];
cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0] = tmp.</td>
</tr>
<tr class="row-even"><td>66</td>
<td>FLAT_ATOMIC_ADD</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>FLAT_ATOMIC_SUB</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>68</td>
<td>FLAT_ATOMIC_SMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&lt; tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>FLAT_ATOMIC_UMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&lt; tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>70</td>
<td>FLAT_ATOMIC_SMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&gt; tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>FLAT_ATOMIC_UMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&gt; tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>72</td>
<td>FLAT_ATOMIC_AND</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>FLAT_ATOMIC_OR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>74</td>
<td>FLAT_ATOMIC_XOR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>FLAT_ATOMIC_INC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
&gt;= DATA) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>76</td>
<td>FLAT_ATOMIC_DEC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
== 0 || tmp &gt; DATA) ? DATA : tmp - 1; //
unsigned compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>FLAT_ATOMIC_SWAP_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] =
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>97</td>
<td>FLAT_ATOMIC_CMPSWAP
_X2</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA[0:1];
cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>FLAT_ATOMIC_ADD_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>99</td>
<td>FLAT_ATOMIC_SUB_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>FLAT_ATOMIC_SMIN_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>101</td>
<td>FLAT_ATOMIC_UMIN_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>FLAT_ATOMIC_SMAX_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>103</td>
<td>FLAT_ATOMIC_UMAX_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>FLAT_ATOMIC_AND_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>105</td>
<td>FLAT_ATOMIC_OR_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>FLAT_ATOMIC_XOR_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>107</td>
<td>FLAT_ATOMIC_INC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
&gt;= DATA[0:1]) ? 0 : tmp + 1; // unsigned
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>FLAT_ATOMIC_DEC_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
== 0 || tmp &gt; DATA[0:1]) ? DATA[0:1] :
tmp - 1; // unsigned compare
RETURN_DATA[0:1] = tmp.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="scratch-instructions">
<h4>Scratch Instructions<a class="headerlink" href="#scratch-instructions" title="Permalink to this headline">¶</a></h4>
<p>Scratch instructions are like Flat, but assume all workitem addresses
fall in scratch (private) space.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="30%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>SCRATCH_LOAD_UBYTE</td>
<td>Untyped buffer load unsigned byte (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>SCRATCH_LOAD_SBYTE</td>
<td>Untyped buffer load signed byte (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>18</td>
<td>SCRATCH_LOAD_USHORT</td>
<td>Untyped buffer load unsigned short (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>SCRATCH_LOAD_SSHORT</td>
<td>Untyped buffer load signed short (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>20</td>
<td>SCRATCH_LOAD_DWORD</td>
<td>Untyped buffer load dword.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>SCRATCH_LOAD_DWORDX
2</td>
<td>Untyped buffer load 2 dwords.</td>
</tr>
<tr class="row-even"><td>22</td>
<td>SCRATCH_LOAD_DWORDX
3</td>
<td>Untyped buffer load 3 dwords.</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>SCRATCH_LOAD_DWORDX
4</td>
<td>Untyped buffer load 4 dwords.</td>
</tr>
<tr class="row-even"><td>24</td>
<td>SCRATCH_STORE_BYTE</td>
<td>Untyped buffer store byte. Stores S0[7:0].</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>SCRATCH_STORE_BYTE_D16_HI</td>
<td>Untyped buffer store byte. Stores
S0[23:16].</td>
</tr>
<tr class="row-even"><td>26</td>
<td>SCRATCH_STORE_SHORT</td>
<td>Untyped buffer store short. Stores
S0[15:0].</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>SCRATCH_STORE_SHORT
_D16_HI</td>
<td>Untyped buffer store short. Stores
S0[31:16].</td>
</tr>
<tr class="row-even"><td>28</td>
<td>SCRATCH_STORE_DWORD</td>
<td>Untyped buffer store dword.</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>SCRATCH_STORE_DWORD
X2</td>
<td>Untyped buffer store 2 dwords.</td>
</tr>
<tr class="row-even"><td>30</td>
<td>SCRATCH_STORE_DWORD
X3</td>
<td>Untyped buffer store 3 dwords.</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>SCRATCH_STORE_DWORD
X4</td>
<td>Untyped buffer store 4 dwords.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>SCRATCH_LOAD_UBYTE_D16</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>SCRATCH_LOAD_UBYTE_D16_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-even"><td>34</td>
<td>SCRATCH_LOAD_SBYTE_D16</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>SCRATCH_LOAD_SBYTE_D16_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>SCRATCH_LOAD_SHORT_D16</td>
<td>D0[15:0] = MEM[ADDR]. Untyped buffer load
short.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>SCRATCH_LOAD_SHORT_D16_HI</td>
<td>D0[31:16] = MEM[ADDR]. Untyped buffer load
short.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="global-instructions">
<h4>Global Instructions<a class="headerlink" href="#global-instructions" title="Permalink to this headline">¶</a></h4>
<p>Global instructions are like Flat, but assume all workitem addresses
fall in global memory space.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="30%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>GLOBAL_LOAD_UBYTE</td>
<td>Untyped buffer load unsigned byte (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>GLOBAL_LOAD_SBYTE</td>
<td>Untyped buffer load signed byte (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>18</td>
<td>GLOBAL_LOAD_USHORT</td>
<td>Untyped buffer load unsigned short (zero
extend to VGPR destination).</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>GLOBAL_LOAD_SSHORT</td>
<td>Untyped buffer load signed short (sign
extend to VGPR destination).</td>
</tr>
<tr class="row-even"><td>20</td>
<td>GLOBAL_LOAD_DWORD</td>
<td>Untyped buffer load dword.</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>GLOBAL_LOAD_DWORDX2</td>
<td>Untyped buffer load 2 dwords.</td>
</tr>
<tr class="row-even"><td>22</td>
<td>GLOBAL_LOAD_DWORDX3</td>
<td>Untyped buffer load 3 dwords.</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>GLOBAL_LOAD_DWORDX4</td>
<td>Untyped buffer load 4 dwords.</td>
</tr>
<tr class="row-even"><td>24</td>
<td>GLOBAL_STORE_BYTE</td>
<td>Untyped buffer store byte. Stores S0[7:0].</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>GLOBAL_STORE_BYTE_
D16_HI</td>
<td>Untyped buffer store byte. Stores
S0[23:16].</td>
</tr>
<tr class="row-even"><td>26</td>
<td>GLOBAL_STORE_SHORT</td>
<td>Untyped buffer store short. Stores
S0[15:0].</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>GLOBAL_STORE_SHORT_D16_HI</td>
<td>Untyped buffer store short. Stores
S0[31:16].</td>
</tr>
<tr class="row-even"><td>28</td>
<td>GLOBAL_STORE_DWORD</td>
<td>Untyped buffer store dword.</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>GLOBAL_STORE_DWORDX
2</td>
<td>Untyped buffer store 2 dwords.</td>
</tr>
<tr class="row-even"><td>30</td>
<td>GLOBAL_STORE_DWORDX
3</td>
<td>Untyped buffer store 3 dwords.</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>GLOBAL_STORE_DWORDX
4</td>
<td>Untyped buffer store 4 dwords.</td>
</tr>
<tr class="row-even"><td>32</td>
<td>GLOBAL_LOAD_UBYTE_
D16</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>GLOBAL_LOAD_UBYTE_
D16_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load unsigned byte.</td>
</tr>
<tr class="row-even"><td>34</td>
<td>GLOBAL_LOAD_SBYTE_
D16</td>
<td>D0[15:0] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>GLOBAL_LOAD_SBYTE_
D16_HI</td>
<td>D0[31:16] = {8’h0, MEM[ADDR]}. Untyped
buffer load signed byte.</td>
</tr>
<tr class="row-even"><td>36</td>
<td>GLOBAL_LOAD_SHORT_
D16</td>
<td>D0[15:0] = MEM[ADDR]. Untyped buffer load
short.</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>GLOBAL_LOAD_SHORT_
D16_HI</td>
<td>D0[31:16] = MEM[ADDR]. Untyped buffer load
short.</td>
</tr>
<tr class="row-even"><td>64</td>
<td>GLOBAL_ATOMIC_SWAP</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = DATA;
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>GLOBAL_ATOMIC_CMPSW
AP</td>
<td>// 32bit tmp = MEM[ADDR]; src = DATA[0];
cmp = DATA[1]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0] = tmp.</td>
</tr>
<tr class="row-even"><td>66</td>
<td>GLOBAL_ATOMIC_ADD</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>GLOBAL_ATOMIC_SUB</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>68</td>
<td>GLOBAL_ATOMIC_SMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&lt; tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>GLOBAL_ATOMIC_UMIN</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&lt; tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>70</td>
<td>GLOBAL_ATOMIC_SMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&gt; tmp) ? DATA : tmp; // signed compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>GLOBAL_ATOMIC_UMAX</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (DATA
&gt; tmp) ? DATA : tmp; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>72</td>
<td>GLOBAL_ATOMIC_AND</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>GLOBAL_ATOMIC_OR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>74</td>
<td>GLOBAL_ATOMIC_XOR</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA; RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>GLOBAL_ATOMIC_INC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
&gt;= DATA) ? 0 : tmp + 1; // unsigned compare
RETURN_DATA = tmp.</td>
</tr>
<tr class="row-even"><td>76</td>
<td>GLOBAL_ATOMIC_DEC</td>
<td>// 32bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
== 0 || tmp &gt; DATA) ? DATA : tmp - 1; //
unsigned compare RETURN_DATA = tmp.</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>GLOBAL_ATOMIC_SWAP_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] =
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>97</td>
<td>GLOBAL_ATOMIC_CMPSW
AP_X2</td>
<td>// 64bit tmp = MEM[ADDR]; src = DATA[0:1];
cmp = DATA[2:3]; MEM[ADDR] = (tmp == cmp) ?
src : tmp; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>GLOBAL_ATOMIC_ADD_
X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] +=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>99</td>
<td>GLOBAL_ATOMIC_SUB_
X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>GLOBAL_ATOMIC_SMIN_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>101</td>
<td>GLOBAL_ATOMIC_UMIN_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &lt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>GLOBAL_ATOMIC_SMAX_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
signed compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>103</td>
<td>GLOBAL_ATOMIC_UMAX_X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] -=
(DATA[0:1] &gt; tmp) ? DATA[0:1] : tmp; //
unsigned compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>GLOBAL_ATOMIC_AND_
X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] &amp;=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>105</td>
<td>GLOBAL_ATOMIC_OR_X
2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] |=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>GLOBAL_ATOMIC_XOR_
X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] ^=
DATA[0:1]; RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-even"><td>107</td>
<td>GLOBAL_ATOMIC_INC_
X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
&gt;= DATA[0:1]) ? 0 : tmp + 1; // unsigned
compare RETURN_DATA[0:1] = tmp.</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>GLOBAL_ATOMIC_DEC_
X2</td>
<td>// 64bit tmp = MEM[ADDR]; MEM[ADDR] = (tmp
== 0 || tmp &gt; DATA[0:1]) ? DATA[0:1] :
tmp - 1; // unsigned compare
RETURN_DATA[0:1] = tmp.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="instruction-limitations">
<h3>Instruction Limitations<a class="headerlink" href="#instruction-limitations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="dpp">
<h4>DPP<a class="headerlink" href="#dpp" title="Permalink to this headline">¶</a></h4>
<p>The following instructions cannot use DPP:</p>
<ul class="simple">
<li>V_MADMK_F32</li>
<li>V_MADAK_F32</li>
<li>V_MADMK_F16</li>
<li>V_MADAK_F16</li>
<li>V_READFIRSTLANE_B32</li>
<li>V_CVT_I32_F64</li>
<li>V_CVT_F64_I32</li>
<li>V_CVT_F32_F64</li>
<li>V_CVT_F64_F32</li>
<li>V_CVT_U32_F64</li>
<li>V_CVT_F64_U32</li>
<li>V_TRUNC_F64</li>
<li>V_CEIL_F64</li>
<li>V_RNDNE_F64</li>
<li>V_FLOOR_F64</li>
<li>V_RCP_F64</li>
<li>V_RSQ_F64</li>
<li>V_SQRT_F64</li>
<li>V_FREXP_EXP_I32_F64</li>
<li>V_FREXP_MANT_F64</li>
<li>V_FRACT_F64</li>
<li>V_CLREXCP</li>
<li>V_SWAP_B32</li>
<li>V_CMP_CLASS_F64</li>
<li>V_CMPX_CLASS_F64</li>
<li>V_CMP_*_F64</li>
<li>V_CMPX_*_F64</li>
<li>V_CMP_*_I64</li>
<li>V_CMP_*_U64</li>
<li>V_CMPX_*_I64</li>
<li>V_CMPX_*_U64</li>
</ul>
</div>
<div class="section" id="sdwa">
<h4>SDWA<a class="headerlink" href="#sdwa" title="Permalink to this headline">¶</a></h4>
<p>The following instructions cannot use SDWA:</p>
<ul class="simple">
<li>V_MAC_F32</li>
<li>V_MADMK_F32</li>
<li>V_MADAK_F32</li>
<li>V_MAC_F16</li>
<li>V_MADMK_F16</li>
<li>V_MADAK_F16</li>
<li>V_FMAC_F32</li>
<li>V_READFIRSTLANE_B32</li>
<li>V_CLREXCP</li>
<li>V_SWAP_B32</li>
</ul>
</div>
</div>
</div>
<div class="section" id="microcode-formats">
<h2>Microcode Formats<a class="headerlink" href="#microcode-formats" title="Permalink to this headline">¶</a></h2>
<p>This section specifies the microcode formats. The definitions can be
used to simplify compilation by providing standard templates and
enumeration names for the various instruction formats.</p>
<p>Endian Order - The GCN architecture addresses memory and registers using
littleendian byte-ordering and bit-ordering. Multi-byte values are
stored with their least-significant (low-order) byte (LSB) at the lowest
byte address, and they are illustrated with their LSB at the right side.
Byte values are stored with their least-significant (low-order) bit
(lsb) at the lowest bit address, and they are illustrated with their lsb
at the right side.</p>
<p>The table below summarizes the microcode formats and their widths. The
sections that follow provide details</p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="30%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Microcode Formats</th>
<th class="head">Reference</th>
<th class="head">Width
(bits)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>Scalar ALU and Control Formats</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>SOP2</td>
<td><a class="reference external" href="#_sop2">section_title</a></td>
<td>32</td>
</tr>
<tr class="row-even"><td>SOP1</td>
<td><a class="reference external" href="#_sop1">section_title</a></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>SOPK</td>
<td><a class="reference external" href="#_sopk">section_title</a></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOPP</td>
<td><a class="reference external" href="#_sopp">section_title</a></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>SOPC</td>
<td><a class="reference external" href="#_sopc">section_title</a></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>Scalar Memory Format</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>SMEM</td>
<td><a class="reference external" href="#_smem">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-even"><td><strong>Vector ALU Format</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>VOP1</td>
<td><a class="reference external" href="#_vop1">section_title</a></td>
<td>32</td>
</tr>
<tr class="row-even"><td>VOP2</td>
<td><a class="reference external" href="#_vop2">section_title</a></td>
<td>32</td>
</tr>
<tr class="row-odd"><td>VOPC</td>
<td><a class="reference external" href="#_vopc">section_title</a></td>
<td>32</td>
</tr>
<tr class="row-even"><td>VOP3A</td>
<td><a class="reference external" href="#_vop3a">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-odd"><td>VOP3B</td>
<td><a class="reference external" href="#_vop3b">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-even"><td>VOP3P</td>
<td><a class="reference external" href="#_vop3p">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-odd"><td>DPP</td>
<td><a class="reference external" href="#_dpp">section_title</a></td>
<td>32</td>
</tr>
<tr class="row-even"><td>SDWA</td>
<td><a class="reference external" href="#_vop2">section_title</a></td>
<td>32</td>
</tr>
<tr class="row-odd"><td><strong>Vector Parameter Interpolation
Format</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>VINTRP</td>
<td><a class="reference external" href="#_vintrp">section_title</a></td>
<td>32</td>
</tr>
<tr class="row-odd"><td><strong>LDS/GDS Format</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>DS</td>
<td><a href="#id19"><span class="problematic" id="id20">`section\_title &lt;#_ds
&gt;`__</span></a></td>
<td>64</td>
</tr>
<tr class="row-odd"><td><strong>Vector Memory Buffer Formats</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>MTBUF</td>
<td><a class="reference external" href="#MTUBF">???</a></td>
<td>64</td>
</tr>
<tr class="row-odd"><td>MUBUF</td>
<td><a class="reference external" href="#_mubuf">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-even"><td><strong>Vector Memory Image Format</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>MIMG</td>
<td><a class="reference external" href="#_mimg">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-even"><td><strong>Export Format</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>EXP</td>
<td><a class="reference external" href="#_exp">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-even"><td><strong>Flat Formats</strong></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>FLAT</td>
<td><a class="reference external" href="#_flat">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-even"><td>GLOBAL</td>
<td><a class="reference external" href="#_global_2">section_title</a></td>
<td>64</td>
</tr>
<tr class="row-odd"><td>SCRATCH</td>
<td><a class="reference external" href="#_scratch_2">section_title</a></td>
<td>64</td>
</tr>
</tbody>
</table>
<p>Table: Summary of Microcode Formats</p>
<p>The field-definition tables that accompany the descriptions in the
sections below use the following notation.</p>
<ul class="simple">
<li>int(2) - A two-bit field that specifies an unsigned integer value.</li>
<li>enum(7) - A seven-bit field that specifies an enumerated set of
values (in this case, a set of up to 27 values). The number of valid
values can be less than the maximum.</li>
</ul>
<p>The default value of all fields is zero. Any bitfield not identified is
assumed to be reserved.</p>
<p><strong>Instruction Suffixes</strong></p>
<p>Most instructions include a suffix which indicates the data type the
instruction handles. This suffix may also include a number which
indicate the size of the data.</p>
<p>For example: “F32” indicates “32-bit floating point data”, or “B16” is
“16-bit binary data”.</p>
<ul class="simple">
<li>B = binary</li>
<li>F = floating point</li>
<li>U = unsigned integer</li>
<li>S = signed integer</li>
</ul>
<p>When more than one data-type specifier occurs in an instruction, the
last one is the result type and size, and the earlier one(s) is/are
input data type and size.</p>
<div class="section" id="scalar-alu-and-control-formats">
<h3>Scalar ALU and Control Formats<a class="headerlink" href="#scalar-alu-and-control-formats" title="Permalink to this headline">¶</a></h3>
<div class="section" id="sop2">
<h4>SOP2<a class="headerlink" href="#sop2" title="Permalink to this headline">¶</a></h4>
<p>Scalar format with Two inputs, one output</p>
<p><img alt="microcode sop2" src="../_images/microcode_sop2.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SOP2</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>This is a scalar instruction with two inputs and one output.
Can be followed by a 32-bit literal constant.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SSRC0</td>
<td><div class="first last line-block">
<div class="line">[7:0]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249 -
250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">Reserved.</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>SSRC1</td>
<td>[15:8]</td>
<td><div class="first last line-block">
<div class="line">Second scalar source operand.</div>
<div class="line">Same codes as SSRC0, above.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>SDST</td>
<td>[22:16]</td>
<td><div class="first last line-block">
<div class="line">Scalar destination.</div>
<div class="line">Same codes as SSRC0, above except only codes
0-127 are valid.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[29:23]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-even"><td>ENCODING</td>
<td>[31:30]</td>
<td>Must be: 10</td>
</tr>
</tbody>
</table>
<p>Table: SOP2 Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_ADD_U32</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_SUB_U32</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_ADD_I32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_SUB_I32</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_ADDC_U32</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_SUBB_U32</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_MIN_I32</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_MIN_U32</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_MAX_I32</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_MAX_U32</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_CSELECT_B32</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_CSELECT_B64</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_AND_B32</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_AND_B64</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_OR_B32</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_OR_B64</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_XOR_B32</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_XOR_B64</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_ANDN2_B32</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_ANDN2_B64</td>
</tr>
<tr class="row-even"><td>20</td>
<td>S_ORN2_B32</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>S_ORN2_B64</td>
</tr>
<tr class="row-even"><td>22</td>
<td>S_NAND_B32</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>S_NAND_B64</td>
</tr>
<tr class="row-even"><td>24</td>
<td>S_NOR_B32</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>S_NOR_B64</td>
</tr>
<tr class="row-even"><td>26</td>
<td>S_XNOR_B32</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>S_XNOR_B64</td>
</tr>
<tr class="row-even"><td>28</td>
<td>S_LSHL_B32</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>S_LSHL_B64</td>
</tr>
<tr class="row-even"><td>30</td>
<td>S_LSHR_B32</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>S_LSHR_B64</td>
</tr>
<tr class="row-even"><td>32</td>
<td>S_ASHR_I32</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>S_ASHR_I64</td>
</tr>
<tr class="row-even"><td>34</td>
<td>S_BFM_B32</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>S_BFM_B64</td>
</tr>
<tr class="row-even"><td>36</td>
<td>S_MUL_I32</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>S_BFE_U32</td>
</tr>
<tr class="row-even"><td>38</td>
<td>S_BFE_I32</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>S_BFE_U64</td>
</tr>
<tr class="row-even"><td>40</td>
<td>S_BFE_I64</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>S_CBRANCH_G_FORK</td>
</tr>
<tr class="row-even"><td>42</td>
<td>S_ABSDIFF_I32</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>S_RFE_RESTORE_B64</td>
</tr>
<tr class="row-even"><td>44</td>
<td>S_MUL_HI_U32</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>S_MUL_HI_I32</td>
</tr>
<tr class="row-even"><td>46</td>
<td>S_LSHL1_ADD_U32</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>S_LSHL2_ADD_U32</td>
</tr>
<tr class="row-even"><td>48</td>
<td>S_LSHL3_ADD_U32</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>S_LSHL4_ADD_U32</td>
</tr>
<tr class="row-even"><td>50</td>
<td>S_PACK_LL_B32_B16</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>S_PACK_LH_B32_B16</td>
</tr>
<tr class="row-even"><td>52</td>
<td>S_PACK_HH_B32_B16</td>
</tr>
</tbody>
</table>
<p>Table: SOP2 Opcodes</p>
</div>
<div class="section" id="sopk">
<h4>SOPK<a class="headerlink" href="#sopk" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode sopk" src="../_images/microcode_sopk.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SOPK</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>This is a scalar instruction with one 16-bit signed immediate
(SIMM16) input and a single destination. Instructions which
take 2 inputs use the destination as the second input.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="14%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SIMM16</td>
<td>[15:0]</td>
<td>Signed immediate 16-bit value.</td>
</tr>
<tr class="row-odd"><td>SDST</td>
<td><div class="first line-block">
<div class="line">[22:16]</div>
</div>
<div class="line-block">
<div class="line">0 - 101</div>
</div>
<div class="last line-block">
<div class="line-block">
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
</div>
<div class="line">108-123</div>
<div class="line-block">
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Scalar destination, and can provide second
source operand.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
</div>
</td>
</tr>
<tr class="row-even"><td>OP</td>
<td>[27:23]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:28]</td>
<td>Must be: 1011</td>
</tr>
</tbody>
</table>
<p>Table: SOPK Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_MOVK_I32</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_CMOVK_I32</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_CMPK_EQ_I32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_CMPK_LG_I32</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_CMPK_GT_I32</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_CMPK_GE_I32</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_CMPK_LT_I32</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_CMPK_LE_I32</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_CMPK_EQ_U32</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_CMPK_LG_U32</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_CMPK_GT_U32</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_CMPK_GE_U32</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_CMPK_LT_U32</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_CMPK_LE_U32</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_ADDK_I32</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_MULK_I32</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_CBRANCH_I_FORK</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_GETREG_B32</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_SETREG_B32</td>
</tr>
<tr class="row-odd"><td>20</td>
<td>S_SETREG_IMM32_B32</td>
</tr>
<tr class="row-even"><td>21</td>
<td>S_CALL_B64</td>
</tr>
</tbody>
</table>
<p>Table: SOPK Opcodes</p>
</div>
<div class="section" id="sop1">
<h4>SOP1<a class="headerlink" href="#sop1" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode sop1" src="../_images/microcode_sop1.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SOP1</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>This is a scalar instruction with two inputs and one output.
Can be followed by a 32-bit literal constant.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SSRC0</td>
<td><div class="first last line-block">
<div class="line">[7:0]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249 -
250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">Reserved.</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[15:8]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-even"><td>SDST</td>
<td>[22:16]</td>
<td><div class="first last line-block">
<div class="line">Scalar destination.</div>
<div class="line">Same codes as SSRC0, above except only codes
0-127 are valid.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:23]</td>
<td>Must be: 10_1111101</td>
</tr>
</tbody>
</table>
<p>Table: SOP1 Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_MOV_B32</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_MOV_B64</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_CMOV_B32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_CMOV_B64</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_NOT_B32</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_NOT_B64</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_WQM_B32</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_WQM_B64</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_BREV_B32</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_BREV_B64</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_BCNT0_I32_B32</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_BCNT0_I32_B64</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_BCNT1_I32_B32</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_BCNT1_I32_B64</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_FF0_I32_B32</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_FF0_I32_B64</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_FF1_I32_B32</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_FF1_I32_B64</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_FLBIT_I32_B32</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_FLBIT_I32_B64</td>
</tr>
<tr class="row-even"><td>20</td>
<td>S_FLBIT_I32</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>S_FLBIT_I32_I64</td>
</tr>
<tr class="row-even"><td>22</td>
<td>S_SEXT_I32_I8</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>S_SEXT_I32_I16</td>
</tr>
<tr class="row-even"><td>24</td>
<td>S_BITSET0_B32</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>S_BITSET0_B64</td>
</tr>
<tr class="row-even"><td>26</td>
<td>S_BITSET1_B32</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>S_BITSET1_B64</td>
</tr>
<tr class="row-even"><td>28</td>
<td>S_GETPC_B64</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>S_SETPC_B64</td>
</tr>
<tr class="row-even"><td>30</td>
<td>S_SWAPPC_B64</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>S_RFE_B64</td>
</tr>
<tr class="row-even"><td>32</td>
<td>S_AND_SAVEEXEC_B64</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>S_OR_SAVEEXEC_B64</td>
</tr>
<tr class="row-even"><td>34</td>
<td>S_XOR_SAVEEXEC_B64</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>S_ANDN2_SAVEEXEC_B64</td>
</tr>
<tr class="row-even"><td>36</td>
<td>S_ORN2_SAVEEXEC_B64</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>S_NAND_SAVEEXEC_B64</td>
</tr>
<tr class="row-even"><td>38</td>
<td>S_NOR_SAVEEXEC_B64</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>S_XNOR_SAVEEXEC_B64</td>
</tr>
<tr class="row-even"><td>40</td>
<td>S_QUADMASK_B32</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>S_QUADMASK_B64</td>
</tr>
<tr class="row-even"><td>42</td>
<td>S_MOVRELS_B32</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>S_MOVRELS_B64</td>
</tr>
<tr class="row-even"><td>44</td>
<td>S_MOVRELD_B32</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>S_MOVRELD_B64</td>
</tr>
<tr class="row-even"><td>46</td>
<td>S_CBRANCH_JOIN</td>
</tr>
<tr class="row-odd"><td>48</td>
<td>S_ABS_I32</td>
</tr>
<tr class="row-even"><td>50</td>
<td>S_SET_GPR_IDX_IDX</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>S_ANDN1_SAVEEXEC_B64</td>
</tr>
<tr class="row-even"><td>52</td>
<td>S_ORN1_SAVEEXEC_B64</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>S_ANDN1_WREXEC_B64</td>
</tr>
<tr class="row-even"><td>54</td>
<td>S_ANDN2_WREXEC_B64</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>S_BITREPLICATE_B64_B32</td>
</tr>
</tbody>
</table>
<p>Table: SOP1 Opcodes</p>
</div>
<div class="section" id="sopc">
<h4>SOPC<a class="headerlink" href="#sopc" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode sop1" src="../_images/microcode_sop1.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SOPC</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>This is a scalar instruction with two inputs which are
compared and produce SCC as a result. Can be followed by a
32-bit literal constant.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SSRC0</td>
<td><div class="first last line-block">
<div class="line">[7:0]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249 -
250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">Reserved.</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>SSRC1</td>
<td>[15:8]</td>
<td><div class="first last line-block">
<div class="line">Second scalar source operand.</div>
<div class="line">Same codes as SSRC0, above.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>OP</td>
<td>[22:16]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:23]</td>
<td>Must be: 10_1111110</td>
</tr>
</tbody>
</table>
<p>Table: SOPC Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_CMP_EQ_I32</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_CMP_LG_I32</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_CMP_GT_I32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_CMP_GE_I32</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_CMP_LT_I32</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_CMP_LE_I32</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_CMP_EQ_U32</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_CMP_LG_U32</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_CMP_GT_U32</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_CMP_GE_U32</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_CMP_LT_U32</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_CMP_LE_U32</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_BITCMP0_B32</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_BITCMP1_B32</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_BITCMP0_B64</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_BITCMP1_B64</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_SETVSKIP</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_SET_GPR_IDX_ON</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_CMP_EQ_U64</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_CMP_LG_U64</td>
</tr>
</tbody>
</table>
<p>Table: SOPC Opcodes</p>
</div>
<div class="section" id="sopp">
<h4>SOPP<a class="headerlink" href="#sopp" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode sopp" src="../_images/microcode_sopp.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SOPP</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>This is a scalar instruction with one 16-bit signed immediate
(SIMM16) input.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SIMM16</td>
<td>[15:0]</td>
<td>Signed immediate 16-bit value.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[22:16]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-even"><td>ENCODING</td>
<td>[31:23]</td>
<td>Must be: 10_1111111</td>
</tr>
</tbody>
</table>
<p>Table: SOPP Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_NOP</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_ENDPGM</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_BRANCH</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_WAKEUP</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_CBRANCH_SCC0</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_CBRANCH_SCC1</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_CBRANCH_VCCZ</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_CBRANCH_VCCNZ</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_CBRANCH_EXECZ</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_CBRANCH_EXECNZ</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_BARRIER</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_SETKILL</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_WAITCNT</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>S_SETHALT</td>
</tr>
<tr class="row-even"><td>14</td>
<td>S_SLEEP</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>S_SETPRIO</td>
</tr>
<tr class="row-even"><td>16</td>
<td>S_SENDMSG</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>S_SENDMSGHALT</td>
</tr>
<tr class="row-even"><td>18</td>
<td>S_TRAP</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>S_ICACHE_INV</td>
</tr>
<tr class="row-even"><td>20</td>
<td>S_INCPERFLEVEL</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>S_DECPERFLEVEL</td>
</tr>
<tr class="row-even"><td>22</td>
<td>S_TTRACEDATA</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>S_CBRANCH_CDBGSYS</td>
</tr>
<tr class="row-even"><td>24</td>
<td>S_CBRANCH_CDBGUSER</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>S_CBRANCH_CDBGSYS_OR_USER</td>
</tr>
<tr class="row-even"><td>26</td>
<td>S_CBRANCH_CDBGSYS_AND_USER</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>S_ENDPGM_SAVED</td>
</tr>
<tr class="row-even"><td>28</td>
<td>S_SET_GPR_IDX_OFF</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>S_SET_GPR_IDX_MODE</td>
</tr>
<tr class="row-even"><td>30</td>
<td>S_ENDPGM_ORDERED_PS_DONE</td>
</tr>
</tbody>
</table>
<p>Table: SOPP Opcodes</p>
</div>
</div>
<div class="section" id="scalar-memory-format">
<h3>Scalar Memory Format<a class="headerlink" href="#scalar-memory-format" title="Permalink to this headline">¶</a></h3>
<div class="section" id="smem">
<h4>SMEM<a class="headerlink" href="#smem" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode smem" src="../_images/microcode_smem.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SMEM</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Scalar Memory data load/store</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SBASE</td>
<td>[5:0]</td>
<td>SGPR-pair which provides base address or
SGPR-quad which provides V#. (LSB of SGPR address
is omitted).</td>
</tr>
<tr class="row-odd"><td>SDATA</td>
<td>[12:6]</td>
<td>SGPR which provides write data or accepts return
data.</td>
</tr>
<tr class="row-even"><td>SOE</td>
<td>[14]</td>
<td>Scalar offset enable.</td>
</tr>
<tr class="row-odd"><td>NV</td>
<td>[15]</td>
<td>Non-volatile</td>
</tr>
<tr class="row-even"><td>GLC</td>
<td>[16]</td>
<td>Globally memory Coherent. Force bypass of L1
cache, or for atomics, cause pre-op value to be
returned.</td>
</tr>
<tr class="row-odd"><td>IMM</td>
<td>[17]</td>
<td>Immediate enable.</td>
</tr>
<tr class="row-even"><td>OP</td>
<td>[25:18]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 110000</td>
</tr>
<tr class="row-even"><td>OFFSET</td>
<td>[52:32]</td>
<td>An immediate signed byte offset, or the address
of an SGPR holding the unsigned byte offset.
Signed offsets only work with S_LOAD/STORE.</td>
</tr>
<tr class="row-odd"><td>SOFFSET</td>
<td>[63:57]</td>
<td>SGPR offset. Used only when SOFFSET_EN = 1 May
only specify an SGPR or M0.</td>
</tr>
</tbody>
</table>
<p>Table: SMEM Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>S_LOAD_DWORD</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>S_LOAD_DWORDX2</td>
</tr>
<tr class="row-even"><td>2</td>
<td>S_LOAD_DWORDX4</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>S_LOAD_DWORDX8</td>
</tr>
<tr class="row-even"><td>4</td>
<td>S_LOAD_DWORDX16</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>S_SCRATCH_LOAD_DWORD</td>
</tr>
<tr class="row-even"><td>6</td>
<td>S_SCRATCH_LOAD_DWORDX2</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>S_SCRATCH_LOAD_DWORDX4</td>
</tr>
<tr class="row-even"><td>8</td>
<td>S_BUFFER_LOAD_DWORD</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>S_BUFFER_LOAD_DWORDX2</td>
</tr>
<tr class="row-even"><td>10</td>
<td>S_BUFFER_LOAD_DWORDX4</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>S_BUFFER_LOAD_DWORDX8</td>
</tr>
<tr class="row-even"><td>12</td>
<td>S_BUFFER_LOAD_DWORDX16</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>S_STORE_DWORD</td>
</tr>
<tr class="row-even"><td>17</td>
<td>S_STORE_DWORDX2</td>
</tr>
<tr class="row-odd"><td>18</td>
<td>S_STORE_DWORDX4</td>
</tr>
<tr class="row-even"><td>21</td>
<td>S_SCRATCH_STORE_DWORD</td>
</tr>
<tr class="row-odd"><td>22</td>
<td>S_SCRATCH_STORE_DWORDX2</td>
</tr>
<tr class="row-even"><td>23</td>
<td>S_SCRATCH_STORE_DWORDX4</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>S_BUFFER_STORE_DWORD</td>
</tr>
<tr class="row-even"><td>25</td>
<td>S_BUFFER_STORE_DWORDX2</td>
</tr>
<tr class="row-odd"><td>26</td>
<td>S_BUFFER_STORE_DWORDX4</td>
</tr>
<tr class="row-even"><td>32</td>
<td>S_DCACHE_INV</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>S_DCACHE_WB</td>
</tr>
<tr class="row-even"><td>34</td>
<td>S_DCACHE_INV_VOL</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>S_DCACHE_WB_VOL</td>
</tr>
<tr class="row-even"><td>36</td>
<td>S_MEMTIME</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>S_MEMREALTIME</td>
</tr>
<tr class="row-even"><td>38</td>
<td>S_ATC_PROBE</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>S_ATC_PROBE_BUFFER</td>
</tr>
<tr class="row-even"><td>40</td>
<td>S_DCACHE_DISCARD</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>S_DCACHE_DISCARD_X2</td>
</tr>
<tr class="row-even"><td>64</td>
<td>S_BUFFER_ATOMIC_SWAP</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>S_BUFFER_ATOMIC_CMPSWAP</td>
</tr>
<tr class="row-even"><td>66</td>
<td>S_BUFFER_ATOMIC_ADD</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>S_BUFFER_ATOMIC_SUB</td>
</tr>
<tr class="row-even"><td>68</td>
<td>S_BUFFER_ATOMIC_SMIN</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>S_BUFFER_ATOMIC_UMIN</td>
</tr>
<tr class="row-even"><td>70</td>
<td>S_BUFFER_ATOMIC_SMAX</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>S_BUFFER_ATOMIC_UMAX</td>
</tr>
<tr class="row-even"><td>72</td>
<td>S_BUFFER_ATOMIC_AND</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>S_BUFFER_ATOMIC_OR</td>
</tr>
<tr class="row-even"><td>74</td>
<td>S_BUFFER_ATOMIC_XOR</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>S_BUFFER_ATOMIC_INC</td>
</tr>
<tr class="row-even"><td>76</td>
<td>S_BUFFER_ATOMIC_DEC</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>S_BUFFER_ATOMIC_SWAP_X2</td>
</tr>
<tr class="row-even"><td>97</td>
<td>S_BUFFER_ATOMIC_CMPSWAP_X2</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>S_BUFFER_ATOMIC_ADD_X2</td>
</tr>
<tr class="row-even"><td>99</td>
<td>S_BUFFER_ATOMIC_SUB_X2</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>S_BUFFER_ATOMIC_SMIN_X2</td>
</tr>
<tr class="row-even"><td>101</td>
<td>S_BUFFER_ATOMIC_UMIN_X2</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>S_BUFFER_ATOMIC_SMAX_X2</td>
</tr>
<tr class="row-even"><td>103</td>
<td>S_BUFFER_ATOMIC_UMAX_X2</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>S_BUFFER_ATOMIC_AND_X2</td>
</tr>
<tr class="row-even"><td>105</td>
<td>S_BUFFER_ATOMIC_OR_X2</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>S_BUFFER_ATOMIC_XOR_X2</td>
</tr>
<tr class="row-even"><td>107</td>
<td>S_BUFFER_ATOMIC_INC_X2</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>S_BUFFER_ATOMIC_DEC_X2</td>
</tr>
<tr class="row-even"><td>128</td>
<td>S_ATOMIC_SWAP</td>
</tr>
<tr class="row-odd"><td>129</td>
<td>S_ATOMIC_CMPSWAP</td>
</tr>
<tr class="row-even"><td>130</td>
<td>S_ATOMIC_ADD</td>
</tr>
<tr class="row-odd"><td>131</td>
<td>S_ATOMIC_SUB</td>
</tr>
<tr class="row-even"><td>132</td>
<td>S_ATOMIC_SMIN</td>
</tr>
<tr class="row-odd"><td>133</td>
<td>S_ATOMIC_UMIN</td>
</tr>
<tr class="row-even"><td>134</td>
<td>S_ATOMIC_SMAX</td>
</tr>
<tr class="row-odd"><td>135</td>
<td>S_ATOMIC_UMAX</td>
</tr>
<tr class="row-even"><td>136</td>
<td>S_ATOMIC_AND</td>
</tr>
<tr class="row-odd"><td>137</td>
<td>S_ATOMIC_OR</td>
</tr>
<tr class="row-even"><td>138</td>
<td>S_ATOMIC_XOR</td>
</tr>
<tr class="row-odd"><td>139</td>
<td>S_ATOMIC_INC</td>
</tr>
<tr class="row-even"><td>140</td>
<td>S_ATOMIC_DEC</td>
</tr>
<tr class="row-odd"><td>160</td>
<td>S_ATOMIC_SWAP_X2</td>
</tr>
<tr class="row-even"><td>161</td>
<td>S_ATOMIC_CMPSWAP_X2</td>
</tr>
<tr class="row-odd"><td>162</td>
<td>S_ATOMIC_ADD_X2</td>
</tr>
<tr class="row-even"><td>163</td>
<td>S_ATOMIC_SUB_X2</td>
</tr>
<tr class="row-odd"><td>164</td>
<td>S_ATOMIC_SMIN_X2</td>
</tr>
<tr class="row-even"><td>165</td>
<td>S_ATOMIC_UMIN_X2</td>
</tr>
<tr class="row-odd"><td>166</td>
<td>S_ATOMIC_SMAX_X2</td>
</tr>
<tr class="row-even"><td>167</td>
<td>S_ATOMIC_UMAX_X2</td>
</tr>
<tr class="row-odd"><td>168</td>
<td>S_ATOMIC_AND_X2</td>
</tr>
<tr class="row-even"><td>169</td>
<td>S_ATOMIC_OR_X2</td>
</tr>
<tr class="row-odd"><td>170</td>
<td>S_ATOMIC_XOR_X2</td>
</tr>
<tr class="row-even"><td>171</td>
<td>S_ATOMIC_INC_X2</td>
</tr>
<tr class="row-odd"><td>172</td>
<td>S_ATOMIC_DEC_X2</td>
</tr>
</tbody>
</table>
<p>Table: SMEM Opcodes</p>
</div>
</div>
<div class="section" id="vector-alu-formats">
<h3>Vector ALU Formats<a class="headerlink" href="#vector-alu-formats" title="Permalink to this headline">¶</a></h3>
<div class="section" id="vop2">
<h4>VOP2<a class="headerlink" href="#vop2" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode vop2" src="../_images/microcode_vop2.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>VOP2</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Vector ALU format with two operands</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRC0</td>
<td><div class="first last line-block">
<div class="line">[8:0]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249</div>
<div class="line">250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
<div class="line">256 -
511</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">SDWA</div>
<div class="line">DPP</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
<div class="line">VGPR 0 - 255</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>VSRC1</td>
<td>[16:9]</td>
<td>VGPR which provides the second operand.</td>
</tr>
<tr class="row-even"><td>VDST</td>
<td>[24:17]</td>
<td>Destination VGPR.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[30:25]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-even"><td>ENCODING</td>
<td>[31]</td>
<td>Must be: 0</td>
</tr>
</tbody>
</table>
<p>Table: VOP2 Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>V_CNDMASK_B32</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>V_ADD_F32</td>
</tr>
<tr class="row-even"><td>2</td>
<td>V_SUB_F32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>V_SUBREV_F32</td>
</tr>
<tr class="row-even"><td>4</td>
<td>V_MUL_LEGACY_F32</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>V_MUL_F32</td>
</tr>
<tr class="row-even"><td>6</td>
<td>V_MUL_I32_I24</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>V_MUL_HI_I32_I24</td>
</tr>
<tr class="row-even"><td>8</td>
<td>V_MUL_U32_U24</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>V_MUL_HI_U32_U24</td>
</tr>
<tr class="row-even"><td>10</td>
<td>V_MIN_F32</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>V_MAX_F32</td>
</tr>
<tr class="row-even"><td>12</td>
<td>V_MIN_I32</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>V_MAX_I32</td>
</tr>
<tr class="row-even"><td>14</td>
<td>V_MIN_U32</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>V_MAX_U32</td>
</tr>
<tr class="row-even"><td>16</td>
<td>V_LSHRREV_B32</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>V_ASHRREV_I32</td>
</tr>
<tr class="row-even"><td>18</td>
<td>V_LSHLREV_B32</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>V_AND_B32</td>
</tr>
<tr class="row-even"><td>20</td>
<td>V_OR_B32</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>V_XOR_B32</td>
</tr>
<tr class="row-even"><td>22</td>
<td>V_MAC_F32</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>V_MADMK_F32</td>
</tr>
<tr class="row-even"><td>24</td>
<td>V_MADAK_F32</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>V_ADD_CO_U32</td>
</tr>
<tr class="row-even"><td>26</td>
<td>V_SUB_CO_U32</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>V_SUBREV_CO_U32</td>
</tr>
<tr class="row-even"><td>28</td>
<td>V_ADDC_CO_U32</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>V_SUBB_CO_U32</td>
</tr>
<tr class="row-even"><td>30</td>
<td>V_SUBBREV_CO_U32</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>V_ADD_F16</td>
</tr>
<tr class="row-even"><td>32</td>
<td>V_SUB_F16</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>V_SUBREV_F16</td>
</tr>
<tr class="row-even"><td>34</td>
<td>V_MUL_F16</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>V_MAC_F16</td>
</tr>
<tr class="row-even"><td>36</td>
<td>V_MADMK_F16</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>V_MADAK_F16</td>
</tr>
<tr class="row-even"><td>38</td>
<td>V_ADD_U16</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>V_SUB_U16</td>
</tr>
<tr class="row-even"><td>40</td>
<td>V_SUBREV_U16</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>V_MUL_LO_U16</td>
</tr>
<tr class="row-even"><td>42</td>
<td>V_LSHLREV_B16</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>V_LSHRREV_B16</td>
</tr>
<tr class="row-even"><td>44</td>
<td>V_ASHRREV_I16</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>V_MAX_F16</td>
</tr>
<tr class="row-even"><td>46</td>
<td>V_MIN_F16</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>V_MAX_U16</td>
</tr>
<tr class="row-even"><td>48</td>
<td>V_MAX_I16</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>V_MIN_U16</td>
</tr>
<tr class="row-even"><td>50</td>
<td>V_MIN_I16</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>V_LDEXP_F16</td>
</tr>
<tr class="row-even"><td>52</td>
<td>V_ADD_U32</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>V_SUB_U32</td>
</tr>
<tr class="row-even"><td>54</td>
<td>V_SUBREV_U32</td>
</tr>
</tbody>
</table>
<p>Table: VOP2 Opcodes</p>
</div>
<div class="section" id="vop1">
<h4>VOP1<a class="headerlink" href="#vop1" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode vop1" src="../_images/microcode_vop1.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>VOP1</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Vector ALU format with one operand</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRC0</td>
<td><div class="first last line-block">
<div class="line">[8:0]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249</div>
<div class="line">250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
<div class="line">256 -
511</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">SDWA</div>
<div class="line">DPP</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
<div class="line">VGPR 0 - 255</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[16:9]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-even"><td>VDST</td>
<td>[24:17]</td>
<td>Destination VGPR.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:25]</td>
<td>Must be: 0_111111</td>
</tr>
</tbody>
</table>
<p>Table: VOP1 Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>V_NOP</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>V_MOV_B32</td>
</tr>
<tr class="row-even"><td>2</td>
<td>V_READFIRSTLANE_B32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>V_CVT_I32_F64</td>
</tr>
<tr class="row-even"><td>4</td>
<td>V_CVT_F64_I32</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>V_CVT_F32_I32</td>
</tr>
<tr class="row-even"><td>6</td>
<td>V_CVT_F32_U32</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>V_CVT_U32_F32</td>
</tr>
<tr class="row-even"><td>8</td>
<td>V_CVT_I32_F32</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>V_CVT_F16_F32</td>
</tr>
<tr class="row-even"><td>11</td>
<td>V_CVT_F32_F16</td>
</tr>
<tr class="row-odd"><td>12</td>
<td>V_CVT_RPI_I32_F32</td>
</tr>
<tr class="row-even"><td>13</td>
<td>V_CVT_FLR_I32_F32</td>
</tr>
<tr class="row-odd"><td>14</td>
<td>V_CVT_OFF_F32_I4</td>
</tr>
<tr class="row-even"><td>15</td>
<td>V_CVT_F32_F64</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>V_CVT_F64_F32</td>
</tr>
<tr class="row-even"><td>17</td>
<td>V_CVT_F32_UBYTE0</td>
</tr>
<tr class="row-odd"><td>18</td>
<td>V_CVT_F32_UBYTE1</td>
</tr>
<tr class="row-even"><td>19</td>
<td>V_CVT_F32_UBYTE2</td>
</tr>
<tr class="row-odd"><td>20</td>
<td>V_CVT_F32_UBYTE3</td>
</tr>
<tr class="row-even"><td>21</td>
<td>V_CVT_U32_F64</td>
</tr>
<tr class="row-odd"><td>22</td>
<td>V_CVT_F64_U32</td>
</tr>
<tr class="row-even"><td>23</td>
<td>V_TRUNC_F64</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>V_CEIL_F64</td>
</tr>
<tr class="row-even"><td>25</td>
<td>V_RNDNE_F64</td>
</tr>
<tr class="row-odd"><td>26</td>
<td>V_FLOOR_F64</td>
</tr>
<tr class="row-even"><td>27</td>
<td>V_FRACT_F32</td>
</tr>
<tr class="row-odd"><td>28</td>
<td>V_TRUNC_F32</td>
</tr>
<tr class="row-even"><td>29</td>
<td>V_CEIL_F32</td>
</tr>
<tr class="row-odd"><td>30</td>
<td>V_RNDNE_F32</td>
</tr>
<tr class="row-even"><td>31</td>
<td>V_FLOOR_F32</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>V_EXP_F32</td>
</tr>
<tr class="row-even"><td>33</td>
<td>V_LOG_F32</td>
</tr>
<tr class="row-odd"><td>34</td>
<td>V_RCP_F32</td>
</tr>
<tr class="row-even"><td>35</td>
<td>V_RCP_IFLAG_F32</td>
</tr>
<tr class="row-odd"><td>36</td>
<td>V_RSQ_F32</td>
</tr>
<tr class="row-even"><td>37</td>
<td>V_RCP_F64</td>
</tr>
<tr class="row-odd"><td>38</td>
<td>V_RSQ_F64</td>
</tr>
<tr class="row-even"><td>39</td>
<td>V_SQRT_F32</td>
</tr>
<tr class="row-odd"><td>40</td>
<td>V_SQRT_F64</td>
</tr>
<tr class="row-even"><td>41</td>
<td>V_SIN_F32</td>
</tr>
<tr class="row-odd"><td>42</td>
<td>V_COS_F32</td>
</tr>
<tr class="row-even"><td>43</td>
<td>V_NOT_B32</td>
</tr>
<tr class="row-odd"><td>44</td>
<td>V_BFREV_B32</td>
</tr>
<tr class="row-even"><td>45</td>
<td>V_FFBH_U32</td>
</tr>
<tr class="row-odd"><td>46</td>
<td>V_FFBL_B32</td>
</tr>
<tr class="row-even"><td>47</td>
<td>V_FFBH_I32</td>
</tr>
<tr class="row-odd"><td>48</td>
<td>V_FREXP_EXP_I32_F64</td>
</tr>
<tr class="row-even"><td>49</td>
<td>V_FREXP_MANT_F64</td>
</tr>
<tr class="row-odd"><td>50</td>
<td>V_FRACT_F64</td>
</tr>
<tr class="row-even"><td>51</td>
<td>V_FREXP_EXP_I32_F32</td>
</tr>
<tr class="row-odd"><td>52</td>
<td>V_FREXP_MANT_F32</td>
</tr>
<tr class="row-even"><td>53</td>
<td>V_CLREXCP</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>V_SCREEN_PARTITION_4SE_B32</td>
</tr>
<tr class="row-even"><td>57</td>
<td>V_CVT_F16_U16</td>
</tr>
<tr class="row-odd"><td>58</td>
<td>V_CVT_F16_I16</td>
</tr>
<tr class="row-even"><td>59</td>
<td>V_CVT_U16_F16</td>
</tr>
<tr class="row-odd"><td>60</td>
<td>V_CVT_I16_F16</td>
</tr>
<tr class="row-even"><td>61</td>
<td>V_RCP_F16</td>
</tr>
<tr class="row-odd"><td>62</td>
<td>V_SQRT_F16</td>
</tr>
<tr class="row-even"><td>63</td>
<td>V_RSQ_F16</td>
</tr>
<tr class="row-odd"><td>64</td>
<td>V_LOG_F16</td>
</tr>
<tr class="row-even"><td>65</td>
<td>V_EXP_F16</td>
</tr>
<tr class="row-odd"><td>66</td>
<td>V_FREXP_MANT_F16</td>
</tr>
<tr class="row-even"><td>67</td>
<td>V_FREXP_EXP_I16_F16</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>V_FLOOR_F16</td>
</tr>
<tr class="row-even"><td>69</td>
<td>V_CEIL_F16</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>V_TRUNC_F16</td>
</tr>
<tr class="row-even"><td>71</td>
<td>V_RNDNE_F16</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>V_FRACT_F16</td>
</tr>
<tr class="row-even"><td>73</td>
<td>V_SIN_F16</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>V_COS_F16</td>
</tr>
<tr class="row-even"><td>75</td>
<td>V_EXP_LEGACY_F32</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>V_LOG_LEGACY_F32</td>
</tr>
<tr class="row-even"><td>77</td>
<td>V_CVT_NORM_I16_F16</td>
</tr>
<tr class="row-odd"><td>78</td>
<td>V_CVT_NORM_U16_F16</td>
</tr>
<tr class="row-even"><td>79</td>
<td>V_SAT_PK_U8_I16</td>
</tr>
<tr class="row-odd"><td>81</td>
<td>V_SWAP_B32</td>
</tr>
</tbody>
</table>
<p>Table: VOP1 Opcodes</p>
</div>
<div class="section" id="vopc">
<h4>VOPC<a class="headerlink" href="#vopc" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode vopc" src="../_images/microcode_vopc.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>VOPC</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td><p class="first">Vector instruction taking two inputs and producing a
comparison result. Can be followed by a 32- bit literal
constant. Vector Comparison operations are divided into three
groups:</p>
<ul class="last simple">
<li>those which can use any one of 16 comparison operations,</li>
<li>those which can use any one of 8, and</li>
<li>those which have only a single comparison operation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The final opcode number is determined by adding the base for the opcode
family plus the offset from the compare op. Every compare instruction
writes a result to VCC (for VOPC) or an SGPR (for VOP3). Additionally,
every compare instruction has a variant that also writes to the EXEC
mask. The destination of the compare result is always VCC when encoded
using the VOPC format, and can be an arbitrary SGPR when encoded in the
VOP3 format.</p>
<p><strong>Comparison Operations</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Compare
Operation</th>
<th class="head">Opcode
Offset</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Sixteen Compare
Operations
(OP16)</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>F</td>
<td>0</td>
<td>D.u = 0</td>
</tr>
<tr class="row-even"><td>LT</td>
<td>1</td>
<td>D.u = (S0 &lt; S1)</td>
</tr>
<tr class="row-odd"><td>EQ</td>
<td>2</td>
<td>D.u = (S0 == S1)</td>
</tr>
<tr class="row-even"><td>LE</td>
<td>3</td>
<td>D.u = (S0 &lt;= S1)</td>
</tr>
<tr class="row-odd"><td>GT</td>
<td>4</td>
<td>D.u = (S0 &gt; S1)</td>
</tr>
<tr class="row-even"><td>LG</td>
<td>5</td>
<td>D.u = (S0 &lt;&gt; S1)</td>
</tr>
<tr class="row-odd"><td>GE</td>
<td>6</td>
<td>D.u = (S0 &gt;= S1)</td>
</tr>
<tr class="row-even"><td>O</td>
<td>7</td>
<td>D.u = (!isNaN(S0) &amp;&amp; !isNaN(S1))</td>
</tr>
<tr class="row-odd"><td>U</td>
<td>8</td>
<td>D.u = (!isNaN(S0) || !isNaN(S1))</td>
</tr>
<tr class="row-even"><td>NGE</td>
<td>9</td>
<td>D.u = !(S0 &gt;= S1)</td>
</tr>
<tr class="row-odd"><td>NLG</td>
<td>10</td>
<td>D.u = !(S0 &lt;&gt; S1)</td>
</tr>
<tr class="row-even"><td>NGT</td>
<td>11</td>
<td>D.u = !(S0 &gt; S1)</td>
</tr>
<tr class="row-odd"><td>NLE</td>
<td>12</td>
<td>D.u = !(S0 &lt;= S1)</td>
</tr>
<tr class="row-even"><td>NEQ</td>
<td>13</td>
<td>D.u = !(S0 == S1)</td>
</tr>
<tr class="row-odd"><td>NLT</td>
<td>14</td>
<td>D.u = !(S0 &lt; S1)</td>
</tr>
<tr class="row-even"><td>TRU</td>
<td>15</td>
<td>D.u = 1</td>
</tr>
<tr class="row-odd"><td>Eight Compare
Operations
(OP8)</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>F</td>
<td>0</td>
<td>D.u = 0</td>
</tr>
<tr class="row-odd"><td>LT</td>
<td>1</td>
<td>D.u = (S0 &lt; S1)</td>
</tr>
<tr class="row-even"><td>EQ</td>
<td>2</td>
<td>D.u = (S0 == S1)</td>
</tr>
<tr class="row-odd"><td>LE</td>
<td>3</td>
<td>D.u = (S0 &lt;= S1)</td>
</tr>
<tr class="row-even"><td>GT</td>
<td>4</td>
<td>D.u = (S0 &gt; S1)</td>
</tr>
<tr class="row-odd"><td>LG</td>
<td>5</td>
<td>D.u = (S0 &lt;&gt; S1)</td>
</tr>
<tr class="row-even"><td>GE</td>
<td>6</td>
<td>D.u = (S0 &gt;= S1)</td>
</tr>
<tr class="row-odd"><td>TRU</td>
<td>7</td>
<td>D.u = 1</td>
</tr>
</tbody>
</table>
<p>Table: Comparison Operations</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRC0</td>
<td><div class="first last line-block">
<div class="line">[8:0]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249</div>
<div class="line">250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
<div class="line">256 -
511</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">SDWA</div>
<div class="line">DPP</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
<div class="line">VGPR 0 - 255</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>VSRC1</td>
<td>[16:9]</td>
<td>VGPR which provides the second operand.</td>
</tr>
<tr class="row-even"><td>OP</td>
<td>[24:17]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:25]</td>
<td>Must be: 0_111110</td>
</tr>
</tbody>
</table>
<p>Table: VOPC Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>V_CMP_CLASS_F32</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>V_CMPX_CLASS_F32</td>
</tr>
<tr class="row-even"><td>18</td>
<td>V_CMP_CLASS_F64</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>V_CMPX_CLASS_F64</td>
</tr>
<tr class="row-even"><td>20</td>
<td>V_CMP_CLASS_F16</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>V_CMPX_CLASS_F16</td>
</tr>
<tr class="row-even"><td>32</td>
<td>V_CMP_F_F16</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>V_CMP_LT_F16</td>
</tr>
<tr class="row-even"><td>34</td>
<td>V_CMP_EQ_F16</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>V_CMP_LE_F16</td>
</tr>
<tr class="row-even"><td>36</td>
<td>V_CMP_GT_F16</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>V_CMP_LG_F16</td>
</tr>
<tr class="row-even"><td>38</td>
<td>V_CMP_GE_F16</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>V_CMP_O_F16</td>
</tr>
<tr class="row-even"><td>40</td>
<td>V_CMP_U_F16</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>V_CMP_NGE_F16</td>
</tr>
<tr class="row-even"><td>42</td>
<td>V_CMP_NLG_F16</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>V_CMP_NGT_F16</td>
</tr>
<tr class="row-even"><td>44</td>
<td>V_CMP_NLE_F16</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>V_CMP_NEQ_F16</td>
</tr>
<tr class="row-even"><td>46</td>
<td>V_CMP_NLT_F16</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>V_CMP_TRU_F16</td>
</tr>
<tr class="row-even"><td>48</td>
<td>V_CMPX_F_F16</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>V_CMPX_LT_F16</td>
</tr>
<tr class="row-even"><td>50</td>
<td>V_CMPX_EQ_F16</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>V_CMPX_LE_F16</td>
</tr>
<tr class="row-even"><td>52</td>
<td>V_CMPX_GT_F16</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>V_CMPX_LG_F16</td>
</tr>
<tr class="row-even"><td>54</td>
<td>V_CMPX_GE_F16</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>V_CMPX_O_F16</td>
</tr>
<tr class="row-even"><td>56</td>
<td>V_CMPX_U_F16</td>
</tr>
<tr class="row-odd"><td>57</td>
<td>V_CMPX_NGE_F16</td>
</tr>
<tr class="row-even"><td>58</td>
<td>V_CMPX_NLG_F16</td>
</tr>
<tr class="row-odd"><td>59</td>
<td>V_CMPX_NGT_F16</td>
</tr>
<tr class="row-even"><td>60</td>
<td>V_CMPX_NLE_F16</td>
</tr>
<tr class="row-odd"><td>61</td>
<td>V_CMPX_NEQ_F16</td>
</tr>
<tr class="row-even"><td>62</td>
<td>V_CMPX_NLT_F16</td>
</tr>
<tr class="row-odd"><td>63</td>
<td>V_CMPX_TRU_F16</td>
</tr>
<tr class="row-even"><td>64</td>
<td>V_CMP_F_F32</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>V_CMP_LT_F32</td>
</tr>
<tr class="row-even"><td>66</td>
<td>V_CMP_EQ_F32</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>V_CMP_LE_F32</td>
</tr>
<tr class="row-even"><td>68</td>
<td>V_CMP_GT_F32</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>V_CMP_LG_F32</td>
</tr>
<tr class="row-even"><td>70</td>
<td>V_CMP_GE_F32</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>V_CMP_O_F32</td>
</tr>
<tr class="row-even"><td>72</td>
<td>V_CMP_U_F32</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>V_CMP_NGE_F32</td>
</tr>
<tr class="row-even"><td>74</td>
<td>V_CMP_NLG_F32</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>V_CMP_NGT_F32</td>
</tr>
<tr class="row-even"><td>76</td>
<td>V_CMP_NLE_F32</td>
</tr>
<tr class="row-odd"><td>77</td>
<td>V_CMP_NEQ_F32</td>
</tr>
<tr class="row-even"><td>78</td>
<td>V_CMP_NLT_F32</td>
</tr>
<tr class="row-odd"><td>79</td>
<td>V_CMP_TRU_F32</td>
</tr>
<tr class="row-even"><td>80</td>
<td>V_CMPX_F_F32</td>
</tr>
<tr class="row-odd"><td>81</td>
<td>V_CMPX_LT_F32</td>
</tr>
<tr class="row-even"><td>82</td>
<td>V_CMPX_EQ_F32</td>
</tr>
<tr class="row-odd"><td>83</td>
<td>V_CMPX_LE_F32</td>
</tr>
<tr class="row-even"><td>84</td>
<td>V_CMPX_GT_F32</td>
</tr>
<tr class="row-odd"><td>85</td>
<td>V_CMPX_LG_F32</td>
</tr>
<tr class="row-even"><td>86</td>
<td>V_CMPX_GE_F32</td>
</tr>
<tr class="row-odd"><td>87</td>
<td>V_CMPX_O_F32</td>
</tr>
<tr class="row-even"><td>88</td>
<td>V_CMPX_U_F32</td>
</tr>
<tr class="row-odd"><td>89</td>
<td>V_CMPX_NGE_F32</td>
</tr>
<tr class="row-even"><td>90</td>
<td>V_CMPX_NLG_F32</td>
</tr>
<tr class="row-odd"><td>91</td>
<td>V_CMPX_NGT_F32</td>
</tr>
<tr class="row-even"><td>92</td>
<td>V_CMPX_NLE_F32</td>
</tr>
<tr class="row-odd"><td>93</td>
<td>V_CMPX_NEQ_F32</td>
</tr>
<tr class="row-even"><td>94</td>
<td>V_CMPX_NLT_F32</td>
</tr>
<tr class="row-odd"><td>95</td>
<td>V_CMPX_TRU_F32</td>
</tr>
<tr class="row-even"><td>96</td>
<td>V_CMP_F_F64</td>
</tr>
<tr class="row-odd"><td>97</td>
<td>V_CMP_LT_F64</td>
</tr>
<tr class="row-even"><td>98</td>
<td>V_CMP_EQ_F64</td>
</tr>
<tr class="row-odd"><td>99</td>
<td>V_CMP_LE_F64</td>
</tr>
<tr class="row-even"><td>100</td>
<td>V_CMP_GT_F64</td>
</tr>
<tr class="row-odd"><td>101</td>
<td>V_CMP_LG_F64</td>
</tr>
<tr class="row-even"><td>102</td>
<td>V_CMP_GE_F64</td>
</tr>
<tr class="row-odd"><td>103</td>
<td>V_CMP_O_F64</td>
</tr>
<tr class="row-even"><td>104</td>
<td>V_CMP_U_F64</td>
</tr>
<tr class="row-odd"><td>105</td>
<td>V_CMP_NGE_F64</td>
</tr>
<tr class="row-even"><td>106</td>
<td>V_CMP_NLG_F64</td>
</tr>
<tr class="row-odd"><td>107</td>
<td>V_CMP_NGT_F64</td>
</tr>
<tr class="row-even"><td>108</td>
<td>V_CMP_NLE_F64</td>
</tr>
<tr class="row-odd"><td>109</td>
<td>V_CMP_NEQ_F64</td>
</tr>
<tr class="row-even"><td>110</td>
<td>V_CMP_NLT_F64</td>
</tr>
<tr class="row-odd"><td>111</td>
<td>V_CMP_TRU_F64</td>
</tr>
<tr class="row-even"><td>112</td>
<td>V_CMPX_F_F64</td>
</tr>
<tr class="row-odd"><td>113</td>
<td>V_CMPX_LT_F64</td>
</tr>
<tr class="row-even"><td>114</td>
<td>V_CMPX_EQ_F64</td>
</tr>
<tr class="row-odd"><td>115</td>
<td>V_CMPX_LE_F64</td>
</tr>
<tr class="row-even"><td>116</td>
<td>V_CMPX_GT_F64</td>
</tr>
<tr class="row-odd"><td>117</td>
<td>V_CMPX_LG_F64</td>
</tr>
<tr class="row-even"><td>118</td>
<td>V_CMPX_GE_F64</td>
</tr>
<tr class="row-odd"><td>119</td>
<td>V_CMPX_O_F64</td>
</tr>
<tr class="row-even"><td>120</td>
<td>V_CMPX_U_F64</td>
</tr>
<tr class="row-odd"><td>121</td>
<td>V_CMPX_NGE_F64</td>
</tr>
<tr class="row-even"><td>122</td>
<td>V_CMPX_NLG_F64</td>
</tr>
<tr class="row-odd"><td>123</td>
<td>V_CMPX_NGT_F64</td>
</tr>
<tr class="row-even"><td>124</td>
<td>V_CMPX_NLE_F64</td>
</tr>
<tr class="row-odd"><td>125</td>
<td>V_CMPX_NEQ_F64</td>
</tr>
<tr class="row-even"><td>126</td>
<td>V_CMPX_NLT_F64</td>
</tr>
<tr class="row-odd"><td>127</td>
<td>V_CMPX_TRU_F64</td>
</tr>
<tr class="row-even"><td>160</td>
<td>V_CMP_F_I16</td>
</tr>
<tr class="row-odd"><td>161</td>
<td>V_CMP_LT_I16</td>
</tr>
<tr class="row-even"><td>162</td>
<td>V_CMP_EQ_I16</td>
</tr>
<tr class="row-odd"><td>163</td>
<td>V_CMP_LE_I16</td>
</tr>
<tr class="row-even"><td>164</td>
<td>V_CMP_GT_I16</td>
</tr>
<tr class="row-odd"><td>165</td>
<td>V_CMP_NE_I16</td>
</tr>
<tr class="row-even"><td>166</td>
<td>V_CMP_GE_I16</td>
</tr>
<tr class="row-odd"><td>167</td>
<td>V_CMP_T_I16</td>
</tr>
<tr class="row-even"><td>168</td>
<td>V_CMP_F_U16</td>
</tr>
<tr class="row-odd"><td>169</td>
<td>V_CMP_LT_U16</td>
</tr>
<tr class="row-even"><td>170</td>
<td>V_CMP_EQ_U16</td>
</tr>
<tr class="row-odd"><td>171</td>
<td>V_CMP_LE_U16</td>
</tr>
<tr class="row-even"><td>172</td>
<td>V_CMP_GT_U16</td>
</tr>
<tr class="row-odd"><td>173</td>
<td>V_CMP_NE_U16</td>
</tr>
<tr class="row-even"><td>174</td>
<td>V_CMP_GE_U16</td>
</tr>
<tr class="row-odd"><td>175</td>
<td>V_CMP_T_U16</td>
</tr>
<tr class="row-even"><td>176</td>
<td>V_CMPX_F_I16</td>
</tr>
<tr class="row-odd"><td>177</td>
<td>V_CMPX_LT_I16</td>
</tr>
<tr class="row-even"><td>178</td>
<td>V_CMPX_EQ_I16</td>
</tr>
<tr class="row-odd"><td>179</td>
<td>V_CMPX_LE_I16</td>
</tr>
<tr class="row-even"><td>180</td>
<td>V_CMPX_GT_I16</td>
</tr>
<tr class="row-odd"><td>181</td>
<td>V_CMPX_NE_I16</td>
</tr>
<tr class="row-even"><td>182</td>
<td>V_CMPX_GE_I16</td>
</tr>
<tr class="row-odd"><td>183</td>
<td>V_CMPX_T_I16</td>
</tr>
<tr class="row-even"><td>184</td>
<td>V_CMPX_F_U16</td>
</tr>
<tr class="row-odd"><td>185</td>
<td>V_CMPX_LT_U16</td>
</tr>
<tr class="row-even"><td>186</td>
<td>V_CMPX_EQ_U16</td>
</tr>
<tr class="row-odd"><td>187</td>
<td>V_CMPX_LE_U16</td>
</tr>
<tr class="row-even"><td>188</td>
<td>V_CMPX_GT_U16</td>
</tr>
<tr class="row-odd"><td>189</td>
<td>V_CMPX_NE_U16</td>
</tr>
<tr class="row-even"><td>190</td>
<td>V_CMPX_GE_U16</td>
</tr>
<tr class="row-odd"><td>191</td>
<td>V_CMPX_T_U16</td>
</tr>
<tr class="row-even"><td>192</td>
<td>V_CMP_F_I32</td>
</tr>
<tr class="row-odd"><td>193</td>
<td>V_CMP_LT_I32</td>
</tr>
<tr class="row-even"><td>194</td>
<td>V_CMP_EQ_I32</td>
</tr>
<tr class="row-odd"><td>195</td>
<td>V_CMP_LE_I32</td>
</tr>
<tr class="row-even"><td>196</td>
<td>V_CMP_GT_I32</td>
</tr>
<tr class="row-odd"><td>197</td>
<td>V_CMP_NE_I32</td>
</tr>
<tr class="row-even"><td>198</td>
<td>V_CMP_GE_I32</td>
</tr>
<tr class="row-odd"><td>199</td>
<td>V_CMP_T_I32</td>
</tr>
<tr class="row-even"><td>200</td>
<td>V_CMP_F_U32</td>
</tr>
<tr class="row-odd"><td>201</td>
<td>V_CMP_LT_U32</td>
</tr>
<tr class="row-even"><td>202</td>
<td>V_CMP_EQ_U32</td>
</tr>
<tr class="row-odd"><td>203</td>
<td>V_CMP_LE_U32</td>
</tr>
<tr class="row-even"><td>204</td>
<td>V_CMP_GT_U32</td>
</tr>
<tr class="row-odd"><td>205</td>
<td>V_CMP_NE_U32</td>
</tr>
<tr class="row-even"><td>206</td>
<td>V_CMP_GE_U32</td>
</tr>
<tr class="row-odd"><td>207</td>
<td>V_CMP_T_U32</td>
</tr>
<tr class="row-even"><td>208</td>
<td>V_CMPX_F_I32</td>
</tr>
<tr class="row-odd"><td>209</td>
<td>V_CMPX_LT_I32</td>
</tr>
<tr class="row-even"><td>210</td>
<td>V_CMPX_EQ_I32</td>
</tr>
<tr class="row-odd"><td>211</td>
<td>V_CMPX_LE_I32</td>
</tr>
<tr class="row-even"><td>212</td>
<td>V_CMPX_GT_I32</td>
</tr>
<tr class="row-odd"><td>213</td>
<td>V_CMPX_NE_I32</td>
</tr>
<tr class="row-even"><td>214</td>
<td>V_CMPX_GE_I32</td>
</tr>
<tr class="row-odd"><td>215</td>
<td>V_CMPX_T_I32</td>
</tr>
<tr class="row-even"><td>216</td>
<td>V_CMPX_F_U32</td>
</tr>
<tr class="row-odd"><td>217</td>
<td>V_CMPX_LT_U32</td>
</tr>
<tr class="row-even"><td>218</td>
<td>V_CMPX_EQ_U32</td>
</tr>
<tr class="row-odd"><td>219</td>
<td>V_CMPX_LE_U32</td>
</tr>
<tr class="row-even"><td>220</td>
<td>V_CMPX_GT_U32</td>
</tr>
<tr class="row-odd"><td>221</td>
<td>V_CMPX_NE_U32</td>
</tr>
<tr class="row-even"><td>222</td>
<td>V_CMPX_GE_U32</td>
</tr>
<tr class="row-odd"><td>223</td>
<td>V_CMPX_T_U32</td>
</tr>
<tr class="row-even"><td>224</td>
<td>V_CMP_F_I64</td>
</tr>
<tr class="row-odd"><td>225</td>
<td>V_CMP_LT_I64</td>
</tr>
<tr class="row-even"><td>226</td>
<td>V_CMP_EQ_I64</td>
</tr>
<tr class="row-odd"><td>227</td>
<td>V_CMP_LE_I64</td>
</tr>
<tr class="row-even"><td>228</td>
<td>V_CMP_GT_I64</td>
</tr>
<tr class="row-odd"><td>229</td>
<td>V_CMP_NE_I64</td>
</tr>
<tr class="row-even"><td>230</td>
<td>V_CMP_GE_I64</td>
</tr>
<tr class="row-odd"><td>231</td>
<td>V_CMP_T_I64</td>
</tr>
<tr class="row-even"><td>232</td>
<td>V_CMP_F_U64</td>
</tr>
<tr class="row-odd"><td>233</td>
<td>V_CMP_LT_U64</td>
</tr>
<tr class="row-even"><td>234</td>
<td>V_CMP_EQ_U64</td>
</tr>
<tr class="row-odd"><td>235</td>
<td>V_CMP_LE_U64</td>
</tr>
<tr class="row-even"><td>236</td>
<td>V_CMP_GT_U64</td>
</tr>
<tr class="row-odd"><td>237</td>
<td>V_CMP_NE_U64</td>
</tr>
<tr class="row-even"><td>238</td>
<td>V_CMP_GE_U64</td>
</tr>
<tr class="row-odd"><td>239</td>
<td>V_CMP_T_U64</td>
</tr>
<tr class="row-even"><td>240</td>
<td>V_CMPX_F_I64</td>
</tr>
<tr class="row-odd"><td>241</td>
<td>V_CMPX_LT_I64</td>
</tr>
<tr class="row-even"><td>242</td>
<td>V_CMPX_EQ_I64</td>
</tr>
<tr class="row-odd"><td>243</td>
<td>V_CMPX_LE_I64</td>
</tr>
<tr class="row-even"><td>244</td>
<td>V_CMPX_GT_I64</td>
</tr>
<tr class="row-odd"><td>245</td>
<td>V_CMPX_NE_I64</td>
</tr>
<tr class="row-even"><td>246</td>
<td>V_CMPX_GE_I64</td>
</tr>
<tr class="row-odd"><td>247</td>
<td>V_CMPX_T_I64</td>
</tr>
<tr class="row-even"><td>248</td>
<td>V_CMPX_F_U64</td>
</tr>
<tr class="row-odd"><td>249</td>
<td>V_CMPX_LT_U64</td>
</tr>
<tr class="row-even"><td>250</td>
<td>V_CMPX_EQ_U64</td>
</tr>
<tr class="row-odd"><td>251</td>
<td>V_CMPX_LE_U64</td>
</tr>
<tr class="row-even"><td>252</td>
<td>V_CMPX_GT_U64</td>
</tr>
<tr class="row-odd"><td>253</td>
<td>V_CMPX_NE_U64</td>
</tr>
<tr class="row-even"><td>254</td>
<td>V_CMPX_GE_U64</td>
</tr>
<tr class="row-odd"><td>255</td>
<td>V_CMPX_T_U64</td>
</tr>
</tbody>
</table>
<p>Table: VOPC Opcodes</p>
</div>
<div class="section" id="vop3a">
<h4>VOP3A<a class="headerlink" href="#vop3a" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode vop3a" src="../_images/microcode_vop3a.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>VOP3A</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Vector ALU format with three operands</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VDST</td>
<td>[7:0]</td>
<td>Destination VGPR</td>
</tr>
<tr class="row-odd"><td>ABS</td>
<td>[10:8]</td>
<td>Absolute value of input. [8] = src0, [9] = src1,
[10] = src2</td>
</tr>
<tr class="row-even"><td>OPSEL</td>
<td>[14:11]</td>
<td>Operand select for 16-bit data. 0 = select low
half, 1 = select high half. [11] = src0, [12] =
src1, [13] = src2, [14] = dest.</td>
</tr>
<tr class="row-odd"><td>CLMP</td>
<td>[15]</td>
<td>Clamp output</td>
</tr>
<tr class="row-even"><td>OP</td>
<td>[25:16]</td>
<td>Opcode. See next table.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 110100</td>
</tr>
<tr class="row-even"><td>SRC0</td>
<td><div class="first last line-block">
<div class="line">[40:3
2]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249</div>
<div class="line">250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
<div class="line">256 -
511</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">SDWA</div>
<div class="line">DPP</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
<div class="line">VGPR 0 - 255</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>SRC1</td>
<td>[49:41]</td>
<td>Second input operand. Same options as SRC0.</td>
</tr>
<tr class="row-even"><td>SRC2</td>
<td>[58:50]</td>
<td>Third input operand. Same options as SRC0.</td>
</tr>
<tr class="row-odd"><td>OMOD</td>
<td>[60:59]</td>
<td>Output Modifier: 0=none, 1=*2, 2=*4, 3=div-2</td>
</tr>
<tr class="row-even"><td>NEG</td>
<td>[63:61]</td>
<td>Negate input. [61] = src0, [62] = src1, [63] =
src2</td>
</tr>
</tbody>
</table>
<p>Table: VOP3A Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>448</td>
<td>V_MAD_LEGACY_F32</td>
</tr>
<tr class="row-odd"><td>449</td>
<td>V_MAD_F32</td>
</tr>
<tr class="row-even"><td>450</td>
<td>V_MAD_I32_I24</td>
</tr>
<tr class="row-odd"><td>451</td>
<td>V_MAD_U32_U24</td>
</tr>
<tr class="row-even"><td>452</td>
<td>V_CUBEID_F32</td>
</tr>
<tr class="row-odd"><td>453</td>
<td>V_CUBESC_F32</td>
</tr>
<tr class="row-even"><td>454</td>
<td>V_CUBETC_F32</td>
</tr>
<tr class="row-odd"><td>455</td>
<td>V_CUBEMA_F32</td>
</tr>
<tr class="row-even"><td>456</td>
<td>V_BFE_U32</td>
</tr>
<tr class="row-odd"><td>457</td>
<td>V_BFE_I32</td>
</tr>
<tr class="row-even"><td>458</td>
<td>V_BFI_B32</td>
</tr>
<tr class="row-odd"><td>459</td>
<td>V_FMA_F32</td>
</tr>
<tr class="row-even"><td>460</td>
<td>V_FMA_F64</td>
</tr>
<tr class="row-odd"><td>461</td>
<td>V_LERP_U8</td>
</tr>
<tr class="row-even"><td>462</td>
<td>V_ALIGNBIT_B32</td>
</tr>
<tr class="row-odd"><td>463</td>
<td>V_ALIGNBYTE_B32</td>
</tr>
<tr class="row-even"><td>464</td>
<td>V_MIN3_F32</td>
</tr>
<tr class="row-odd"><td>465</td>
<td>V_MIN3_I32</td>
</tr>
<tr class="row-even"><td>466</td>
<td>V_MIN3_U32</td>
</tr>
<tr class="row-odd"><td>467</td>
<td>V_MAX3_F32</td>
</tr>
<tr class="row-even"><td>468</td>
<td>V_MAX3_I32</td>
</tr>
<tr class="row-odd"><td>469</td>
<td>V_MAX3_U32</td>
</tr>
<tr class="row-even"><td>470</td>
<td>V_MED3_F32</td>
</tr>
<tr class="row-odd"><td>471</td>
<td>V_MED3_I32</td>
</tr>
<tr class="row-even"><td>472</td>
<td>V_MED3_U32</td>
</tr>
<tr class="row-odd"><td>473</td>
<td>V_SAD_U8</td>
</tr>
<tr class="row-even"><td>474</td>
<td>V_SAD_HI_U8</td>
</tr>
<tr class="row-odd"><td>475</td>
<td>V_SAD_U16</td>
</tr>
<tr class="row-even"><td>476</td>
<td>V_SAD_U32</td>
</tr>
<tr class="row-odd"><td>477</td>
<td>V_CVT_PK_U8_F32</td>
</tr>
<tr class="row-even"><td>478</td>
<td>V_DIV_FIXUP_F32</td>
</tr>
<tr class="row-odd"><td>479</td>
<td>V_DIV_FIXUP_F64</td>
</tr>
<tr class="row-even"><td>482</td>
<td>V_DIV_FMAS_F32</td>
</tr>
<tr class="row-odd"><td>483</td>
<td>V_DIV_FMAS_F64</td>
</tr>
<tr class="row-even"><td>484</td>
<td>V_MSAD_U8</td>
</tr>
<tr class="row-odd"><td>485</td>
<td>V_QSAD_PK_U16_U8</td>
</tr>
<tr class="row-even"><td>486</td>
<td>V_MQSAD_PK_U16_U8</td>
</tr>
<tr class="row-odd"><td>487</td>
<td>V_MQSAD_U32_U8</td>
</tr>
<tr class="row-even"><td>490</td>
<td>V_MAD_LEGACY_F16</td>
</tr>
<tr class="row-odd"><td>491</td>
<td>V_MAD_LEGACY_U16</td>
</tr>
<tr class="row-even"><td>492</td>
<td>V_MAD_LEGACY_I16</td>
</tr>
<tr class="row-odd"><td>493</td>
<td>V_PERM_B32</td>
</tr>
<tr class="row-even"><td>494</td>
<td>V_FMA_LEGACY_F16</td>
</tr>
<tr class="row-odd"><td>495</td>
<td>V_DIV_FIXUP_LEGACY_F16</td>
</tr>
<tr class="row-even"><td>496</td>
<td>V_CVT_PKACCUM_U8_F32</td>
</tr>
<tr class="row-odd"><td>497</td>
<td>V_MAD_U32_U16</td>
</tr>
<tr class="row-even"><td>498</td>
<td>V_MAD_I32_I16</td>
</tr>
<tr class="row-odd"><td>499</td>
<td>V_XAD_U32</td>
</tr>
<tr class="row-even"><td>500</td>
<td>V_MIN3_F16</td>
</tr>
<tr class="row-odd"><td>501</td>
<td>V_MIN3_I16</td>
</tr>
<tr class="row-even"><td>502</td>
<td>V_MIN3_U16</td>
</tr>
<tr class="row-odd"><td>503</td>
<td>V_MAX3_F16</td>
</tr>
<tr class="row-even"><td>504</td>
<td>V_MAX3_I16</td>
</tr>
<tr class="row-odd"><td>505</td>
<td>V_MAX3_U16</td>
</tr>
<tr class="row-even"><td>506</td>
<td>V_MED3_F16</td>
</tr>
<tr class="row-odd"><td>507</td>
<td>V_MED3_I16</td>
</tr>
<tr class="row-even"><td>508</td>
<td>V_MED3_U16</td>
</tr>
<tr class="row-odd"><td>509</td>
<td>V_LSHL_ADD_U32</td>
</tr>
<tr class="row-even"><td>510</td>
<td>V_ADD_LSHL_U32</td>
</tr>
<tr class="row-odd"><td>511</td>
<td>V_ADD3_U32</td>
</tr>
<tr class="row-even"><td>512</td>
<td>V_LSHL_OR_B32</td>
</tr>
<tr class="row-odd"><td>513</td>
<td>V_AND_OR_B32</td>
</tr>
<tr class="row-even"><td>514</td>
<td>V_OR3_B32</td>
</tr>
<tr class="row-odd"><td>515</td>
<td>V_MAD_F16</td>
</tr>
<tr class="row-even"><td>516</td>
<td>V_MAD_U16</td>
</tr>
<tr class="row-odd"><td>517</td>
<td>V_MAD_I16</td>
</tr>
<tr class="row-even"><td>518</td>
<td>V_FMA_F16</td>
</tr>
<tr class="row-odd"><td>519</td>
<td>V_DIV_FIXUP_F16</td>
</tr>
<tr class="row-even"><td>628</td>
<td>V_INTERP_P1LL_F16</td>
</tr>
<tr class="row-odd"><td>629</td>
<td>V_INTERP_P1LV_F16</td>
</tr>
<tr class="row-even"><td>630</td>
<td>V_INTERP_P2_LEGACY_F16</td>
</tr>
<tr class="row-odd"><td>631</td>
<td>V_INTERP_P2_F16</td>
</tr>
<tr class="row-even"><td>640</td>
<td>V_ADD_F64</td>
</tr>
<tr class="row-odd"><td>641</td>
<td>V_MUL_F64</td>
</tr>
<tr class="row-even"><td>642</td>
<td>V_MIN_F64</td>
</tr>
<tr class="row-odd"><td>643</td>
<td>V_MAX_F64</td>
</tr>
<tr class="row-even"><td>644</td>
<td>V_LDEXP_F64</td>
</tr>
<tr class="row-odd"><td>645</td>
<td>V_MUL_LO_U32</td>
</tr>
<tr class="row-even"><td>646</td>
<td>V_MUL_HI_U32</td>
</tr>
<tr class="row-odd"><td>647</td>
<td>V_MUL_HI_I32</td>
</tr>
<tr class="row-even"><td>648</td>
<td>V_LDEXP_F32</td>
</tr>
<tr class="row-odd"><td>649</td>
<td>V_READLANE_B32</td>
</tr>
<tr class="row-even"><td>650</td>
<td>V_WRITELANE_B32</td>
</tr>
<tr class="row-odd"><td>651</td>
<td>V_BCNT_U32_B32</td>
</tr>
<tr class="row-even"><td>652</td>
<td>V_MBCNT_LO_U32_B32</td>
</tr>
<tr class="row-odd"><td>653</td>
<td>V_MBCNT_HI_U32_B32</td>
</tr>
<tr class="row-even"><td>655</td>
<td>V_LSHLREV_B64</td>
</tr>
<tr class="row-odd"><td>656</td>
<td>V_LSHRREV_B64</td>
</tr>
<tr class="row-even"><td>657</td>
<td>V_ASHRREV_I64</td>
</tr>
<tr class="row-odd"><td>658</td>
<td>V_TRIG_PREOP_F64</td>
</tr>
<tr class="row-even"><td>659</td>
<td>V_BFM_B32</td>
</tr>
<tr class="row-odd"><td>660</td>
<td>V_CVT_PKNORM_I16_F32</td>
</tr>
<tr class="row-even"><td>661</td>
<td>V_CVT_PKNORM_U16_F32</td>
</tr>
<tr class="row-odd"><td>662</td>
<td>V_CVT_PKRTZ_F16_F32</td>
</tr>
<tr class="row-even"><td>663</td>
<td>V_CVT_PK_U16_U32</td>
</tr>
<tr class="row-odd"><td>664</td>
<td>V_CVT_PK_I16_I32</td>
</tr>
<tr class="row-even"><td>665</td>
<td>V_CVT_PKNORM_I16_F16</td>
</tr>
<tr class="row-odd"><td>666</td>
<td>V_CVT_PKNORM_U16_F16</td>
</tr>
<tr class="row-even"><td>668</td>
<td>V_ADD_I32</td>
</tr>
<tr class="row-odd"><td>669</td>
<td>V_SUB_I32</td>
</tr>
<tr class="row-even"><td>670</td>
<td>V_ADD_I16</td>
</tr>
<tr class="row-odd"><td>671</td>
<td>V_SUB_I16</td>
</tr>
<tr class="row-even"><td>672</td>
<td>V_PACK_B32_F16</td>
</tr>
</tbody>
</table>
<p>Table: VOP3A Opcodes</p>
</div>
<div class="section" id="vop3b">
<h4>VOP3B<a class="headerlink" href="#vop3b" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode vop3b" src="../_images/microcode_vop3b.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>VOP3B</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Vector ALU format with three operands and a scalar result.
This encoding is used only for a few opcodes.</td>
</tr>
</tbody>
</table>
<p>This encoding allows specifying a unique scalar destination, and is used
only for the opcodes listed below. All other opcodes use VOP3A.</p>
<ul>
<li><div class="first line-block">
<div class="line">V_ADD_CO_U32</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_SUB_CO_U32</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_SUBREV_CO_U32</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_ADDC_CO_U32</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_SUBB_CO_U32</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_SUBBREV_CO_U32</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_DIV_SCALE_F32</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_DIV_SCALE_F64</div>
</div>
</li>
<li><div class="first line-block">
<div class="line">V_MAD_U64_U32</div>
</div>
</li>
<li><p class="first">V_MAD_I64_I32</p>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VDST</td>
<td>[7:0]</td>
<td>Destination VGPR</td>
</tr>
<tr class="row-odd"><td>SDST</td>
<td>[14:8]</td>
<td>Scalar destination</td>
</tr>
<tr class="row-even"><td>CLMP</td>
<td>[15]</td>
<td>Clamp result</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[25:16]</td>
<td>Opcode. see next table.</td>
</tr>
<tr class="row-even"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 110100</td>
</tr>
<tr class="row-odd"><td>SRC0</td>
<td><div class="first last line-block">
<div class="line">[40:3
2]</div>
<div class="line">0 -
101</div>
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-1
23</div>
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-1
92</div>
<div class="line">193-2
08</div>
<div class="line">209-2
34</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249</div>
<div class="line">250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
<div class="line">256 -
511</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">SDWA</div>
<div class="line">DPP</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
<div class="line">VGPR 0 - 255</div>
</div>
</td>
</tr>
<tr class="row-even"><td>SRC1</td>
<td>[49:41]</td>
<td>Second input operand. Same options as SRC0.</td>
</tr>
<tr class="row-odd"><td>SRC2</td>
<td>[58:50]</td>
<td>Third input operand. Same options as SRC0.</td>
</tr>
<tr class="row-even"><td>OMOD</td>
<td>[60:59]</td>
<td>Output Modifier: 0=none, 1=*2, 2=*4, 3=div-2</td>
</tr>
<tr class="row-odd"><td>NEG</td>
<td>[63:61]</td>
<td>Negate input. [61] = src0, [62] = src1, [63] =
src2</td>
</tr>
</tbody>
</table>
<p>Table: VOP3B Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>480</td>
<td>V_DIV_SCALE_F32</td>
</tr>
<tr class="row-odd"><td>481</td>
<td>V_DIV_SCALE_F64</td>
</tr>
<tr class="row-even"><td>488</td>
<td>V_MAD_U64_U32</td>
</tr>
<tr class="row-odd"><td>489</td>
<td>V_MAD_I64_I32</td>
</tr>
</tbody>
</table>
<p>Table: VOP3B Opcodes</p>
</div>
<div class="section" id="vop3p">
<h4>VOP3P<a class="headerlink" href="#vop3p" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode vop3p" src="../_images/microcode_vop3p.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>VOP3P</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Vector ALU format taking one, two or three pairs of 16 bit
inputs and producing two 16-bit outputs (packed into 1
dword).</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="16%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VDST</td>
<td>[7:0]</td>
<td>Destination VGPR</td>
</tr>
<tr class="row-odd"><td>NEG_HI</td>
<td>[10:8]</td>
<td>Negate sources 0,1,2 of the high 16-bits.</td>
</tr>
<tr class="row-even"><td>OPSEL</td>
<td>[13:11]</td>
<td>Select low or high for low sources 0=[11],
1=[12], 2=[13].</td>
</tr>
<tr class="row-odd"><td>OPSEL_HI2</td>
<td>[14]</td>
<td>Select low or high for high sources 0=[14],
1=[60], 2=[59].</td>
</tr>
<tr class="row-even"><td>CLMP</td>
<td>[15]</td>
<td>1 = clamp result.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[22:16]</td>
<td>Opcode. see next table.</td>
</tr>
<tr class="row-even"><td>ENCODING</td>
<td>[31:24]</td>
<td>Must be: 11010011</td>
</tr>
<tr class="row-odd"><td>SRC0</td>
<td><div class="first line-block">
<div class="line">[40:32]</div>
<div class="line">0 - 101</div>
</div>
<div class="line-block">
<div class="line">102</div>
<div class="line">103</div>
<div class="line">104</div>
<div class="line">105</div>
<div class="line">106</div>
<div class="line">107</div>
<div class="line">108-123</div>
</div>
<div class="last line-block">
<div class="line">124</div>
<div class="line">125</div>
<div class="line">126</div>
<div class="line">127</div>
<div class="line">128</div>
<div class="line">129-192</div>
<div class="line">193-208</div>
<div class="line">209-234</div>
<div class="line">235</div>
<div class="line">236</div>
<div class="line">237</div>
<div class="line">238</div>
<div class="line">239</div>
<div class="line">240</div>
<div class="line">241</div>
<div class="line">242</div>
<div class="line">243</div>
<div class="line">244</div>
<div class="line">245</div>
<div class="line">246</div>
<div class="line">247</div>
<div class="line">248</div>
<div class="line">249</div>
<div class="line">250</div>
<div class="line">251</div>
<div class="line">252</div>
<div class="line">253</div>
<div class="line">254</div>
<div class="line">255</div>
<div class="line">256-511</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Source 0. First operand for the instruction.</div>
<div class="line">SGPR0 to SGPR101: Scalar general-purpose
registers.</div>
<div class="line">FLAT_SCRATCH_LO.</div>
<div class="line">FLAT_SCRATCH_HI.</div>
<div class="line">XNACK_MASK_LO.</div>
<div class="line">XNACK_MASK_HI.</div>
<div class="line">VCC_LO: vcc[31:0].</div>
<div class="line">VCC_HI: vcc[63:32].</div>
<div class="line">TTMP0 - TTMP15: Trap handler temporary
register.</div>
<div class="line">M0. Memory register 0.</div>
<div class="line">Reserved</div>
<div class="line">EXEC_LO: exec[31:0].</div>
<div class="line">EXEC_HI: exec[63:32].</div>
<div class="line">0.</div>
<div class="line">Signed integer 1 to 64.</div>
<div class="line">Signed integer -1 to -16.</div>
<div class="line">Reserved.</div>
<div class="line">SHARED_BASE (Memory Aperture definition).</div>
<div class="line">SHARED_LIMIT (Memory Aperture definition).</div>
<div class="line">PRIVATE_BASE (Memory Aperture definition).</div>
<div class="line">PRIVATE_LIMIT (Memory Aperture definition).</div>
<div class="line">POPS_EXITING_WAVE_ID .</div>
<div class="line">0.5.</div>
<div class="line">-0.5.</div>
<div class="line">1.0.</div>
<div class="line">-1.0.</div>
<div class="line">2.0.</div>
<div class="line">-2.0.</div>
<div class="line">4.0.</div>
<div class="line">-4.0.</div>
<div class="line">1/(2*PI).</div>
<div class="line">SDWA</div>
<div class="line">DPP</div>
<div class="line">VCCZ.</div>
<div class="line">EXECZ.</div>
<div class="line">SCC.</div>
<div class="line">Reserved.</div>
<div class="line">Literal constant.</div>
<div class="line">VGPR 0 - 255</div>
</div>
</td>
</tr>
<tr class="row-even"><td>SRC1</td>
<td>[49:41]</td>
<td>Second input operand. Same options as SRC0.</td>
</tr>
<tr class="row-odd"><td>SRC2</td>
<td>[58:50]</td>
<td>Third input operand. Same options as SRC0.</td>
</tr>
<tr class="row-even"><td>OPSEL_HI</td>
<td>[60:59]</td>
<td>See OP_SEL_HI2.</td>
</tr>
<tr class="row-odd"><td>NEG</td>
<td>[63:61]</td>
<td>Negate input for low 16-bits of sources. [61] =
src0, [62] = src1, [63] = src2</td>
</tr>
</tbody>
</table>
<p>Table: VOP3P Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>V_PK_MAD_I16</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>V_PK_MUL_LO_U16</td>
</tr>
<tr class="row-even"><td>2</td>
<td>V_PK_ADD_I16</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>V_PK_SUB_I16</td>
</tr>
<tr class="row-even"><td>4</td>
<td>V_PK_LSHLREV_B16</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>V_PK_LSHRREV_B16</td>
</tr>
<tr class="row-even"><td>6</td>
<td>V_PK_ASHRREV_I16</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>V_PK_MAX_I16</td>
</tr>
<tr class="row-even"><td>8</td>
<td>V_PK_MIN_I16</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>V_PK_MAD_U16</td>
</tr>
<tr class="row-even"><td>10</td>
<td>V_PK_ADD_U16</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>V_PK_SUB_U16</td>
</tr>
<tr class="row-even"><td>12</td>
<td>V_PK_MAX_U16</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>V_PK_MIN_U16</td>
</tr>
<tr class="row-even"><td>14</td>
<td>V_PK_FMA_F16</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>V_PK_ADD_F16</td>
</tr>
<tr class="row-even"><td>16</td>
<td>V_PK_MUL_F16</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>V_PK_MIN_F16</td>
</tr>
<tr class="row-even"><td>18</td>
<td>V_PK_MAX_F16</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>V_MAD_MIX_F32</td>
</tr>
<tr class="row-even"><td>33</td>
<td>V_MAD_MIXLO_F16</td>
</tr>
<tr class="row-odd"><td>34</td>
<td>V_MAD_MIXHI_F16</td>
</tr>
</tbody>
</table>
<p>Table: VOP3P Opcodes</p>
</div>
<div class="section" id="id10">
<h4>SDWA<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode sdwa" src="../_images/microcode_sdwa.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SDWA</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Sub-Dword Addressing. This is a second dword which can follow
VOP1 or VOP2 instructions (in place of a literal constant) to
control selection of sub-dword (16-bit) operands. Use of SDWA
is indicated by assigning the SRC0 field to SDWA, and then
the actual VGPR used as source-zero is determined in SDWA
instruction word.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRC0</td>
<td>[39:32]</td>
<td>Real SRC0 operand (VGPR).</td>
</tr>
<tr class="row-odd"><td>DST_SEL</td>
<td>[42:40]</td>
<td><div class="first last line-block">
<div class="line">Select the data destination:</div>
<div class="line">0 = data[7:0]</div>
<div class="line">1 = data[15:8]</div>
<div class="line">2 = data[23:16]</div>
<div class="line">3 = data[31:24]</div>
<div class="line">4 = data[15:0]</div>
<div class="line">5 = data[31:16]</div>
<div class="line">6 = data[31:0]</div>
<div class="line">7 = reserved</div>
</div>
</td>
</tr>
<tr class="row-even"><td>DST_U</td>
<td>[44:43]</td>
<td><div class="first last line-block">
<div class="line">Destination format: what do with the bits in
the VGPR that are not selected by DST_SEL:</div>
<div class="line">0 = pad with zeros + 1 = sign extend upper /
zero lower</div>
<div class="line">2 = preserve (don’t modify)</div>
<div class="line">3 = reserved</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>CLMP</td>
<td>[45]</td>
<td>1 = clamp result</td>
</tr>
<tr class="row-even"><td>OMOD</td>
<td>[47:46]</td>
<td>Output modifiers (see VOP3). [46] = low half,
[47] = high half</td>
</tr>
<tr class="row-odd"><td>SRC0_SEL</td>
<td>[50:48]</td>
<td>Source 0 select. Same options as DST_SEL.</td>
</tr>
<tr class="row-even"><td>SRC0_SEXT</td>
<td>[51]</td>
<td>Sign extend modifier for source 0.</td>
</tr>
<tr class="row-odd"><td>SRC0_NEG</td>
<td>[52]</td>
<td>1 = negate source 0.</td>
</tr>
<tr class="row-even"><td>SRC0_ABS</td>
<td>[53]</td>
<td>1 = Absolute value of source 0.</td>
</tr>
<tr class="row-odd"><td>S0</td>
<td>[55]</td>
<td>0 = source 0 is VGPR, 1 = is SGPR.</td>
</tr>
<tr class="row-even"><td>SRC1_SEL</td>
<td>[58:56]</td>
<td>Same options as SRC0_SEL.</td>
</tr>
<tr class="row-odd"><td>SRC1_SEXT</td>
<td>[59]</td>
<td>Sign extend modifier for source 1.</td>
</tr>
<tr class="row-even"><td>SRC1_NEG</td>
<td>[60]</td>
<td>1 = negate source 1.</td>
</tr>
<tr class="row-odd"><td>SRC1_ABS</td>
<td>[61]</td>
<td>1 = Absolute value of source 1.</td>
</tr>
<tr class="row-even"><td>S1</td>
<td>[63]</td>
<td>0 = source 1 is VGPR, 1 = is SGPR.</td>
</tr>
</tbody>
</table>
<p>Table: SDWA Fields</p>
</div>
<div class="section" id="sdwab">
<h4>SDWAB<a class="headerlink" href="#sdwab" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode sdwab" src="../_images/microcode_sdwab.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>SDWAB</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Sub-Dword Addressing. This is a second dword which can follow
VOPC instructions (in place of a literal constant) to control
selection of sub-dword (16-bit) operands. Use of SDWA is
indicated by assigning the SRC0 field to SDWA, and then the
actual VGPR used as source-zero is determined in SDWA
instruction word. This version has a scalar destination.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRC0</td>
<td>[39:32]</td>
<td>Real SRC0 operand (VGPR).</td>
</tr>
<tr class="row-odd"><td>SDST</td>
<td>[46:40]</td>
<td>Scalar GPR destination.</td>
</tr>
<tr class="row-even"><td>SD</td>
<td>[47]</td>
<td>Scalar destination type: 0 = VCC, 1 = normal
SGPR.</td>
</tr>
<tr class="row-odd"><td>SRC0_SEL</td>
<td>[50:48]</td>
<td>Source 0 select. Same options as DST_SEL.</td>
</tr>
<tr class="row-even"><td>SRC0_SEXT</td>
<td>[51]</td>
<td>Sign extend modifier for source 0.</td>
</tr>
<tr class="row-odd"><td>SRC0_NEG</td>
<td>[52]</td>
<td>1 = negate source 0.</td>
</tr>
<tr class="row-even"><td>SRC0_ABS</td>
<td>[53]</td>
<td>1 = Absolute value of source 0.</td>
</tr>
<tr class="row-odd"><td>S0</td>
<td>[55]</td>
<td>0 = source 0 is VGPR, 1 = is SGPR.</td>
</tr>
<tr class="row-even"><td>SRC1_SEL</td>
<td>[58:56]</td>
<td>Same options as SRC0_SEL.</td>
</tr>
<tr class="row-odd"><td>SRC1_SEXT</td>
<td>[59]</td>
<td>Sign extend modifier for source 1.</td>
</tr>
<tr class="row-even"><td>SRC1_NEG</td>
<td>[60]</td>
<td>1 = negate source 1.</td>
</tr>
<tr class="row-odd"><td>SRC1_ABS</td>
<td>[61]</td>
<td>1 = Absolute value of source 1.</td>
</tr>
<tr class="row-even"><td>S1</td>
<td>[63]</td>
<td>0 = source 1 is VGPR, 1 = is SGPR.</td>
</tr>
</tbody>
</table>
<p>Table: SDWAB Fields</p>
</div>
<div class="section" id="id11">
<h4>DPP<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode dpp16" src="../_images/microcode_dpp16.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>DPP</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Data Parallel Primitives. This is a second dword which can
follow VOP1, VOP2 or VOPC instructions (in place of a literal
constant) to control selection of data from other lanes.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRC0</td>
<td>[39:32]</td>
<td>Real SRC0 operand (VGPR).</td>
</tr>
<tr class="row-odd"><td>DPP_CTRL</td>
<td>[48:40]</td>
<td>See next table: “DPP_CTRL Enumeration”</td>
</tr>
<tr class="row-even"><td>BC</td>
<td>[51]</td>
<td>Bounds Control: 0 = do not write when source is
out of range, 1 = write.</td>
</tr>
<tr class="row-odd"><td>SRC0_NEG</td>
<td>[52]</td>
<td>1 = negate source 0.</td>
</tr>
<tr class="row-even"><td>SRC0_ABS</td>
<td>[53]</td>
<td>1 = Absolute value of source 0.</td>
</tr>
<tr class="row-odd"><td>SRC1_NEG</td>
<td>[54]</td>
<td>1 = negate source 1.</td>
</tr>
<tr class="row-even"><td>SRC1_ABS</td>
<td>[55]</td>
<td>1 = Absolute value of source 1.</td>
</tr>
<tr class="row-odd"><td>BANK_MASK</td>
<td>[59:56]</td>
<td><div class="first last line-block">
<div class="line">Bank Mask Applies to the VGPR destination write
only, does not impact the thread mask when
fetching source VGPR data.</div>
<div class="line">27==0: lanes[12:15, 28:31, 44:47, 60:63] are
disabled</div>
<div class="line">26==0: lanes[8:11, 24:27, 40:43, 56:59] are
disabled</div>
<div class="line">25==0: lanes[4:7, 20:23, 36:39, 52:55] are
disabled</div>
<div class="line">24==0: lanes[0:3, 16:19, 32:35, 48:51] are
disabled</div>
<div class="line">Notice: the term “bank” here is not the same as
we used for the VGPR bank.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>ROW_MASK</td>
<td>[63:60]</td>
<td><div class="first last line-block">
<div class="line">Row Mask Applies to the VGPR destination write
only, does not impact the thread mask when
fetching source VGPR data.</div>
<div class="line">31==0: lanes[63:48] are disabled (wave 64 only)</div>
<div class="line">30==0: lanes[47:32] are disabled (wave 64 only)</div>
<div class="line">29==0: lanes[31:16] are disabled</div>
<div class="line">28==0: lanes[15:0] are disabled</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Table: DPP Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">DPP_Cntl
Enumeration</th>
<th class="head">Hex Value</th>
<th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>DPP_QUAD_PERM*</td>
<td>000-0FF</td>
<td>pix[n].srca =
pix[(n&amp;0x3c)+
dpp_cntl[n%4*2+1
: n%4*2]].srca</td>
<td>Full permute of
four threads.</td>
</tr>
<tr class="row-odd"><td>DPP_UNUSED</td>
<td>100</td>
<td>Undefined</td>
<td>Reserved.</td>
</tr>
<tr class="row-even"><td>DPP_ROW_SL*</td>
<td>101-10F</td>
<td>if n&amp;0xf) &lt;
(16-cntl[3:0]n&amp;0xf
)
&lt; (16-cntl[3:0]
pix[n].srca =
pix[n+
cntl[3:0]].srca
else use
bound_cntl</td>
<td>Row shift left by
1-15 threads.</td>
</tr>
<tr class="row-odd"><td>DPP_ROW_SR*</td>
<td>111-11F</td>
<td>if ((n&amp;0xf) &gt;=
cntl[3:0])
pix[n].srca =
pix[n -
cntl[3:0]].srca
else use
bound_cntl</td>
<td>Row shift right by
1-15 threads.</td>
</tr>
<tr class="row-even"><td>DPP_ROW_RR*</td>
<td>121-12F</td>
<td>if ((n&amp;0xf) &gt;=
cnt[3:0])
pix[n].srca =
pix[n -
cntl[3:0]].srca
else pix[n].srca =
pix[n + 16 -
cntl[3:0]].srca</td>
<td>Row rotate right
by 1-15 threads.</td>
</tr>
<tr class="row-odd"><td>DPP_WF_SL1*</td>
<td>130</td>
<td>if (n&lt;63)
pix[n].srca =
pix[n+1].srca else
use bound_cntl</td>
<td>Wavefront left
shift by 1 thread.</td>
</tr>
<tr class="row-even"><td>DPP_WF_RL1*</td>
<td>134</td>
<td>if (n&lt;63)
pix[n].srca =
pix[n+1].srca else
pix[n].srca =
pix[0].srca</td>
<td>Wavefront left
rotate by 1
thread.</td>
</tr>
<tr class="row-odd"><td>DPP_WF_SR1*</td>
<td>138</td>
<td>if (n&gt;0)
pix[n].srca =
pix[n-1].srca else
use bound_cntl</td>
<td>Wavefront right
shift by 1 thread.</td>
</tr>
<tr class="row-even"><td>DPP_WF_RR1*</td>
<td>13C</td>
<td>if (n&gt;0)
pix[n].srca =
pix[n-1].srca else
pix[n].srca =
pix[63].srca</td>
<td>Wavefront right
rotate by 1
thread.</td>
</tr>
<tr class="row-odd"><td>DPP_ROW_MIRROR*</td>
<td>140</td>
<td>pix[n].srca =
pix[15-(n&amp;f)].srca</td>
<td>Mirror threads
within row.</td>
</tr>
<tr class="row-even"><td>DPP_ROW_HALF_MI
RROR*</td>
<td>141</td>
<td>pix[n].srca =
pix[7-(n&amp;7)].srca</td>
<td>Mirror threads
within row (8
threads).</td>
</tr>
<tr class="row-odd"><td>DPP_ROW_BCAST15*</td>
<td>142</td>
<td>if (n&gt;15)
pix[n].srca =
pix[n &amp; 0x30 -
1].srca</td>
<td>Broadcast 15th
thread of each row
to next row.</td>
</tr>
<tr class="row-even"><td>DPP_ROW_BCAST31*</td>
<td>143</td>
<td>if (n&gt;31)
pix[n].srca =
pix[n &amp; 0x20 -
1].srca</td>
<td>Broadcast thread
31 to rows 2 and
3.</td>
</tr>
</tbody>
</table>
<p>Table: DPP_CTRL Enumeration</p>
</div>
</div>
<div class="section" id="vector-parameter-interpolation-format">
<h3>Vector Parameter Interpolation Format<a class="headerlink" href="#vector-parameter-interpolation-format" title="Permalink to this headline">¶</a></h3>
<div class="section" id="vintrp">
<h4>VINTRP<a class="headerlink" href="#vintrp" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode vintrp" src="../_images/microcode_vintrp.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>VINTRP</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td><div class="first last line-block">
<div class="line">Vector Parameter Interpolation.</div>
<div class="line">These opcodes perform parameter interpolation using vertex
data in pixel shaders.</div>
</div>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>VSRC</td>
<td>[7:0]</td>
<td>SRC0 operand (VGPR).</td>
</tr>
<tr class="row-odd"><td>ATTR_CHAN</td>
<td>[9:8]</td>
<td>Attribute channel: 0=X, 1=Y, 2=Z, 3=W</td>
</tr>
<tr class="row-even"><td>ATTR</td>
<td>[15:10]</td>
<td>Attribute number: 0 - 32.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[17:16]</td>
<td><div class="first last line-block">
<div class="line">Opcode:</div>
<div class="line">0: v_interp_p1_f32 : VDST = P10 * VSRC + P0</div>
<div class="line">1: v_interp_p2_f32: VDST = P20 * VSRC +
VDST</div>
<div class="line">2: v_interp_mov_f32: VDST = (P0, P10 or P20
selected by VSRC[1:0])</div>
</div>
</td>
</tr>
<tr class="row-even"><td>VDST</td>
<td>[25:18]</td>
<td>Destination VGPR</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 110101</td>
</tr>
</tbody>
</table>
<p>Table: VINTRP Fields</p>
<blockquote>
<div><p><strong>Note</strong></p>
<p>VSRC must be different from VDST.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="lds-and-gds-format">
<h3>LDS and GDS format<a class="headerlink" href="#lds-and-gds-format" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ds">
<h4>DS<a class="headerlink" href="#ds" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode ds" src="../_images/microcode_ds.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>LDS and GDS</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Local and Global Data Sharing instructions</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Field Name</td>
<td>Bits</td>
<td>Format or Description</td>
</tr>
<tr class="row-even"><td>OFFSET0</td>
<td>[7:0]</td>
<td>First address offset</td>
</tr>
<tr class="row-odd"><td>OFFSET1</td>
<td>[15:8]</td>
<td>Second address offset. For some opcodes this is
concatenated with OFFSET0.</td>
</tr>
<tr class="row-even"><td>GDS</td>
<td>[16]</td>
<td>1=GDS, 0=LDS operation.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[24:17]</td>
<td>See Opcode table below.</td>
</tr>
<tr class="row-even"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 110110</td>
</tr>
<tr class="row-odd"><td>ADDR</td>
<td>[39:32]</td>
<td>VGPR which supplies the address.</td>
</tr>
<tr class="row-even"><td>DATA0</td>
<td>[47:40]</td>
<td>First data VGPR.</td>
</tr>
<tr class="row-odd"><td>DATA1</td>
<td>[55:48]</td>
<td>Second data VGPR.</td>
</tr>
<tr class="row-even"><td>VDST</td>
<td>[63:56]</td>
<td>Destination VGPR when results returned to VGPRs.</td>
</tr>
</tbody>
</table>
<p>Table: DS Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>DS_ADD_U32</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>DS_SUB_U32</td>
</tr>
<tr class="row-even"><td>2</td>
<td>DS_RSUB_U32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>DS_INC_U32</td>
</tr>
<tr class="row-even"><td>4</td>
<td>DS_DEC_U32</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>DS_MIN_I32</td>
</tr>
<tr class="row-even"><td>6</td>
<td>DS_MAX_I32</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>DS_MIN_U32</td>
</tr>
<tr class="row-even"><td>8</td>
<td>DS_MAX_U32</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>DS_AND_B32</td>
</tr>
<tr class="row-even"><td>10</td>
<td>DS_OR_B32</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>DS_XOR_B32</td>
</tr>
<tr class="row-even"><td>12</td>
<td>DS_MSKOR_B32</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>DS_WRITE_B32</td>
</tr>
<tr class="row-even"><td>14</td>
<td>DS_WRITE2_B32</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>DS_WRITE2ST64_B32</td>
</tr>
<tr class="row-even"><td>16</td>
<td>DS_CMPST_B32</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>DS_CMPST_F32</td>
</tr>
<tr class="row-even"><td>18</td>
<td>DS_MIN_F32</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>DS_MAX_F32</td>
</tr>
<tr class="row-even"><td>20</td>
<td>DS_NOP</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>DS_ADD_F32</td>
</tr>
<tr class="row-even"><td>29</td>
<td>DS_WRITE_ADDTID_B32</td>
</tr>
<tr class="row-odd"><td>30</td>
<td>DS_WRITE_B8</td>
</tr>
<tr class="row-even"><td>31</td>
<td>DS_WRITE_B16</td>
</tr>
<tr class="row-odd"><td>32</td>
<td>DS_ADD_RTN_U32</td>
</tr>
<tr class="row-even"><td>33</td>
<td>DS_SUB_RTN_U32</td>
</tr>
<tr class="row-odd"><td>34</td>
<td>DS_RSUB_RTN_U32</td>
</tr>
<tr class="row-even"><td>35</td>
<td>DS_INC_RTN_U32</td>
</tr>
<tr class="row-odd"><td>36</td>
<td>DS_DEC_RTN_U32</td>
</tr>
<tr class="row-even"><td>37</td>
<td>DS_MIN_RTN_I32</td>
</tr>
<tr class="row-odd"><td>38</td>
<td>DS_MAX_RTN_I32</td>
</tr>
<tr class="row-even"><td>39</td>
<td>DS_MIN_RTN_U32</td>
</tr>
<tr class="row-odd"><td>40</td>
<td>DS_MAX_RTN_U32</td>
</tr>
<tr class="row-even"><td>41</td>
<td>DS_AND_RTN_B32</td>
</tr>
<tr class="row-odd"><td>42</td>
<td>DS_OR_RTN_B32</td>
</tr>
<tr class="row-even"><td>43</td>
<td>DS_XOR_RTN_B32</td>
</tr>
<tr class="row-odd"><td>44</td>
<td>DS_MSKOR_RTN_B32</td>
</tr>
<tr class="row-even"><td>45</td>
<td>DS_WRXCHG_RTN_B32</td>
</tr>
<tr class="row-odd"><td>46</td>
<td>DS_WRXCHG2_RTN_B32</td>
</tr>
<tr class="row-even"><td>47</td>
<td>DS_WRXCHG2ST64_RTN_B32</td>
</tr>
<tr class="row-odd"><td>48</td>
<td>DS_CMPST_RTN_B32</td>
</tr>
<tr class="row-even"><td>49</td>
<td>DS_CMPST_RTN_F32</td>
</tr>
<tr class="row-odd"><td>50</td>
<td>DS_MIN_RTN_F32</td>
</tr>
<tr class="row-even"><td>51</td>
<td>DS_MAX_RTN_F32</td>
</tr>
<tr class="row-odd"><td>52</td>
<td>DS_WRAP_RTN_B32</td>
</tr>
<tr class="row-even"><td>53</td>
<td>DS_ADD_RTN_F32</td>
</tr>
<tr class="row-odd"><td>54</td>
<td>DS_READ_B32</td>
</tr>
<tr class="row-even"><td>55</td>
<td>DS_READ2_B32</td>
</tr>
<tr class="row-odd"><td>56</td>
<td>DS_READ2ST64_B32</td>
</tr>
<tr class="row-even"><td>57</td>
<td>DS_READ_I8</td>
</tr>
<tr class="row-odd"><td>58</td>
<td>DS_READ_U8</td>
</tr>
<tr class="row-even"><td>59</td>
<td>DS_READ_I16</td>
</tr>
<tr class="row-odd"><td>60</td>
<td>DS_READ_U16</td>
</tr>
<tr class="row-even"><td>61</td>
<td>DS_SWIZZLE_B32</td>
</tr>
<tr class="row-odd"><td>62</td>
<td>DS_PERMUTE_B32</td>
</tr>
<tr class="row-even"><td>63</td>
<td>DS_BPERMUTE_B32</td>
</tr>
<tr class="row-odd"><td>64</td>
<td>DS_ADD_U64</td>
</tr>
<tr class="row-even"><td>65</td>
<td>DS_SUB_U64</td>
</tr>
<tr class="row-odd"><td>66</td>
<td>DS_RSUB_U64</td>
</tr>
<tr class="row-even"><td>67</td>
<td>DS_INC_U64</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>DS_DEC_U64</td>
</tr>
<tr class="row-even"><td>69</td>
<td>DS_MIN_I64</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>DS_MAX_I64</td>
</tr>
<tr class="row-even"><td>71</td>
<td>DS_MIN_U64</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>DS_MAX_U64</td>
</tr>
<tr class="row-even"><td>73</td>
<td>DS_AND_B64</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>DS_OR_B64</td>
</tr>
<tr class="row-even"><td>75</td>
<td>DS_XOR_B64</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>DS_MSKOR_B64</td>
</tr>
<tr class="row-even"><td>77</td>
<td>DS_WRITE_B64</td>
</tr>
<tr class="row-odd"><td>78</td>
<td>DS_WRITE2_B64</td>
</tr>
<tr class="row-even"><td>79</td>
<td>DS_WRITE2ST64_B64</td>
</tr>
<tr class="row-odd"><td>80</td>
<td>DS_CMPST_B64</td>
</tr>
<tr class="row-even"><td>81</td>
<td>DS_CMPST_F64</td>
</tr>
<tr class="row-odd"><td>82</td>
<td>DS_MIN_F64</td>
</tr>
<tr class="row-even"><td>83</td>
<td>DS_MAX_F64</td>
</tr>
<tr class="row-odd"><td>84</td>
<td>DS_WRITE_B8_D16_HI</td>
</tr>
<tr class="row-even"><td>85</td>
<td>DS_WRITE_B16_D16_HI</td>
</tr>
<tr class="row-odd"><td>86</td>
<td>DS_READ_U8_D16</td>
</tr>
<tr class="row-even"><td>87</td>
<td>DS_READ_U8_D16_HI</td>
</tr>
<tr class="row-odd"><td>88</td>
<td>DS_READ_I8_D16</td>
</tr>
<tr class="row-even"><td>89</td>
<td>DS_READ_I8_D16_HI</td>
</tr>
<tr class="row-odd"><td>90</td>
<td>DS_READ_U16_D16</td>
</tr>
<tr class="row-even"><td>91</td>
<td>DS_READ_U16_D16_HI</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>DS_ADD_RTN_U64</td>
</tr>
<tr class="row-even"><td>97</td>
<td>DS_SUB_RTN_U64</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>DS_RSUB_RTN_U64</td>
</tr>
<tr class="row-even"><td>99</td>
<td>DS_INC_RTN_U64</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>DS_DEC_RTN_U64</td>
</tr>
<tr class="row-even"><td>101</td>
<td>DS_MIN_RTN_I64</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>DS_MAX_RTN_I64</td>
</tr>
<tr class="row-even"><td>103</td>
<td>DS_MIN_RTN_U64</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>DS_MAX_RTN_U64</td>
</tr>
<tr class="row-even"><td>105</td>
<td>DS_AND_RTN_B64</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>DS_OR_RTN_B64</td>
</tr>
<tr class="row-even"><td>107</td>
<td>DS_XOR_RTN_B64</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>DS_MSKOR_RTN_B64</td>
</tr>
<tr class="row-even"><td>109</td>
<td>DS_WRXCHG_RTN_B64</td>
</tr>
<tr class="row-odd"><td>110</td>
<td>DS_WRXCHG2_RTN_B64</td>
</tr>
<tr class="row-even"><td>111</td>
<td>DS_WRXCHG2ST64_RTN_B64</td>
</tr>
<tr class="row-odd"><td>112</td>
<td>DS_CMPST_RTN_B64</td>
</tr>
<tr class="row-even"><td>113</td>
<td>DS_CMPST_RTN_F64</td>
</tr>
<tr class="row-odd"><td>114</td>
<td>DS_MIN_RTN_F64</td>
</tr>
<tr class="row-even"><td>115</td>
<td>DS_MAX_RTN_F64</td>
</tr>
<tr class="row-odd"><td>118</td>
<td>DS_READ_B64</td>
</tr>
<tr class="row-even"><td>119</td>
<td>DS_READ2_B64</td>
</tr>
<tr class="row-odd"><td>120</td>
<td>DS_READ2ST64_B64</td>
</tr>
<tr class="row-even"><td>126</td>
<td>DS_CONDXCHG32_RTN_B64</td>
</tr>
<tr class="row-odd"><td>128</td>
<td>DS_ADD_SRC2_U32</td>
</tr>
<tr class="row-even"><td>129</td>
<td>DS_SUB_SRC2_U32</td>
</tr>
<tr class="row-odd"><td>130</td>
<td>DS_RSUB_SRC2_U32</td>
</tr>
<tr class="row-even"><td>131</td>
<td>DS_INC_SRC2_U32</td>
</tr>
<tr class="row-odd"><td>132</td>
<td>DS_DEC_SRC2_U32</td>
</tr>
<tr class="row-even"><td>133</td>
<td>DS_MIN_SRC2_I32</td>
</tr>
<tr class="row-odd"><td>134</td>
<td>DS_MAX_SRC2_I32</td>
</tr>
<tr class="row-even"><td>135</td>
<td>DS_MIN_SRC2_U32</td>
</tr>
<tr class="row-odd"><td>136</td>
<td>DS_MAX_SRC2_U32</td>
</tr>
<tr class="row-even"><td>137</td>
<td>DS_AND_SRC2_B32</td>
</tr>
<tr class="row-odd"><td>138</td>
<td>DS_OR_SRC2_B32</td>
</tr>
<tr class="row-even"><td>139</td>
<td>DS_XOR_SRC2_B32</td>
</tr>
<tr class="row-odd"><td>141</td>
<td>DS_WRITE_SRC2_B32</td>
</tr>
<tr class="row-even"><td>146</td>
<td>DS_MIN_SRC2_F32</td>
</tr>
<tr class="row-odd"><td>147</td>
<td>DS_MAX_SRC2_F32</td>
</tr>
<tr class="row-even"><td>149</td>
<td>DS_ADD_SRC2_F32</td>
</tr>
<tr class="row-odd"><td>152</td>
<td>DS_GWS_SEMA_RELEASE_ALL</td>
</tr>
<tr class="row-even"><td>153</td>
<td>DS_GWS_INIT</td>
</tr>
<tr class="row-odd"><td>154</td>
<td>DS_GWS_SEMA_V</td>
</tr>
<tr class="row-even"><td>155</td>
<td>DS_GWS_SEMA_BR</td>
</tr>
<tr class="row-odd"><td>156</td>
<td>DS_GWS_SEMA_P</td>
</tr>
<tr class="row-even"><td>157</td>
<td>DS_GWS_BARRIER</td>
</tr>
<tr class="row-odd"><td>182</td>
<td>DS_READ_ADDTID_B32</td>
</tr>
<tr class="row-even"><td>189</td>
<td>DS_CONSUME</td>
</tr>
<tr class="row-odd"><td>190</td>
<td>DS_APPEND</td>
</tr>
<tr class="row-even"><td>191</td>
<td>DS_ORDERED_COUNT</td>
</tr>
<tr class="row-odd"><td>192</td>
<td>DS_ADD_SRC2_U64</td>
</tr>
<tr class="row-even"><td>193</td>
<td>DS_SUB_SRC2_U64</td>
</tr>
<tr class="row-odd"><td>194</td>
<td>DS_RSUB_SRC2_U64</td>
</tr>
<tr class="row-even"><td>195</td>
<td>DS_INC_SRC2_U64</td>
</tr>
<tr class="row-odd"><td>196</td>
<td>DS_DEC_SRC2_U64</td>
</tr>
<tr class="row-even"><td>197</td>
<td>DS_MIN_SRC2_I64</td>
</tr>
<tr class="row-odd"><td>198</td>
<td>DS_MAX_SRC2_I64</td>
</tr>
<tr class="row-even"><td>199</td>
<td>DS_MIN_SRC2_U64</td>
</tr>
<tr class="row-odd"><td>200</td>
<td>DS_MAX_SRC2_U64</td>
</tr>
<tr class="row-even"><td>201</td>
<td>DS_AND_SRC2_B64</td>
</tr>
<tr class="row-odd"><td>202</td>
<td>DS_OR_SRC2_B64</td>
</tr>
<tr class="row-even"><td>203</td>
<td>DS_XOR_SRC2_B64</td>
</tr>
<tr class="row-odd"><td>205</td>
<td>DS_WRITE_SRC2_B64</td>
</tr>
<tr class="row-even"><td>210</td>
<td>DS_MIN_SRC2_F64</td>
</tr>
<tr class="row-odd"><td>211</td>
<td>DS_MAX_SRC2_F64</td>
</tr>
<tr class="row-even"><td>222</td>
<td>DS_WRITE_B96</td>
</tr>
<tr class="row-odd"><td>223</td>
<td>DS_WRITE_B128</td>
</tr>
<tr class="row-even"><td>254</td>
<td>DS_READ_B96</td>
</tr>
<tr class="row-odd"><td>255</td>
<td>DS_READ_B128</td>
</tr>
</tbody>
</table>
<p>Table: DS Opcodes</p>
</div>
</div>
<div class="section" id="vector-memory-buffer-formats">
<h3>Vector Memory Buffer Formats<a class="headerlink" href="#vector-memory-buffer-formats" title="Permalink to this headline">¶</a></h3>
<p>There are two memory buffer instruction formats:</p>
<dl class="docutils">
<dt>MTBUF</dt>
<dd>typed buffer access (data type is defined by the instruction)</dd>
<dt>MUBUF</dt>
<dd>untyped buffer access (data type is defined by the buffer /
resource-constant)</dd>
</dl>
<div class="section" id="mtbuf">
<h4>MTBUF<a class="headerlink" href="#mtbuf" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode mtbuf" src="GCN_ISA_Manuals/images/microcode/microcode_mtbuf.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>MTBUF</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Memory Typed-Buffer Instructions</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OFFSET</td>
<td>[11:0]</td>
<td>Address offset, unsigned byte.</td>
</tr>
<tr class="row-odd"><td>OFFEN</td>
<td>[12]</td>
<td>1 = enable offset VGPR, 0 = use zero for address
offset</td>
</tr>
<tr class="row-even"><td>IDXEN</td>
<td>[13]</td>
<td>1 = enable index VGPR, 0 = use zero for address
index</td>
</tr>
<tr class="row-odd"><td>GLC</td>
<td>[14]</td>
<td>0 = normal, 1 = globally coherent (bypass L0
cache) or for atomics, return pre-op value to
VGPR.</td>
</tr>
<tr class="row-even"><td>OP</td>
<td>[18:15]</td>
<td>Opcode. See table below.</td>
</tr>
<tr class="row-odd"><td>DFMT</td>
<td>22:19</td>
<td><div class="first last line-block">
<div class="line">Data Format of data in memory buffer:</div>
<div class="line">0 invalid</div>
<div class="line">1 8</div>
<div class="line">2 16</div>
<div class="line">3 8_8</div>
<div class="line">4 32</div>
<div class="line">5 16_16</div>
<div class="line">6 10_11_11</div>
<div class="line">8 10_10_10_2</div>
<div class="line">9 2_10_10_10</div>
<div class="line">10 8_8_8_8</div>
<div class="line">11 32_32</div>
<div class="line">12 16_16_16_16</div>
<div class="line">13 32_32_32</div>
<div class="line">14 32_32_32_32</div>
</div>
</td>
</tr>
<tr class="row-even"><td>NFMT</td>
<td>25:23</td>
<td><div class="first last line-block">
<div class="line">Numeric format of data in memory:</div>
<div class="line">0 unorm</div>
<div class="line">1 snorm</div>
<div class="line">2 uscaled</div>
<div class="line">3 sscaled</div>
<div class="line">4 uint</div>
<div class="line">5 sint</div>
<div class="line">6 reserved</div>
<div class="line">7 float</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 111010</td>
</tr>
<tr class="row-even"><td>VADDR</td>
<td>[39:32]</td>
<td>Address of VGPR to supply first component of
address (offset or index). When both index and
offset are used, index is in the first VGPR and
offset in the second.</td>
</tr>
<tr class="row-odd"><td>VDATA</td>
<td>[47:40]</td>
<td>Address of VGPR to supply first component of
write data or receive first component of
read-data.</td>
</tr>
<tr class="row-even"><td>SRSRC</td>
<td>[52:48]</td>
<td>SGPR to supply V# (resource constant) in 4 or 8
consecutive SGPRs. It is missing 2 LSB’s of
SGPR-address since must be aligned to 4.</td>
</tr>
<tr class="row-odd"><td>SLC</td>
<td>[54]</td>
<td>System level coherent: bypass L2 cache.</td>
</tr>
<tr class="row-even"><td>TFE</td>
<td>[55]</td>
<td>Partially resident texture, texture fail enable.</td>
</tr>
<tr class="row-odd"><td>SOFFSET</td>
<td>[63:56]</td>
<td>Address offset, unsigned byte.</td>
</tr>
</tbody>
</table>
<p>Table: MTBUF Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>TBUFFER_LOAD_FORMAT_X</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>TBUFFER_LOAD_FORMAT_XY</td>
</tr>
<tr class="row-even"><td>2</td>
<td>TBUFFER_LOAD_FORMAT_XYZ</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>TBUFFER_LOAD_FORMAT_XYZW</td>
</tr>
<tr class="row-even"><td>4</td>
<td>TBUFFER_STORE_FORMAT_X</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>TBUFFER_STORE_FORMAT_XY</td>
</tr>
<tr class="row-even"><td>6</td>
<td>TBUFFER_STORE_FORMAT_XYZ</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>TBUFFER_STORE_FORMAT_XYZW</td>
</tr>
<tr class="row-even"><td>8</td>
<td>TBUFFER_LOAD_FORMAT_D16_X</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>TBUFFER_LOAD_FORMAT_D16_XY</td>
</tr>
<tr class="row-even"><td>10</td>
<td>TBUFFER_LOAD_FORMAT_D16_XYZ</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>TBUFFER_LOAD_FORMAT_D16_XYZW</td>
</tr>
<tr class="row-even"><td>12</td>
<td>TBUFFER_STORE_FORMAT_D16_X</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>TBUFFER_STORE_FORMAT_D16_XY</td>
</tr>
<tr class="row-even"><td>14</td>
<td>TBUFFER_STORE_FORMAT_D16_XYZ</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>TBUFFER_STORE_FORMAT_D16_XYZW</td>
</tr>
</tbody>
</table>
<p>Table: MTBUF Opcodes</p>
</div>
<div class="section" id="mubuf">
<h4>MUBUF<a class="headerlink" href="#mubuf" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode mubuf" src="../_images/microcode_mubuf.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>MUBUF</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Memory Untyped-Buffer Instructions</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OFFSET</td>
<td>[11:0]</td>
<td>Address offset, unsigned byte.</td>
</tr>
<tr class="row-odd"><td>OFFEN</td>
<td>[12]</td>
<td>1 = enable offset VGPR, 0 = use zero for address
offset</td>
</tr>
<tr class="row-even"><td>IDXEN</td>
<td>[13]</td>
<td>1 = enable index VGPR, 0 = use zero for address
index</td>
</tr>
<tr class="row-odd"><td>GLC</td>
<td>[14]</td>
<td>0 = normal, 1 = globally coherent (bypass L0
cache) or for atomics, return pre-op value to
VGPR.</td>
</tr>
<tr class="row-even"><td>LDS</td>
<td>[16]</td>
<td>0 = normal, 1 = transfer data between LDS and
memory instead of VGPRs and memory.</td>
</tr>
<tr class="row-odd"><td>SLC</td>
<td>[17]</td>
<td>System level coherent: bypass L2 cache.</td>
</tr>
<tr class="row-even"><td>OP</td>
<td>[24:18]</td>
<td>Opcode. See table below.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 111000</td>
</tr>
<tr class="row-even"><td>VADDR</td>
<td>[39:32]</td>
<td>Address of VGPR to supply first component of
address (offset or index). When both index and
offset are used, index is in the first VGPR and
offset in the second.</td>
</tr>
<tr class="row-odd"><td>VDATA</td>
<td>[47:40]</td>
<td>Address of VGPR to supply first component of
write data or receive first component of
read-data.</td>
</tr>
<tr class="row-even"><td>SRSRC</td>
<td>[52:48]</td>
<td>SGPR to supply V# (resource constant) in 4 or 8
consecutive SGPRs. It is missing 2 LSB’s of
SGPR-address since must be aligned to 4.</td>
</tr>
<tr class="row-odd"><td>TFE</td>
<td>[55]</td>
<td>Partially resident texture, texture fail enable.</td>
</tr>
<tr class="row-even"><td>SOFFSET</td>
<td>[63:56]</td>
<td>Address offset, unsigned byte.</td>
</tr>
</tbody>
</table>
<p>Table: MUBUF Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>BUFFER_LOAD_FORMAT_X</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>BUFFER_LOAD_FORMAT_XY</td>
</tr>
<tr class="row-even"><td>2</td>
<td>BUFFER_LOAD_FORMAT_XYZ</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>BUFFER_LOAD_FORMAT_XYZW</td>
</tr>
<tr class="row-even"><td>4</td>
<td>BUFFER_STORE_FORMAT_X</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>BUFFER_STORE_FORMAT_XY</td>
</tr>
<tr class="row-even"><td>6</td>
<td>BUFFER_STORE_FORMAT_XYZ</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>BUFFER_STORE_FORMAT_XYZW</td>
</tr>
<tr class="row-even"><td>8</td>
<td>BUFFER_LOAD_FORMAT_D16_X</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>BUFFER_LOAD_FORMAT_D16_XY</td>
</tr>
<tr class="row-even"><td>10</td>
<td>BUFFER_LOAD_FORMAT_D16_XYZ</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>BUFFER_LOAD_FORMAT_D16_XYZW</td>
</tr>
<tr class="row-even"><td>12</td>
<td>BUFFER_STORE_FORMAT_D16_X</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>BUFFER_STORE_FORMAT_D16_XY</td>
</tr>
<tr class="row-even"><td>14</td>
<td>BUFFER_STORE_FORMAT_D16_XYZ</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>BUFFER_STORE_FORMAT_D16_XYZW</td>
</tr>
<tr class="row-even"><td>16</td>
<td>BUFFER_LOAD_UBYTE</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>BUFFER_LOAD_SBYTE</td>
</tr>
<tr class="row-even"><td>18</td>
<td>BUFFER_LOAD_USHORT</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>BUFFER_LOAD_SSHORT</td>
</tr>
<tr class="row-even"><td>20</td>
<td>BUFFER_LOAD_DWORD</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>BUFFER_LOAD_DWORDX2</td>
</tr>
<tr class="row-even"><td>22</td>
<td>BUFFER_LOAD_DWORDX3</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>BUFFER_LOAD_DWORDX4</td>
</tr>
<tr class="row-even"><td>24</td>
<td>BUFFER_STORE_BYTE</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>BUFFER_STORE_BYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>26</td>
<td>BUFFER_STORE_SHORT</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>BUFFER_STORE_SHORT_D16_HI</td>
</tr>
<tr class="row-even"><td>28</td>
<td>BUFFER_STORE_DWORD</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>BUFFER_STORE_DWORDX2</td>
</tr>
<tr class="row-even"><td>30</td>
<td>BUFFER_STORE_DWORDX3</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>BUFFER_STORE_DWORDX4</td>
</tr>
<tr class="row-even"><td>32</td>
<td>BUFFER_LOAD_UBYTE_D16</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>BUFFER_LOAD_UBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>34</td>
<td>BUFFER_LOAD_SBYTE_D16</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>BUFFER_LOAD_SBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>36</td>
<td>BUFFER_LOAD_SHORT_D16</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>BUFFER_LOAD_SHORT_D16_HI</td>
</tr>
<tr class="row-even"><td>38</td>
<td>BUFFER_LOAD_FORMAT_D16_HI_X</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>BUFFER_STORE_FORMAT_D16_HI_X</td>
</tr>
<tr class="row-even"><td>61</td>
<td>BUFFER_STORE_LDS_DWORD</td>
</tr>
<tr class="row-odd"><td>62</td>
<td>BUFFER_WBINVL1</td>
</tr>
<tr class="row-even"><td>63</td>
<td>BUFFER_WBINVL1_VOL</td>
</tr>
<tr class="row-odd"><td>64</td>
<td>BUFFER_ATOMIC_SWAP</td>
</tr>
<tr class="row-even"><td>65</td>
<td>BUFFER_ATOMIC_CMPSWAP</td>
</tr>
<tr class="row-odd"><td>66</td>
<td>BUFFER_ATOMIC_ADD</td>
</tr>
<tr class="row-even"><td>67</td>
<td>BUFFER_ATOMIC_SUB</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>BUFFER_ATOMIC_SMIN</td>
</tr>
<tr class="row-even"><td>69</td>
<td>BUFFER_ATOMIC_UMIN</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>BUFFER_ATOMIC_SMAX</td>
</tr>
<tr class="row-even"><td>71</td>
<td>BUFFER_ATOMIC_UMAX</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>BUFFER_ATOMIC_AND</td>
</tr>
<tr class="row-even"><td>73</td>
<td>BUFFER_ATOMIC_OR</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>BUFFER_ATOMIC_XOR</td>
</tr>
<tr class="row-even"><td>75</td>
<td>BUFFER_ATOMIC_INC</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>BUFFER_ATOMIC_DEC</td>
</tr>
<tr class="row-even"><td>96</td>
<td>BUFFER_ATOMIC_SWAP_X2</td>
</tr>
<tr class="row-odd"><td>97</td>
<td>BUFFER_ATOMIC_CMPSWAP_X2</td>
</tr>
<tr class="row-even"><td>98</td>
<td>BUFFER_ATOMIC_ADD_X2</td>
</tr>
<tr class="row-odd"><td>99</td>
<td>BUFFER_ATOMIC_SUB_X2</td>
</tr>
<tr class="row-even"><td>100</td>
<td>BUFFER_ATOMIC_SMIN_X2</td>
</tr>
<tr class="row-odd"><td>101</td>
<td>BUFFER_ATOMIC_UMIN_X2</td>
</tr>
<tr class="row-even"><td>102</td>
<td>BUFFER_ATOMIC_SMAX_X2</td>
</tr>
<tr class="row-odd"><td>103</td>
<td>BUFFER_ATOMIC_UMAX_X2</td>
</tr>
<tr class="row-even"><td>104</td>
<td>BUFFER_ATOMIC_AND_X2</td>
</tr>
<tr class="row-odd"><td>105</td>
<td>BUFFER_ATOMIC_OR_X2</td>
</tr>
<tr class="row-even"><td>106</td>
<td>BUFFER_ATOMIC_XOR_X2</td>
</tr>
<tr class="row-odd"><td>107</td>
<td>BUFFER_ATOMIC_INC_X2</td>
</tr>
<tr class="row-even"><td>108</td>
<td>BUFFER_ATOMIC_DEC_X2</td>
</tr>
</tbody>
</table>
<p>Table: MUBUF Opcodes</p>
</div>
</div>
<div class="section" id="vector-memory-image-format">
<h3>Vector Memory Image Format<a class="headerlink" href="#vector-memory-image-format" title="Permalink to this headline">¶</a></h3>
<div class="section" id="mimg">
<h4>MIMG<a class="headerlink" href="#mimg" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode mimg" src="../_images/microcode_mimg.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>MIMG</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>Memory Image Instructions</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>DMASK</td>
<td>[11:8]</td>
<td><div class="first last line-block">
<div class="line">Data VGPR enable mask: 1 .. 4 consecutive VGPRs</div>
<div class="line">Reads: defines which components are returned:</div>
<div class="line">0=red,1=green,2=blue,3=alpha</div>
<div class="line">Writes: defines which components are written
with data from VGPRs (missing components get
0).</div>
<div class="line">Enabled components come from consecutive VGPRs.</div>
<div class="line">E.G. dmask=1001 : Red is in VGPRn and alpha in
VGPRn+1.</div>
<div class="line">For D16 writes, DMASK is only used as a word
count: each bit represents 16 bits of data to
be written starting at the LSB’s of VADDR, then
MSBs, then VADDR+1 etc. Bit position is
ignored.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>UNRM</td>
<td>[12]</td>
<td>1 = enable offset VGPR</td>
</tr>
<tr class="row-even"><td>GLC</td>
<td>[13]</td>
<td>0 = normal, 1 = globally coherent (bypass L0
cache) or for atomics, return pre-op value to
VGPR.</td>
</tr>
<tr class="row-odd"><td>DA</td>
<td>[14]</td>
<td><div class="first last line-block">
<div class="line">Declare an Array.</div>
<div class="line">1 Kernel has declared this resource to be an
array of texture maps.</div>
<div class="line">0 Kernel has declared this resource to be a
single texture map.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>A16</td>
<td>[15]</td>
<td><div class="first last line-block">
<div class="line">Address components are 16-bits (instead of the
usual 32 bits).</div>
<div class="line">When set, all address components are 16 bits
(packed into 2 per dword), except:</div>
<div class="line">Texel offsets (3 6bit UINT packed into 1 dword)</div>
<div class="line">PCF reference (for “_C” instructions)</div>
<div class="line">Address components are 16b uint for image ops
without sampler; 16b float with sampler.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>TFE</td>
<td>[16]</td>
<td>Partially resident texture, texture fail enable.</td>
</tr>
<tr class="row-even"><td>LWE</td>
<td>[17]</td>
<td>LOD Warning Enable. When set to 1, a texture
fetch may return “LOD_CLAMPED = 1”.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[0],[24
:18]</td>
<td>Opcode. See table below. (combine bits zero and
18-24 to form opcode).</td>
</tr>
<tr class="row-even"><td>SLC</td>
<td>[25]</td>
<td>System level coherent: bypass L2 cache.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 111100</td>
</tr>
<tr class="row-even"><td>VADDR</td>
<td>[39:32]</td>
<td>Address of VGPR to supply first component of
address (offset or index). When both index and
offset are used, index is in the first VGPR and
offset in the second.</td>
</tr>
<tr class="row-odd"><td>VDATA</td>
<td>[47:40]</td>
<td>Address of VGPR to supply first component of
write data or receive first component of
read-data.</td>
</tr>
<tr class="row-even"><td>SRSRC</td>
<td>[52:48]</td>
<td>SGPR to supply V# (resource constant) in 4 or 8
consecutive SGPRs. It is missing 2 LSB’s of
SGPR-address since must be aligned to 4.</td>
</tr>
<tr class="row-odd"><td>SSAMP</td>
<td>[57:53]</td>
<td>SGPR to supply V# (resource constant) in 4 or 8
consecutive SGPRs. It is missing 2 LSB’s of
SGPR-address since must be aligned to 4.</td>
</tr>
<tr class="row-even"><td>D16</td>
<td>[63]</td>
<td>Address offset, unsigned byte.</td>
</tr>
</tbody>
</table>
<p>Table: MIMG Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>IMAGE_LOAD</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>IMAGE_LOAD_MIP</td>
</tr>
<tr class="row-even"><td>2</td>
<td>IMAGE_LOAD_PCK</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>IMAGE_LOAD_PCK_SGN</td>
</tr>
<tr class="row-even"><td>4</td>
<td>IMAGE_LOAD_MIP_PCK</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>IMAGE_LOAD_MIP_PCK_SGN</td>
</tr>
<tr class="row-even"><td>8</td>
<td>IMAGE_STORE</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>IMAGE_STORE_MIP</td>
</tr>
<tr class="row-even"><td>10</td>
<td>IMAGE_STORE_PCK</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>IMAGE_STORE_MIP_PCK</td>
</tr>
<tr class="row-even"><td>14</td>
<td>IMAGE_GET_RESINFO</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>IMAGE_ATOMIC_SWAP</td>
</tr>
<tr class="row-even"><td>17</td>
<td>IMAGE_ATOMIC_CMPSWAP</td>
</tr>
<tr class="row-odd"><td>18</td>
<td>IMAGE_ATOMIC_ADD</td>
</tr>
<tr class="row-even"><td>19</td>
<td>IMAGE_ATOMIC_SUB</td>
</tr>
<tr class="row-odd"><td>20</td>
<td>IMAGE_ATOMIC_SMIN</td>
</tr>
<tr class="row-even"><td>21</td>
<td>IMAGE_ATOMIC_UMIN</td>
</tr>
<tr class="row-odd"><td>22</td>
<td>IMAGE_ATOMIC_SMAX</td>
</tr>
<tr class="row-even"><td>23</td>
<td>IMAGE_ATOMIC_UMAX</td>
</tr>
<tr class="row-odd"><td>24</td>
<td>IMAGE_ATOMIC_AND</td>
</tr>
<tr class="row-even"><td>25</td>
<td>IMAGE_ATOMIC_OR</td>
</tr>
<tr class="row-odd"><td>26</td>
<td>IMAGE_ATOMIC_XOR</td>
</tr>
<tr class="row-even"><td>27</td>
<td>IMAGE_ATOMIC_INC</td>
</tr>
<tr class="row-odd"><td>28</td>
<td>IMAGE_ATOMIC_DEC</td>
</tr>
<tr class="row-even"><td>32</td>
<td>IMAGE_SAMPLE</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>IMAGE_SAMPLE_CL</td>
</tr>
<tr class="row-even"><td>34</td>
<td>IMAGE_SAMPLE_D</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>IMAGE_SAMPLE_D_CL</td>
</tr>
<tr class="row-even"><td>36</td>
<td>IMAGE_SAMPLE_L</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>IMAGE_SAMPLE_B</td>
</tr>
<tr class="row-even"><td>38</td>
<td>IMAGE_SAMPLE_B_CL</td>
</tr>
<tr class="row-odd"><td>39</td>
<td>IMAGE_SAMPLE_LZ</td>
</tr>
<tr class="row-even"><td>40</td>
<td>IMAGE_SAMPLE_C</td>
</tr>
<tr class="row-odd"><td>41</td>
<td>IMAGE_SAMPLE_C_CL</td>
</tr>
<tr class="row-even"><td>42</td>
<td>IMAGE_SAMPLE_C_D</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>IMAGE_SAMPLE_C_D_CL</td>
</tr>
<tr class="row-even"><td>44</td>
<td>IMAGE_SAMPLE_C_L</td>
</tr>
<tr class="row-odd"><td>45</td>
<td>IMAGE_SAMPLE_C_B</td>
</tr>
<tr class="row-even"><td>46</td>
<td>IMAGE_SAMPLE_C_B_CL</td>
</tr>
<tr class="row-odd"><td>47</td>
<td>IMAGE_SAMPLE_C_LZ</td>
</tr>
<tr class="row-even"><td>48</td>
<td>IMAGE_SAMPLE_O</td>
</tr>
<tr class="row-odd"><td>49</td>
<td>IMAGE_SAMPLE_CL_O</td>
</tr>
<tr class="row-even"><td>50</td>
<td>IMAGE_SAMPLE_D_O</td>
</tr>
<tr class="row-odd"><td>51</td>
<td>IMAGE_SAMPLE_D_CL_O</td>
</tr>
<tr class="row-even"><td>52</td>
<td>IMAGE_SAMPLE_L_O</td>
</tr>
<tr class="row-odd"><td>53</td>
<td>IMAGE_SAMPLE_B_O</td>
</tr>
<tr class="row-even"><td>54</td>
<td>IMAGE_SAMPLE_B_CL_O</td>
</tr>
<tr class="row-odd"><td>55</td>
<td>IMAGE_SAMPLE_LZ_O</td>
</tr>
<tr class="row-even"><td>56</td>
<td>IMAGE_SAMPLE_C_O</td>
</tr>
<tr class="row-odd"><td>57</td>
<td>IMAGE_SAMPLE_C_CL_O</td>
</tr>
<tr class="row-even"><td>58</td>
<td>IMAGE_SAMPLE_C_D_O</td>
</tr>
<tr class="row-odd"><td>59</td>
<td>IMAGE_SAMPLE_C_D_CL_O</td>
</tr>
<tr class="row-even"><td>60</td>
<td>IMAGE_SAMPLE_C_L_O</td>
</tr>
<tr class="row-odd"><td>61</td>
<td>IMAGE_SAMPLE_C_B_O</td>
</tr>
<tr class="row-even"><td>62</td>
<td>IMAGE_SAMPLE_C_B_CL_O</td>
</tr>
<tr class="row-odd"><td>63</td>
<td>IMAGE_SAMPLE_C_LZ_O</td>
</tr>
<tr class="row-even"><td>64</td>
<td>IMAGE_GATHER4</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>IMAGE_GATHER4_CL</td>
</tr>
<tr class="row-even"><td>66</td>
<td>IMAGE_GATHER4H</td>
</tr>
<tr class="row-odd"><td>68</td>
<td>IMAGE_GATHER4_L</td>
</tr>
<tr class="row-even"><td>69</td>
<td>IMAGE_GATHER4_B</td>
</tr>
<tr class="row-odd"><td>70</td>
<td>IMAGE_GATHER4_B_CL</td>
</tr>
<tr class="row-even"><td>71</td>
<td>IMAGE_GATHER4_LZ</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>IMAGE_GATHER4_C</td>
</tr>
<tr class="row-even"><td>73</td>
<td>IMAGE_GATHER4_C_CL</td>
</tr>
<tr class="row-odd"><td>74</td>
<td>IMAGE_GATHER4H_PCK</td>
</tr>
<tr class="row-even"><td>75</td>
<td>IMAGE_GATHER8H_PCK</td>
</tr>
<tr class="row-odd"><td>76</td>
<td>IMAGE_GATHER4_C_L</td>
</tr>
<tr class="row-even"><td>77</td>
<td>IMAGE_GATHER4_C_B</td>
</tr>
<tr class="row-odd"><td>78</td>
<td>IMAGE_GATHER4_C_B_CL</td>
</tr>
<tr class="row-even"><td>79</td>
<td>IMAGE_GATHER4_C_LZ</td>
</tr>
<tr class="row-odd"><td>80</td>
<td>IMAGE_GATHER4_O</td>
</tr>
<tr class="row-even"><td>81</td>
<td>IMAGE_GATHER4_CL_O</td>
</tr>
<tr class="row-odd"><td>84</td>
<td>IMAGE_GATHER4_L_O</td>
</tr>
<tr class="row-even"><td>85</td>
<td>IMAGE_GATHER4_B_O</td>
</tr>
<tr class="row-odd"><td>86</td>
<td>IMAGE_GATHER4_B_CL_O</td>
</tr>
<tr class="row-even"><td>87</td>
<td>IMAGE_GATHER4_LZ_O</td>
</tr>
<tr class="row-odd"><td>88</td>
<td>IMAGE_GATHER4_C_O</td>
</tr>
<tr class="row-even"><td>89</td>
<td>IMAGE_GATHER4_C_CL_O</td>
</tr>
<tr class="row-odd"><td>92</td>
<td>IMAGE_GATHER4_C_L_O</td>
</tr>
<tr class="row-even"><td>93</td>
<td>IMAGE_GATHER4_C_B_O</td>
</tr>
<tr class="row-odd"><td>94</td>
<td>IMAGE_GATHER4_C_B_CL_O</td>
</tr>
<tr class="row-even"><td>95</td>
<td>IMAGE_GATHER4_C_LZ_O</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>IMAGE_GET_LOD</td>
</tr>
<tr class="row-even"><td>104</td>
<td>IMAGE_SAMPLE_CD</td>
</tr>
<tr class="row-odd"><td>105</td>
<td>IMAGE_SAMPLE_CD_CL</td>
</tr>
<tr class="row-even"><td>106</td>
<td>IMAGE_SAMPLE_C_CD</td>
</tr>
<tr class="row-odd"><td>107</td>
<td>IMAGE_SAMPLE_C_CD_CL</td>
</tr>
<tr class="row-even"><td>108</td>
<td>IMAGE_SAMPLE_CD_O</td>
</tr>
<tr class="row-odd"><td>109</td>
<td>IMAGE_SAMPLE_CD_CL_O</td>
</tr>
<tr class="row-even"><td>110</td>
<td>IMAGE_SAMPLE_C_CD_O</td>
</tr>
<tr class="row-odd"><td>111</td>
<td>IMAGE_SAMPLE_C_CD_CL_O</td>
</tr>
</tbody>
</table>
<p>Table: MIMG Opcodes</p>
</div>
</div>
<div class="section" id="flat-formats">
<h3>Flat Formats<a class="headerlink" href="#flat-formats" title="Permalink to this headline">¶</a></h3>
<p>Flat memory instruction come in three versions: FLAT:: memory address
(per work-item) may be in global memory, scratch (private) memory or
shared memory (LDS) GLOBAL:: same as FLAT, but assumes all memory
addresses are global memory. SCRATCH:: same as FLAT, but assumes all
memory addresses are scratch (private) memory.</p>
<p>The microcode format is identical for each, and only the value of the
SEG (segment) field differs.</p>
<div class="section" id="flat">
<h4>FLAT<a class="headerlink" href="#flat" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode flat" src="../_images/microcode_flat.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>FLAT</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>FLAT Memory Access</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OFFSET</td>
<td>[12:0]</td>
<td><div class="first last line-block">
<div class="line">Address offset</div>
<div class="line">Scratch, Global: 13-bit signed byte offset</div>
<div class="line">FLAT: 12-bit unsigned offset (MSB is ignored)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>LDS</td>
<td>[13]</td>
<td>0 = normal, 1 = transfer data between LDS and
memory instead of VGPRs and memory.</td>
</tr>
<tr class="row-even"><td>SEG</td>
<td>[15:14]</td>
<td>Memory Segment (instruction type): 0 = flat, 1 =
scratch, 2 = global.</td>
</tr>
<tr class="row-odd"><td>GLC</td>
<td>[16]</td>
<td>0 = normal, 1 = globally coherent (bypass L0
cache) or for atomics, return pre-op value to
VGPR.</td>
</tr>
<tr class="row-even"><td>SLC</td>
<td>[17]</td>
<td>System level coherent: bypass L2 cache.</td>
</tr>
<tr class="row-odd"><td>OP</td>
<td>[24:18]</td>
<td>Opcode. See tables below for FLAT, SCRATCH and
GLOBAL opcodes.</td>
</tr>
<tr class="row-even"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 110111</td>
</tr>
<tr class="row-odd"><td>ADDR</td>
<td>[39:32]</td>
<td><div class="first last line-block">
<div class="line">VGPR which holds address or offset. For 64-bit
addresses, ADDR has the LSB’s and ADDR+1 has
the MSBs. For offset a single VGPR has a 32 bit
unsigned offset.</div>
<div class="line">For FLAT_*: always specifies an address.</div>
<div class="line">For GLOBAL_* and SCRATCH_* when SADDR is
0x7f: specifies an address.</div>
<div class="line">For GLOBAL_* and SCRATCH_* when SADDR is
not 0x7f: specifies an offset.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>DATA</td>
<td>[47:40]</td>
<td>VGPR which supplies data.</td>
</tr>
<tr class="row-odd"><td>SADDR</td>
<td>[54:48]</td>
<td><div class="first last line-block">
<div class="line">Scalar SGPR which provides an address of offset
(unsigned). Set this field to 0x7f to disable
use.</div>
<div class="line">Meaning of this field is different for Scratch
and Global:</div>
<div class="line">FLAT: Unused</div>
<div class="line">Scratch: use an SGPR for the address instead of
a VGPR</div>
<div class="line">Global: use the SGPR to provide a base address
and the VGPR provides a 32-bit byte offset.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>NV</td>
<td>[55]</td>
<td>Non-Volatile.</td>
</tr>
<tr class="row-odd"><td>VDST</td>
<td>[63:56]</td>
<td>Destination VGPR for data returned from memory to
VGPRs.</td>
</tr>
</tbody>
</table>
<p>Table: FLAT Fields</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>FLAT_LOAD_UBYTE</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>FLAT_LOAD_SBYTE</td>
</tr>
<tr class="row-even"><td>18</td>
<td>FLAT_LOAD_USHORT</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>FLAT_LOAD_SSHORT</td>
</tr>
<tr class="row-even"><td>20</td>
<td>FLAT_LOAD_DWORD</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>FLAT_LOAD_DWORDX2</td>
</tr>
<tr class="row-even"><td>22</td>
<td>FLAT_LOAD_DWORDX3</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>FLAT_LOAD_DWORDX4</td>
</tr>
<tr class="row-even"><td>24</td>
<td>FLAT_STORE_BYTE</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>FLAT_STORE_BYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>26</td>
<td>FLAT_STORE_SHORT</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>FLAT_STORE_SHORT_D16_HI</td>
</tr>
<tr class="row-even"><td>28</td>
<td>FLAT_STORE_DWORD</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>FLAT_STORE_DWORDX2</td>
</tr>
<tr class="row-even"><td>30</td>
<td>FLAT_STORE_DWORDX3</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>FLAT_STORE_DWORDX4</td>
</tr>
<tr class="row-even"><td>32</td>
<td>FLAT_LOAD_UBYTE_D16</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>FLAT_LOAD_UBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>34</td>
<td>FLAT_LOAD_SBYTE_D16</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>FLAT_LOAD_SBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>36</td>
<td>FLAT_LOAD_SHORT_D16</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>FLAT_LOAD_SHORT_D16_HI</td>
</tr>
<tr class="row-even"><td>64</td>
<td>FLAT_ATOMIC_SWAP</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>FLAT_ATOMIC_CMPSWAP</td>
</tr>
<tr class="row-even"><td>66</td>
<td>FLAT_ATOMIC_ADD</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>FLAT_ATOMIC_SUB</td>
</tr>
<tr class="row-even"><td>68</td>
<td>FLAT_ATOMIC_SMIN</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>FLAT_ATOMIC_UMIN</td>
</tr>
<tr class="row-even"><td>70</td>
<td>FLAT_ATOMIC_SMAX</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>FLAT_ATOMIC_UMAX</td>
</tr>
<tr class="row-even"><td>72</td>
<td>FLAT_ATOMIC_AND</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>FLAT_ATOMIC_OR</td>
</tr>
<tr class="row-even"><td>74</td>
<td>FLAT_ATOMIC_XOR</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>FLAT_ATOMIC_INC</td>
</tr>
<tr class="row-even"><td>76</td>
<td>FLAT_ATOMIC_DEC</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>FLAT_ATOMIC_SWAP_X2</td>
</tr>
<tr class="row-even"><td>97</td>
<td>FLAT_ATOMIC_CMPSWAP_X2</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>FLAT_ATOMIC_ADD_X2</td>
</tr>
<tr class="row-even"><td>99</td>
<td>FLAT_ATOMIC_SUB_X2</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>FLAT_ATOMIC_SMIN_X2</td>
</tr>
<tr class="row-even"><td>101</td>
<td>FLAT_ATOMIC_UMIN_X2</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>FLAT_ATOMIC_SMAX_X2</td>
</tr>
<tr class="row-even"><td>103</td>
<td>FLAT_ATOMIC_UMAX_X2</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>FLAT_ATOMIC_AND_X2</td>
</tr>
<tr class="row-even"><td>105</td>
<td>FLAT_ATOMIC_OR_X2</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>FLAT_ATOMIC_XOR_X2</td>
</tr>
<tr class="row-even"><td>107</td>
<td>FLAT_ATOMIC_INC_X2</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>FLAT_ATOMIC_DEC_X2</td>
</tr>
</tbody>
</table>
<p>Table: FLAT Opcodes</p>
</div>
<div class="section" id="id12">
<h4>GLOBAL<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>GLOBAL_LOAD_UBYTE</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>GLOBAL_LOAD_SBYTE</td>
</tr>
<tr class="row-even"><td>18</td>
<td>GLOBAL_LOAD_USHORT</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>GLOBAL_LOAD_SSHORT</td>
</tr>
<tr class="row-even"><td>20</td>
<td>GLOBAL_LOAD_DWORD</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>GLOBAL_LOAD_DWORDX2</td>
</tr>
<tr class="row-even"><td>22</td>
<td>GLOBAL_LOAD_DWORDX3</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>GLOBAL_LOAD_DWORDX4</td>
</tr>
<tr class="row-even"><td>24</td>
<td>GLOBAL_STORE_BYTE</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>GLOBAL_STORE_BYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>26</td>
<td>GLOBAL_STORE_SHORT</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>GLOBAL_STORE_SHORT_D16_HI</td>
</tr>
<tr class="row-even"><td>28</td>
<td>GLOBAL_STORE_DWORD</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>GLOBAL_STORE_DWORDX2</td>
</tr>
<tr class="row-even"><td>30</td>
<td>GLOBAL_STORE_DWORDX3</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>GLOBAL_STORE_DWORDX4</td>
</tr>
<tr class="row-even"><td>32</td>
<td>GLOBAL_LOAD_UBYTE_D16</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>GLOBAL_LOAD_UBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>34</td>
<td>GLOBAL_LOAD_SBYTE_D16</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>GLOBAL_LOAD_SBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>36</td>
<td>GLOBAL_LOAD_SHORT_D16</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>GLOBAL_LOAD_SHORT_D16_HI</td>
</tr>
<tr class="row-even"><td>64</td>
<td>GLOBAL_ATOMIC_SWAP</td>
</tr>
<tr class="row-odd"><td>65</td>
<td>GLOBAL_ATOMIC_CMPSWAP</td>
</tr>
<tr class="row-even"><td>66</td>
<td>GLOBAL_ATOMIC_ADD</td>
</tr>
<tr class="row-odd"><td>67</td>
<td>GLOBAL_ATOMIC_SUB</td>
</tr>
<tr class="row-even"><td>68</td>
<td>GLOBAL_ATOMIC_SMIN</td>
</tr>
<tr class="row-odd"><td>69</td>
<td>GLOBAL_ATOMIC_UMIN</td>
</tr>
<tr class="row-even"><td>70</td>
<td>GLOBAL_ATOMIC_SMAX</td>
</tr>
<tr class="row-odd"><td>71</td>
<td>GLOBAL_ATOMIC_UMAX</td>
</tr>
<tr class="row-even"><td>72</td>
<td>GLOBAL_ATOMIC_AND</td>
</tr>
<tr class="row-odd"><td>73</td>
<td>GLOBAL_ATOMIC_OR</td>
</tr>
<tr class="row-even"><td>74</td>
<td>GLOBAL_ATOMIC_XOR</td>
</tr>
<tr class="row-odd"><td>75</td>
<td>GLOBAL_ATOMIC_INC</td>
</tr>
<tr class="row-even"><td>76</td>
<td>GLOBAL_ATOMIC_DEC</td>
</tr>
<tr class="row-odd"><td>96</td>
<td>GLOBAL_ATOMIC_SWAP_X2</td>
</tr>
<tr class="row-even"><td>97</td>
<td>GLOBAL_ATOMIC_CMPSWAP_X2</td>
</tr>
<tr class="row-odd"><td>98</td>
<td>GLOBAL_ATOMIC_ADD_X2</td>
</tr>
<tr class="row-even"><td>99</td>
<td>GLOBAL_ATOMIC_SUB_X2</td>
</tr>
<tr class="row-odd"><td>100</td>
<td>GLOBAL_ATOMIC_SMIN_X2</td>
</tr>
<tr class="row-even"><td>101</td>
<td>GLOBAL_ATOMIC_UMIN_X2</td>
</tr>
<tr class="row-odd"><td>102</td>
<td>GLOBAL_ATOMIC_SMAX_X2</td>
</tr>
<tr class="row-even"><td>103</td>
<td>GLOBAL_ATOMIC_UMAX_X2</td>
</tr>
<tr class="row-odd"><td>104</td>
<td>GLOBAL_ATOMIC_AND_X2</td>
</tr>
<tr class="row-even"><td>105</td>
<td>GLOBAL_ATOMIC_OR_X2</td>
</tr>
<tr class="row-odd"><td>106</td>
<td>GLOBAL_ATOMIC_XOR_X2</td>
</tr>
<tr class="row-even"><td>107</td>
<td>GLOBAL_ATOMIC_INC_X2</td>
</tr>
<tr class="row-odd"><td>108</td>
<td>GLOBAL_ATOMIC_DEC_X2</td>
</tr>
</tbody>
</table>
<p>Table: GLOBAL Opcodes</p>
</div>
<div class="section" id="id13">
<h4>SCRATCH<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Opcode #</th>
<th class="head">Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>SCRATCH_LOAD_UBYTE</td>
</tr>
<tr class="row-odd"><td>17</td>
<td>SCRATCH_LOAD_SBYTE</td>
</tr>
<tr class="row-even"><td>18</td>
<td>SCRATCH_LOAD_USHORT</td>
</tr>
<tr class="row-odd"><td>19</td>
<td>SCRATCH_LOAD_SSHORT</td>
</tr>
<tr class="row-even"><td>20</td>
<td>SCRATCH_LOAD_DWORD</td>
</tr>
<tr class="row-odd"><td>21</td>
<td>SCRATCH_LOAD_DWORDX2</td>
</tr>
<tr class="row-even"><td>22</td>
<td>SCRATCH_LOAD_DWORDX3</td>
</tr>
<tr class="row-odd"><td>23</td>
<td>SCRATCH_LOAD_DWORDX4</td>
</tr>
<tr class="row-even"><td>24</td>
<td>SCRATCH_STORE_BYTE</td>
</tr>
<tr class="row-odd"><td>25</td>
<td>SCRATCH_STORE_BYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>26</td>
<td>SCRATCH_STORE_SHORT</td>
</tr>
<tr class="row-odd"><td>27</td>
<td>SCRATCH_STORE_SHORT_D16_HI</td>
</tr>
<tr class="row-even"><td>28</td>
<td>SCRATCH_STORE_DWORD</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>SCRATCH_STORE_DWORDX2</td>
</tr>
<tr class="row-even"><td>30</td>
<td>SCRATCH_STORE_DWORDX3</td>
</tr>
<tr class="row-odd"><td>31</td>
<td>SCRATCH_STORE_DWORDX4</td>
</tr>
<tr class="row-even"><td>32</td>
<td>SCRATCH_LOAD_UBYTE_D16</td>
</tr>
<tr class="row-odd"><td>33</td>
<td>SCRATCH_LOAD_UBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>34</td>
<td>SCRATCH_LOAD_SBYTE_D16</td>
</tr>
<tr class="row-odd"><td>35</td>
<td>SCRATCH_LOAD_SBYTE_D16_HI</td>
</tr>
<tr class="row-even"><td>36</td>
<td>SCRATCH_LOAD_SHORT_D16</td>
</tr>
<tr class="row-odd"><td>37</td>
<td>SCRATCH_LOAD_SHORT_D16_HI</td>
</tr>
</tbody>
</table>
<p>Table: SCRATCH Opcodes</p>
</div>
</div>
<div class="section" id="export-format">
<h3>Export Format<a class="headerlink" href="#export-format" title="Permalink to this headline">¶</a></h3>
<div class="section" id="exp">
<h4>EXP<a class="headerlink" href="#exp" title="Permalink to this headline">¶</a></h4>
<p><img alt="microcode mubuf" src="../_images/microcode_mubuf.png" /></p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Format</td>
<td>EXP</td>
</tr>
<tr class="row-even"><td>Descriptio
n</td>
<td>EXPORT instructions</td>
</tr>
</tbody>
</table>
<p>The export format has only a single opcode, “EXPORT”.</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="12%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Field Name</th>
<th class="head">Bits</th>
<th class="head">Format or Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>EN</td>
<td>[3:0]</td>
<td><div class="first last line-block">
<div class="line">COMPR==1: export half-dword enable. Valid
values are: 0x0,3,c,f</div>
<div class="line">[0] enables VSRC0 : R,G from one VGPR (R in low
bits, G high)</div>
<div class="line">[2] enables VSRC1 : B,A from one VGPR (B in low
bits, A high)</div>
<div class="line">COMPR==0: [0-3] = enables for VSRC0..3.</div>
<div class="line">EN may be zero only for “NULL Pixel Shader”
exports (used when exporting only valid mask to
NULL target).</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>TARGET</td>
<td>[9:4]</td>
<td><div class="first last line-block">
<div class="line">Export destination:</div>
<div class="line">0-7: MRT 0..7</div>
<div class="line">8: Z</div>
<div class="line">9: Null pixel shader export (no data)</div>
<div class="line">12-15: Position 0..3</div>
<div class="line">32-63: Parameter 0..31</div>
</div>
</td>
</tr>
<tr class="row-even"><td>COMPR</td>
<td>[10]</td>
<td>Indicates that data is float-16/short/byte
(compressed). Data is written to consecutive
components (rgba or xyzw).</td>
</tr>
<tr class="row-odd"><td>DONE</td>
<td>[11]</td>
<td>Indicates that this is the last export from the
shader. Used only for Position and Pixel/color
data.</td>
</tr>
<tr class="row-even"><td>VM</td>
<td>[12]</td>
<td>1 = the exec mask IS the valid mask for this
export. Can be sent multiple times, must be sent
at least once per pixel shader. This bit is only
used for Pixel Shaders.</td>
</tr>
<tr class="row-odd"><td>ENCODING</td>
<td>[31:26]</td>
<td>Must be: 110001</td>
</tr>
<tr class="row-even"><td>VSRC0</td>
<td>[39:32]</td>
<td>VGPR for source 0.</td>
</tr>
<tr class="row-odd"><td>VSRC1</td>
<td>[47:40]</td>
<td>VGPR for source 1.</td>
</tr>
<tr class="row-even"><td>VSRC2</td>
<td>[55:48]</td>
<td>VGPR for source 2.</td>
</tr>
<tr class="row-odd"><td>VSRC3</td>
<td>[63:56]</td>
<td>VGPR for source 3.</td>
</tr>
</tbody>
</table>
<p>Table: EXP Fields</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Thomas Edvalson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>