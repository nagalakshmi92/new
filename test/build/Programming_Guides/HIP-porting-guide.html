

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>HIP porting guide: overview and how-to &mdash; ReadTheDocs-Breathe 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> ReadTheDocs-Breathe
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../ROCm.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Current_Release_Notes/Current-Release-Notes.html">Current Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Installation_Guide/Installation-Guide.html">ROCm Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Programming-Guides.html">Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_GPU_Tunning_Guides/ROCm-GPU-Tunning-Guides.html">ROCm GPU Tuning Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GCN_ISA_Manuals/GCN-ISA-Manuals.html">GCN ISA Manuals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_API_References/ROCm-API-References.html">ROCm API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Tools/ROCm-Tools.html">ROCm Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Libraries/ROCm_Libraries.html">ROCm Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Compiler_SDK/ROCm-Compiler-SDK.html">ROCm Compiler SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_System_Managment/ROCm-System-Managment.html">ROCm System Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Virtualization_Containers/ROCm-Virtualization-&amp;-Containers.html">ROCm Virtualization &amp; Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Remote_Device_Programming/Remote-Device-Programming.html">Remote Device Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Deep_learning/Deep-learning.html">Deep Learning on ROCm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Other_Solutions/Other-Solutions.html">System Level Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tutorial/Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ROCm_Glossary/ROCm-Glossary.html">ROCm Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ReadTheDocs-Breathe</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>HIP porting guide: overview and how-to</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Programming_Guides/HIP-porting-guide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="hip-porting-guide-overview-and-how-to">
<span id="hip-porting-guide"></span><h1>HIP porting guide: overview and how-to<a class="headerlink" href="#hip-porting-guide-overview-and-how-to" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>HIP Porting Guide<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>In addition to providing a portable C++ programming environment for GPUs, HIP is designed to ease the porting of existing CUDA code into the HIP environment. This section describes the available tools and provides practical suggestions on how to port CUDA code and work through common issues.</p>
</div>
<div class="section" id="porting-a-new-cuda-project">
<h2>Porting a New Cuda Project<a class="headerlink" href="#porting-a-new-cuda-project" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general-tips">
<h3>General Tips<a class="headerlink" href="#general-tips" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>Starting the port on a Cuda machine is often the easiest approach, since you can incrementally port pieces of the code to HIP while leaving         the rest in Cuda. (Recall that on Cuda machines HIP is just a thin layer over Cuda, so the two code types can interoperate on nvcc platforms.)          Also, the HIP port can be compared with the original Cuda code for function and performance.</li>
<li>Once the Cuda code is ported to HIP and is running on the Cuda machine, compile the HIP code using hcc on an AMD machine.</li>
<li>HIP ports can replace Cuda versions—HIP can deliver the same performance as a native Cuda implementation, with the benefit of portability        to both Nvidia and AMD architectures as well as a path to future C++ standard support. You can handle platform-specific features through                conditional compilation or by adding them to the open-source HIP infrastructure.</li>
<li>Use bin/hipconvertinplace.sh to hipify all code files in the Cuda source directory.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="scanning-existing-cuda-code-to-scope-the-porting-effort">
<h2>Scanning existing CUDA code to scope the porting effort<a class="headerlink" href="#scanning-existing-cuda-code-to-scope-the-porting-effort" title="Permalink to this headline">¶</a></h2>
<p>The hipexamine.sh tool will scan a source directory to determine which files contain CUDA code and how much of that code can be automatically hipified,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; cd examples/rodinia_3.0/cuda/kmeans
&gt; $HIP_DIR/bin/hipexamine.sh .
info: hipify ./kmeans.h =====&gt;
info: hipify ./unistd.h =====&gt;
info: hipify ./kmeans.c =====&gt;
info: hipify ./kmeans_cuda_kernel.cu =====&gt;
info: converted 40 CUDA-&gt;HIP refs( dev:0 mem:0 kern:0 builtin:37 math:0 stream:0 event:0 err:0 def:0 tex:3 other:0 ) warn:0 LOC:185
info: hipify ./getopt.h =====&gt;
info: hipify ./kmeans_cuda.cu =====&gt;
info: converted 49 CUDA-&gt;HIP refs( dev:3 mem:32 kern:2 builtin:0 math:0 stream:0 event:0 err:0 def:0 tex:12 other:0 ) warn:0 LOC:311
info: hipify ./rmse.c =====&gt;
info: hipify ./cluster.c =====&gt;
info: hipify ./getopt.c =====&gt;
info: hipify ./kmeans_clustering.c =====&gt;
info: TOTAL-converted 89 CUDA-&gt;HIP refs( dev:3 mem:32 kern:2 builtin:37 math:0 stream:0 event:0 err:0 def:0 tex:15 other:0 ) warn:0 LOC:3607
kernels (1 total) :   kmeansPoint(1)
</pre></div>
</div>
<p>hipexamine scans each code file (cpp, c, h, hpp, etc) found in the specified directory:</p>
<blockquote>
<div><ul>
<li><p class="first">Files with no CUDA code (ie kmeans.h) print one line summary just listing the source file name.</p>
</li>
<li><p class="first">Files with CUDA code print a summary of what was found - for example the kmeans_cuda_kernel.cu file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">:</span> <span class="n">hipify</span> <span class="o">./</span><span class="n">kmeans_cuda_kernel</span><span class="o">.</span><span class="n">cu</span> <span class="o">=====&gt;</span>
<span class="n">info</span><span class="p">:</span> <span class="n">converted</span> <span class="mi">40</span> <span class="n">CUDA</span><span class="o">-&gt;</span><span class="n">HIP</span> <span class="n">refs</span><span class="p">(</span> <span class="n">dev</span><span class="p">:</span><span class="mi">0</span> <span class="n">mem</span><span class="p">:</span><span class="mi">0</span> <span class="n">kern</span><span class="p">:</span><span class="mi">0</span> <span class="n">builtin</span><span class="p">:</span><span class="mi">37</span> <span class="n">math</span><span class="p">:</span><span class="mi">0</span> <span class="n">stream</span><span class="p">:</span><span class="mi">0</span> <span class="n">event</span><span class="p">:</span><span class="mi">0</span>
</pre></div>
</div>
</li>
<li><p class="first">Some of the most interesting information in kmeans_cuda_kernel.cu : * How many CUDA calls were converted to HIP (40) * Breakdown of the            different CUDA functionality used (dev:0 mem:0 etc). This file uses many CUDA builtins (37) and texture functions (3). * Warning for code that          looks like CUDA API but was not converted (0 in this file). * Count Lines-of-Code (LOC) - 185 for this file.</p>
</li>
<li><p class="first">hipexamine also presents a summary at the end of the process for the statistics collected across all files. This has similar format to the                 per-file reporting, and also includes a list of all kernels which have been called. An example from above:</p>
</li>
</ul>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">:</span> <span class="n">TOTAL</span><span class="o">-</span><span class="n">converted</span> <span class="mi">89</span> <span class="n">CUDA</span><span class="o">-&gt;</span><span class="n">HIP</span> <span class="n">refs</span><span class="p">(</span> <span class="n">dev</span><span class="p">:</span><span class="mi">3</span> <span class="n">mem</span><span class="p">:</span><span class="mi">32</span> <span class="n">kern</span><span class="p">:</span><span class="mi">2</span> <span class="n">builtin</span><span class="p">:</span><span class="mi">37</span> <span class="n">math</span><span class="p">:</span><span class="mi">0</span> <span class="n">stream</span><span class="p">:</span><span class="mi">0</span> <span class="n">event</span><span class="p">:</span><span class="mi">0</span> <span class="n">err</span><span class="p">:</span><span class="mi">0</span> <span class="n">def</span><span class="p">:</span><span class="mi">0</span> <span class="n">tex</span><span class="p">:</span><span class="mi">15</span> <span class="n">other</span><span class="p">:</span><span class="mi">0</span> <span class="p">)</span> <span class="n">warn</span><span class="p">:</span><span class="mi">0</span> <span class="n">LOC</span><span class="p">:</span><span class="mi">3607</span>
<span class="n">kernels</span> <span class="p">(</span><span class="mi">1</span> <span class="n">total</span><span class="p">)</span> <span class="p">:</span>   <span class="n">kmeansPoint</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="converting-a-project-in-place">
<h2>Converting a project “in-place”<a class="headerlink" href="#converting-a-project-in-place" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">hipify</span> <span class="o">--</span><span class="n">inplace</span>
</pre></div>
</div>
<p>For each input file FILE, this script will:</p>
<blockquote>
<div><ul class="simple">
<li>If “FILE.prehip file does not exist, copy the original code to a new file with extension “.prehip”. Then Hipify the code file.</li>
<li>If “FILE.prehip” file exists, hipify FILE.prehip and save to FILE.</li>
</ul>
</div></blockquote>
<p>This is useful for testing improvements to the hipify toolset.</p>
<p>The “hipconvertinplace.sh” script will perform inplace conversion for all code files in the specified directory. This can be quite handy when dealing with an existing CUDA code base since the script preserves the existing directory structure and filenames - so includes work. After converting in-place, you can review the code to add additional parameters to directory names.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">hipconvertinplace</span><span class="o">.</span><span class="n">sh</span> <span class="n">MY_SRC_DIR</span>
</pre></div>
</div>
</div>
<div class="section" id="distinguishing-compiler-modes">
<h2>Distinguishing Compiler Modes<a class="headerlink" href="#distinguishing-compiler-modes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="identifying-hip-target-platform">
<h3>Identifying HIP Target Platform<a class="headerlink" href="#identifying-hip-target-platform" title="Permalink to this headline">¶</a></h3>
<p>All HIP projects target either the hcc or nvcc platform. The platform affects which headers are included and which libraries are used for linking.</p>
<blockquote>
<div><ul class="simple">
<li>HIPCC_PLATFORM_HCC is defined if the HIP platform targets hcc</li>
<li>HIPCC_PLATFORM_NVCC is defined if the HIP platform targets nvcc</li>
</ul>
</div></blockquote>
<p>Many projects use a mixture of an accelerator compiler (hcc or nvcc) and a standard compiler (e.g., g++). These defines are set for both accelerator and standard compilers and thus are often the best option when writing code that uses conditional compilation.</p>
</div>
<div class="section" id="identifying-the-compiler-hcc-or-nvcc">
<h3>Identifying the Compiler: hcc or nvcc<a class="headerlink" href="#identifying-the-compiler-hcc-or-nvcc" title="Permalink to this headline">¶</a></h3>
<p>Often, it useful to know whether the underlying compiler is hcc or nvcc. This knowledge can guard platform-specific code (features that only work on the nvcc or hcc path but not both) or aid in platform-specific performance tuning.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef __HCC__</span>
<span class="o">//</span> <span class="n">Compiled</span> <span class="k">with</span> <span class="n">hcc</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef __NVCC__</span>
<span class="o">//</span> <span class="n">Compiled</span> <span class="k">with</span> <span class="n">nvcc</span>
<span class="o">//</span>  <span class="n">Could</span> <span class="n">be</span> <span class="n">compiling</span> <span class="k">with</span> <span class="n">Cuda</span> <span class="n">language</span> <span class="n">extensions</span> <span class="n">enabled</span> <span class="p">(</span><span class="k">for</span> <span class="n">example</span><span class="p">,</span> <span class="n">a</span> <span class="s2">&quot;.cu file)</span>
<span class="o">//</span>  <span class="n">Could</span> <span class="n">be</span> <span class="ow">in</span> <span class="k">pass</span><span class="o">-</span><span class="n">through</span> <span class="n">mode</span> <span class="n">to</span> <span class="n">an</span> <span class="n">underlying</span> <span class="n">host</span> <span class="nb">compile</span> <span class="n">OR</span> <span class="p">(</span><span class="k">for</span> <span class="n">example</span><span class="p">,</span> <span class="n">a</span> <span class="o">.</span><span class="n">cpp</span> <span class="n">file</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifdef __CUDACC__</span>
<span class="o">//</span> <span class="n">Compiled</span> <span class="k">with</span> <span class="n">nvcc</span> <span class="p">(</span><span class="n">Cuda</span> <span class="n">language</span> <span class="n">extensions</span> <span class="n">enabled</span><span class="p">)</span>
</pre></div>
</div>
<p>hcc directly generates the host code (using the Clang x86 target) and passes the code to another host compiler. Thus, it lacks the equivalent of the __CUDA_ACC define.</p>
<p>The macro __HIPCC__ is set if either __HCC__ or __CUDACC__ is defined. This configuration is useful in determining when code is being compiled using an accelerator-enabled compiler (hcc or nvcc) as opposed to a standard host compiler (GCC, ICC, Clang, etc.).</p>
</div>
<div class="section" id="identifying-current-compilation-pass-host-or-device">
<h3>Identifying Current Compilation Pass: Host or Device<a class="headerlink" href="#identifying-current-compilation-pass-host-or-device" title="Permalink to this headline">¶</a></h3>
<p>Both nvcc and hcc make two passes over the code: one for host code and one for device code. __HIP_DEVICE_COMPILE__ is set to a nonzero value when the compiler (hcc or nvcc) is compiling code for a device inside a __global__ kernel or for a device function. __HIP_DEVICE_COMPILE__ can replace #ifdef checks on the __CUDA_ARCH__ define.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="c1">#ifdef __CUDA_ARCH__</span>

<span class="c1">#if __HIP_DEVICE_COMPILE__</span>
</pre></div>
</div>
<p>Unlike __CUDA_ARCH__, the __HIP_DEVICE_COMPILE__ value is 1 or undefined, and it doesn’t represent the feature capability of the target device.</p>
</div>
<div class="section" id="compiler-defines-summary">
<h3>Compiler Defines: Summary<a class="headerlink" href="#compiler-defines-summary" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="24%" />
<col width="26%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Define</th>
<th class="head">hcc</th>
<th class="head">nvcc</th>
<th class="head">Other (GCC, ICC, Clang, etc.)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td colspan="4">HIP-related defines:</td>
</tr>
<tr class="row-odd"><td>__HIP_PLATFORM_HCC___</td>
<td>Defined</td>
<td>Undefined</td>
<td><div class="first last line-block">
<div class="line">Defined if targeting hcc platform;</div>
<div class="line">undefined otherwise</div>
</div>
</td>
</tr>
<tr class="row-even"><td>__HIP_PLATFORM_NVCC___</td>
<td>Undefined</td>
<td>defined</td>
<td><div class="first last line-block">
<div class="line">Defined if targeting NVcc platform;</div>
<div class="line">undefined otherwise</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>__HIP_DEVICE_COMPILE__</td>
<td><div class="first last line-block">
<div class="line">1 if compiling for device;</div>
<div class="line">undefined if compiling</div>
<div class="line">for host</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">1 if compiling for device;</div>
<div class="line">undefined if compiling</div>
<div class="line">for host</div>
</div>
</td>
<td>Undefined</td>
</tr>
<tr class="row-even"><td>__HIPCC__</td>
<td>Defined</td>
<td>Defined</td>
<td>Undefined</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_*</td>
<td><div class="first last line-block">
<div class="line">0 or 1 depending on feature</div>
<div class="line">support (see below)</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">0 or 1 depending on feature</div>
<div class="line">support (see below)</div>
</div>
</td>
<td>0</td>
</tr>
<tr class="row-even"><td colspan="4">nvcc-related defines:</td>
</tr>
<tr class="row-odd"><td>__CUDACC__</td>
<td>Undefined</td>
<td><div class="first last line-block">
<div class="line">Defined if source code is</div>
<div class="line">compiled by nvcc;</div>
<div class="line">undefined otherwise</div>
</div>
</td>
<td>Undefined</td>
</tr>
<tr class="row-even"><td>__NVCC__</td>
<td>Undefined</td>
<td>Defined</td>
<td>Undefined</td>
</tr>
<tr class="row-odd"><td>__CUDA_ARCH__</td>
<td>Undefined</td>
<td><div class="first last line-block">
<div class="line">Unsigned representing compute</div>
<div class="line">capability (e.g., “130”)if in</div>
<div class="line">device code; 0 if in host code</div>
</div>
</td>
<td>Undefined</td>
</tr>
<tr class="row-even"><td colspan="4">hcc-related defines:</td>
</tr>
<tr class="row-odd"><td>__HCC__</td>
<td>Defined</td>
<td>Undefined</td>
<td>Undefined</td>
</tr>
<tr class="row-even"><td>__HCC_ACCELERATOR__</td>
<td><div class="first last line-block">
<div class="line">Nonzero if in device code;</div>
<div class="line">otherwise undefined</div>
</div>
</td>
<td>Undefined</td>
<td>Undefined</td>
</tr>
<tr class="row-odd"><td>__clang__</td>
<td>Defined</td>
<td>Undefined</td>
<td><div class="first last line-block">
<div class="line">Defined if using Clang;</div>
<div class="line">otherwise undefined</div>
</div>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="identifying-architecture-features">
<h2>Identifying Architecture Features<a class="headerlink" href="#identifying-architecture-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hip-arch-defines">
<h3>HIP_ARCH Defines<a class="headerlink" href="#hip-arch-defines" title="Permalink to this headline">¶</a></h3>
<p>Some Cuda code tests __CUDA_ARCH__ for a specific value to determine whether the machine supports a certain architectural feature. For instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#if (__CUDA_ARCH__ &gt;= 130)</span>
<span class="o">//</span> <span class="n">doubles</span> <span class="n">are</span> <span class="n">supported</span>
</pre></div>
</div>
<p>This type of code requires special attention, since hcc/AMD and nvcc/Cuda devices have different architectural capabilities. Moreover, you can’t determine the presence of a feature using a simple comparison against an architecture’s version number. HIP provides a set of defines and device properties to query whether a specific architectural feature is supported.</p>
<p>The __HIP_ARCH_* defines can replace comparisons of __CUDA_ARCH__ values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="c1">#if (__CUDA_ARCH__ &gt;= 130)   // non-portable</span>
<span class="k">if</span> <span class="n">__HIP_ARCH_HAS_DOUBLES__</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">portable</span> <span class="n">HIP</span> <span class="n">feature</span> <span class="n">query</span>
 <span class="o">//</span> <span class="n">doubles</span> <span class="n">are</span> <span class="n">supported</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For host code, the __HIP_ARCH__* defines are set to 0. You should only use the HIP_ARCH fields in device code.</p>
</div>
<div class="section" id="device-architecture-properties">
<h3>Device-Architecture Properties<a class="headerlink" href="#device-architecture-properties" title="Permalink to this headline">¶</a></h3>
<p>Host code should query the architecture feature flags in the device properties that hipGetDeviceProperties returns, rather than testing the “major” and “minor” fields directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hipGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>
<span class="o">//</span><span class="k">if</span> <span class="p">((</span><span class="n">deviceProp</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">deviceProp</span><span class="o">.</span><span class="n">minor</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))</span>  <span class="o">//</span> <span class="n">non</span><span class="o">-</span><span class="n">portable</span>
<span class="k">if</span> <span class="p">(</span><span class="n">deviceProp</span><span class="o">.</span><span class="n">arch</span><span class="o">.</span><span class="n">hasSharedInt32Atomics</span><span class="p">)</span> <span class="p">{</span>            <span class="o">//</span> <span class="n">portable</span> <span class="n">HIP</span> <span class="n">feature</span> <span class="n">query</span>
  <span class="o">//</span> <span class="n">has</span> <span class="n">shared</span> <span class="n">int32</span> <span class="n">atomic</span> <span class="n">operations</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="table-of-architecture-properties">
<h3>Table of Architecture Properties<a class="headerlink" href="#table-of-architecture-properties" title="Permalink to this headline">¶</a></h3>
<p>The table below shows the full set of architectural properties that HIP supports.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="27%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Define (use only in device code)</td>
<td>Device Property (run-time query)</td>
<td>Comment</td>
</tr>
<tr class="row-even"><td>32-bit atomics:</td>
<td colspan="2">&#160;</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_GLOBAL_INT32_ATOMICS__</td>
<td>hasGlobalInt32Atomics</td>
<td>32-bit integer atomics for global memory</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_GLOBAL_FLOAT_ATOMIC_EXCH__</td>
<td>hasGlobalFloatAtomicExch</td>
<td>32-bit float atomic exchange for global memory</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_SHARED_INT32_ATOMICS__</td>
<td>hasSharedInt32Atomics</td>
<td>32-bit integer atomics for shared memory</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_SHARED_FLOAT_ATOMIC_EXCH__</td>
<td>hasSharedFloatAtomicExch</td>
<td>32-bit float atomic exchange for shared memory</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_FLOAT_ATOMIC_ADD__</td>
<td>hasFloatAtomicAdd</td>
<td>32-bit float atomic add in global and shared memory</td>
</tr>
<tr class="row-even"><td colspan="3">64-bit atomics:</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_GLOBAL_INT64_ATOMICS__</td>
<td>hasGlobalInt64Atomics</td>
<td>64-bit integer atomics for global memory</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_SHARED_INT64_ATOMICS__</td>
<td>hasSharedInt64Atomics</td>
<td>64-bit integer atomics for shared memory</td>
</tr>
<tr class="row-odd"><td colspan="3">Doubles:</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_DOUBLES__</td>
<td>hasDoubles</td>
<td>Double-precision floating point</td>
</tr>
<tr class="row-odd"><td colspan="3">Warp cross-lane operations:</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_WARP_VOTE__</td>
<td>hasWarpVote</td>
<td>Warp vote instructions (any, all)</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_WARP_BALLOT__</td>
<td>hasWarpBallot</td>
<td>Warp ballot instructions</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_WARP_SHUFFLE__</td>
<td>hasWarpShuffle</td>
<td>Warp shuffle operations (shfl_*)</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_WARP_FUNNEL_SHIFT__</td>
<td>hasFunnelShift</td>
<td>Funnel shift two input words into one</td>
</tr>
<tr class="row-even"><td colspan="3">Sync:</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_THREAD_FENCE_SYSTEM__</td>
<td>hasThreadFenceSystem</td>
<td>threadfence_system</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_SYNC_THREAD_EXT__</td>
<td>hasSyncThreadsExt</td>
<td>syncthreads_count, syncthreads_and, syncthreads_or</td>
</tr>
<tr class="row-odd"><td colspan="3">Miscellaneous:</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_SURFACE_FUNCS__</td>
<td>hasSurfaceFuncs</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>__HIP_ARCH_HAS_3DGRID__</td>
<td>has3dGrid</td>
<td>Grids and groups are 3D</td>
</tr>
<tr class="row-even"><td>__HIP_ARCH_HAS_DYNAMIC_PARALLEL__</td>
<td>hasDynamicParallelism</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="finding-hip">
<h2>Finding HIP<a class="headerlink" href="#finding-hip" title="Permalink to this headline">¶</a></h2>
<p>Makefiles can use the following syntax to conditionally provide a default HIP_PATH if one does not exist:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>HIP_PATH ?= $(shell hipconfig --path)
</pre></div>
</div>
</div>
<div class="section" id="hiplaunchkernel">
<h2>hipLaunchKernel<a class="headerlink" href="#hiplaunchkernel" title="Permalink to this headline">¶</a></h2>
<p>hipLaunchKernel is a variadic macro which accepts as parameters the launch configurations (grid dims, group dims, stream, dynamic shared size) followed by a variable number of kernel arguments. This sequence is then expanded into the appropriate kernel launch syntax depending on the platform.
While this can be a convenient single-line kernel launch syntax, the macro implementation can cause issues when nested inside other macros. For example, consider the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Will</span> <span class="n">cause</span> <span class="nb">compile</span> <span class="n">error</span><span class="p">:</span>
<span class="c1">#define MY_LAUNCH(command, doTrace) \</span>
<span class="p">{</span>\
   <span class="k">if</span> <span class="p">(</span><span class="n">doTrace</span><span class="p">)</span> <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;TRACE: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="c1">#command); \</span>
   <span class="p">(</span><span class="n">command</span><span class="p">);</span>   <span class="o">/*</span> <span class="n">The</span> <span class="n">nested</span> <span class="p">(</span> <span class="p">)</span> <span class="n">will</span> <span class="n">cause</span> <span class="nb">compile</span> <span class="n">error</span> <span class="o">*/</span>\
<span class="p">}</span>

<span class="n">MY_LAUNCH</span> <span class="p">(</span><span class="n">hipLaunchKernel</span><span class="p">(</span><span class="n">vAdd</span><span class="p">,</span> <span class="n">dim3</span><span class="p">(</span><span class="mi">1024</span><span class="p">),</span> <span class="n">dim3</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ad</span><span class="p">),</span> <span class="n">true</span><span class="p">,</span> <span class="s2">&quot;firstCall&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Avoid nesting macro parameters inside parenthesis - here’s an alternative that will work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define MY_LAUNCH(command, doTrace) \</span>
<span class="p">{</span>\
   <span class="k">if</span> <span class="p">(</span><span class="n">doTrace</span><span class="p">)</span> <span class="n">printf</span> <span class="p">(</span><span class="s2">&quot;TRACE: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="c1">#command); \</span>
   <span class="n">command</span><span class="p">;</span>\
<span class="p">}</span>

<span class="n">MY_LAUNCH</span> <span class="p">(</span><span class="n">hipLaunchKernel</span><span class="p">(</span><span class="n">vAdd</span><span class="p">,</span> <span class="n">dim3</span><span class="p">(</span><span class="mi">1024</span><span class="p">),</span> <span class="n">dim3</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ad</span><span class="p">),</span> <span class="n">true</span><span class="p">,</span> <span class="s2">&quot;firstCall&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="compiler-options">
<h2>Compiler Options<a class="headerlink" href="#compiler-options" title="Permalink to this headline">¶</a></h2>
<p>hipcc is a portable compiler driver that will call nvcc or hcc (depending on the target system) and attach all required include and library options. It passes options through to the target compiler. Tools that call hipcc must ensure the compiler options are appropriate for the target compiler. The hipconfig script may helpful in making infrastructure that identifies the target platform and sets options appropriately. It returns either “nvcc” or “hcc.” The following sample shows the script in a makefile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>HIP_PLATFORM=$(shell hipconfig --compiler)

ifeq (${HIP_PLATFORM}, nvcc)
        HIPCC_FLAGS = -gencode=arch=compute_20,code=sm_20
endif
ifeq (${HIP_PLATFORM}, hcc)
      HIPCC_FLAGS = -Wno-deprecated-register
endif
</pre></div>
</div>
</div>
<div class="section" id="linking-issues">
<h2>Linking Issues<a class="headerlink" href="#linking-issues" title="Permalink to this headline">¶</a></h2>
<div class="section" id="linking-with-hipcc">
<h3>Linking With hipcc<a class="headerlink" href="#linking-with-hipcc" title="Permalink to this headline">¶</a></h3>
<p>hipcc adds the necessary libraries for HIP as well as for the accelerator compiler (nvcc or hcc). We recommend linking with hipcc.</p>
</div>
<div class="section" id="lm-option">
<h3>-lm Option<a class="headerlink" href="#lm-option" title="Permalink to this headline">¶</a></h3>
<p>hipcc adds <code class="docutils literal notranslate"><span class="pre">-lm</span></code> by default to the link command.</p>
</div>
</div>
<div class="section" id="linking-code-with-other-compilers">
<h2>Linking Code With Other Compilers<a class="headerlink" href="#linking-code-with-other-compilers" title="Permalink to this headline">¶</a></h2>
<p>Cuda code often uses nvcc for accelerator code (defining and launching kernels, typically defined in .cu or .cuh files). It also uses a standard compiler (g++) for the rest of the application. nvcc is a preprocessor that employs a standard host compiler (e.g., gcc) to generate the host code. Code compiled using this tool can employ only the intersection of language features supported by both nvcc and the host compiler. In some cases, you must take care to ensure the data types and alignment of the host compiler are identical to those of the device compiler. Only some host compilers are supported—for example, recent nvcc versions lack Clang host-compiler capability.</p>
<p>hcc generates both device and host code using the same Clang-based compiler. The code uses the same API as gcc, which allows code generated by different gcc-compatible compilers to be linked together. For example, code compiled using hcc can link with code compiled using “standard” compilers (such as gcc, ICC and Clang). You must take care to ensure all compilers use the same standard C++ header and library formats.</p>
<div class="section" id="libc-and-libstdc">
<h3>libc++ and libstdc++<a class="headerlink" href="#libc-and-libstdc" title="Permalink to this headline">¶</a></h3>
<p>Version 0.86 of hipcc now uses libstdc++ by default for the HCC platform. This improves cross-linking support between G++ and hcc, in particular for interfaces that use standard C++ libraries (ie std::vector, std::string).</p>
<p>If you pass “–stdlib=libc++” to hipcc, hipcc will use the libc++ library. Generally, libc++ provides a broader set of C++ features while libstdc++ is the standard for more compilers (notably including g++).</p>
<p>When cross-linking C++ code, any C++ functions that use types from the C++ standard library (including std::string, std::vector and other containers) must use the same standard-library implementation. They include the following:</p>
<blockquote>
<div><ul class="simple">
<li>Functions or kernels defined in hcc that are called from a standard compiler</li>
<li>Functions defined in a standard compiler that are called from hcc.</li>
</ul>
</div></blockquote>
<p>Applications with these interfaces should use the default libstdc++ linking.</p>
<p>Applications which are compiled entirely with hipcc, and which benefit from advanced C++ features not supported in libstdc++, and which do not require portability to nvcc, may choose to use libc++.</p>
</div>
<div class="section" id="hip-headers-hip-runtime-h-hip-runtime-api-h">
<h3>HIP Headers (hip_runtime.h, hip_runtime_api.h)<a class="headerlink" href="#hip-headers-hip-runtime-h-hip-runtime-api-h" title="Permalink to this headline">¶</a></h3>
<p>The hip_runtime.h and hip_runtime_api.h files define the types, functions and enumerations needed to compile a HIP program:</p>
<blockquote>
<div><ul class="simple">
<li>hip_runtime_api.h: defines all the HIP runtime APIs (e.g., hipMalloc) and the types required to call them. A source file that is only calling      HIP APIs but neither defines nor launches any kernels can include hip_runtime_api.h. hip_runtime_api.h uses no custom hc language features and   can be compiled using a standard C++ compiler.</li>
<li>hip_runtime.h: included in hip_runtime_api.h. It additionally provides the types and defines required to create and launch kernels.                hip_runtime.h does use custom hc language features, but they are guarded by ifdef checks. It can be compiled using a standard C++ compiler but   will expose a subset of the available functions.</li>
</ul>
</div></blockquote>
<p>Cuda has slightly different contents for these two files. In some cases you may need to convert hipified code to include the richer hip_runtime.h instead of hip_runtime_api.h.</p>
</div>
<div class="section" id="using-a-standard-c-compiler">
<h3>Using a Standard C++ Compiler<a class="headerlink" href="#using-a-standard-c-compiler" title="Permalink to this headline">¶</a></h3>
<p>You can compile hip_runtime_api.h using a standard C or C++ compiler (e.g., gcc or ICC). The HIP include paths and defines (__HIP_PLATFORM_HCC__ or __HIP_PLATFORM_NVCC__) must pass to the standard compiler; hipconfig then returns the necessary options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">hipconfig</span> <span class="o">--</span><span class="n">cxx_config</span>
<span class="o">-</span><span class="n">D__HIP_PLATFORM_HCC__</span> <span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">user1</span><span class="o">/</span><span class="n">hip</span><span class="o">/</span><span class="n">include</span>
</pre></div>
</div>
<p>You can capture the hipconfig output and passed it to the standard compiler; below is a sample makefile syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CPPFLAGS += $(shell $(HIP_PATH)/bin/hipconfig --cpp_config)
</pre></div>
</div>
<p>nvcc includes some headers by default. However, HIP does not include default headers, and instead all required files must be explicitly included.
Specifically, files that call HIP run-time APIs or define HIP kernels must explicitly include the appropriate HIP headers. If the compilation process reports that it cannot find necessary APIs (for example, “error: identifier ‘hipSetDevice’ is undefined”), ensure that the file includes hip_runtime.h (or hip_runtime_api.h, if appropriate). The hipify script automatically converts “cuda_runtime.h” to “hip_runtime.h,” and it converts “cuda_runtime_api.h” to “hip_runtime_api.h”, but it may miss nested headers or macros.</p>
<p><strong>cuda.h</strong></p>
<p>The hcc path provides an empty cuda.h file. Some existing Cuda programs include this file but don’t require any of the functions.</p>
<p><strong>Choosing HIP File Extensions</strong></p>
<p>Many existing Cuda projects use the “.cu” and “.cuh” file extensions to indicate code that should be run through the nvcc compiler. For quick HIP ports, leaving these file extensions unchanged is often easier, as it minimizes the work required to change file names in the directory and #include statements in the files.</p>
<p>For new projects or ports which can be re-factored, we recommend the use of the extension “.hip.cpp” for header files, and “.hip.h” or “.hip.hpp” for header files. This indicates that the code is standard C++ code, but also provides a unique indication for make tools to run hipcc when appropriate.</p>
</div>
</div>
<div class="section" id="workarounds">
<h2>Workarounds<a class="headerlink" href="#workarounds" title="Permalink to this headline">¶</a></h2>
<p><strong>warpSize</strong></p>
<p>Code should not assume a warp size of 32 or 64. See Warp Cross-Lane Functions for information on how to write portable wave-aware code.</p>
<div class="section" id="memcpytosymbol">
<h3>memcpyToSymbol<a class="headerlink" href="#memcpytosymbol" title="Permalink to this headline">¶</a></h3>
<p>HIP support for hipMemCpyToSymbol is complete. This feature allows a kernel to define a device-side data symbol which can be accessed on the host side. The symbol can be in __constant or device space.</p>
<p>For example:</p>
<p>Device Code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include&lt;hip/hip_runtime.h&gt;</span>
<span class="c1">#include&lt;hip/hip_runtime_api.h&gt;</span>
<span class="c1">#include&lt;iostream&gt;</span>

<span class="c1">#define HIP_ASSERT(status) \</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">hipSuccess</span><span class="p">)</span>

<span class="c1">#define LEN 512</span>
<span class="c1">#define SIZE 2048</span>

<span class="n">__constant__</span> <span class="nb">int</span> <span class="n">Value</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>

<span class="n">__global__</span> <span class="n">void</span> <span class="n">Get</span><span class="p">(</span><span class="n">hipLaunchParm</span> <span class="n">lp</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">Ad</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">hipThreadIdx_x</span> <span class="o">+</span> <span class="n">hipBlockIdx_x</span> <span class="o">*</span> <span class="n">hipBlockDim_x</span><span class="p">;</span>
    <span class="n">Ad</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span> <span class="o">=</span> <span class="n">Value</span><span class="p">[</span><span class="n">tid</span><span class="p">];</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="o">*</span><span class="n">Ad</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">new</span> <span class="nb">int</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">new</span> <span class="nb">int</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">LEN</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
        <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">HIP_ASSERT</span><span class="p">(</span><span class="n">hipMalloc</span><span class="p">((</span><span class="n">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Ad</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">));</span>

    <span class="n">HIP_ASSERT</span><span class="p">(</span><span class="n">hipMemcpyToSymbol</span><span class="p">(</span><span class="n">HIP_SYMBOL</span><span class="p">(</span><span class="n">Value</span><span class="p">),</span> <span class="n">A</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hipMemcpyHostToDevice</span><span class="p">));</span>
    <span class="n">hipLaunchKernel</span><span class="p">(</span><span class="n">Get</span><span class="p">,</span> <span class="n">dim3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dim3</span><span class="p">(</span><span class="n">LEN</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ad</span><span class="p">);</span>
    <span class="n">HIP_ASSERT</span><span class="p">(</span><span class="n">hipMemcpy</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Ad</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">hipMemcpyDeviceToHost</span><span class="p">));</span>

    <span class="k">for</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">LEN</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;Passed&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="threadfence-system">
<h2>threadfence_system<a class="headerlink" href="#threadfence-system" title="Permalink to this headline">¶</a></h2>
<p>Threadfence_system makes all device memory writes, all writes to mapped host memory, and all writes to peer memory visible to CPU and other GPU devices. Some implementations can provide this behavior by flushing the GPU L2 cache. HIP/HCC does not provide this functionality. As a workaround, users can set the environment variable HSA_DISABLE_CACHE=1 to disable the GPU L2 cache. This will affect all accesses and for all kernels and so may have a performance impact.</p>
<p><strong>Textures and Cache Control</strong></p>
<blockquote>
<div>Texture support is under-development and not yet supported by HIP.</div></blockquote>
<p>Compute programs sometimes use textures either to access dedicated texture caches or to use the texture-sampling hardware for interpolation and clamping. The former approach uses simple point samplers with linear interpolation, essentially only reading a single point. The latter approach uses the sampler hardware to interpolate and combine multiple point samples. AMD hardware, as well as recent competing hardware, has a unified texture/L1 cache, so it no longer has a dedicated texture cache. But the nvcc path often caches global loads in the L2 cache, and some programs may benefit from explicit control of the L1 cache contents. We recommend the __ldg instruction for this purpose.</p>
<p>HIP currently lacks texture support; a future revision will add this capability. Also, AMD compilers currently load all data into both the L1 and L2 caches, so __ldg is treated as a no-op.</p>
<p>We recommend the following for functional portability:</p>
<blockquote>
<div><ul class="simple">
<li>For programs that use textures only to benefit from improved caching, use the __ldg instruction</li>
<li><dl class="first docutils">
<dt>Alternatively, use conditional compilation (see Identify HIP Target Platform)</dt>
<dd><ul class="first last">
<li>For the __HIP_PLATFORM_NVCC__ path, use the full texture path</li>
<li>For the __HIP_PLATFORM_HCC__ path, pass an additional pointer to the kernel and reference it using regular device memory-load instructions rather than texture loads. Some applications may already take this step, since it allows experimentation with caching behavior.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">texture</span><span class="o">&lt;</span><span class="nb">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cudaReadModeElementType</span><span class="o">&gt;</span> <span class="n">t_features</span><span class="p">;</span>

<span class="n">void</span> <span class="n">__global__</span> <span class="n">MyKernel</span><span class="p">(</span><span class="nb">float</span> <span class="o">*</span><span class="n">d_features</span> <span class="o">/*</span> <span class="k">pass</span> <span class="n">pointer</span> <span class="n">parameter</span><span class="p">,</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">already</span> <span class="n">available</span> <span class="o">*/...</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="o">...</span>

<span class="c1">#ifdef __HIP_PLATFORM_NVCC__</span>
    <span class="nb">float</span> <span class="n">tval</span> <span class="o">=</span> <span class="n">tex1Dfetch</span><span class="p">(</span><span class="n">t_features</span><span class="p">,</span><span class="n">addr</span><span class="p">);</span>
<span class="c1">#else</span>
    <span class="nb">float</span> <span class="n">tval</span> <span class="o">=</span> <span class="n">d_features</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>
<span class="c1">#endif</span>

<span class="p">}</span>

<span class="o">//</span> <span class="n">Host</span> <span class="n">code</span><span class="p">:</span>
<span class="n">void</span> <span class="n">myFunc</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="o">...</span>

<span class="c1">#ifdef __HIP_PLATFORM_NVCC__</span>
    <span class="n">cudaChannelFormatDesc</span> <span class="n">chDesc0</span> <span class="o">=</span> <span class="n">cudaCreateChannelDesc</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">t_features</span><span class="o">.</span><span class="n">filterMode</span> <span class="o">=</span> <span class="n">cudaFilterModePoint</span><span class="p">;</span>
    <span class="n">t_features</span><span class="o">.</span><span class="n">normalized</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
    <span class="n">t_features</span><span class="o">.</span><span class="n">channelDesc</span> <span class="o">=</span> <span class="n">chDesc0</span><span class="p">;</span>

        <span class="n">cudaBindTexture</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t_features</span><span class="p">,</span> <span class="n">d_features</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">chDesc0</span><span class="p">,</span> <span class="n">npoints</span><span class="o">*</span><span class="n">nfeatures</span><span class="o">*</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">float</span><span class="p">));</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>Additionally, many of the Rodinia benchmarks demonstrate how to modify hipified programs so that textures are not required - search for USE_TEXTURES define in the rodinia source directory.
For example, [here</p>
<p>Cuda programs that employ sampler hardware must either wait for hcc texture support or use more-sophisticated workarounds.</p>
<div class="section" id="more-tips">
<h3>More Tips<a class="headerlink" href="#more-tips" title="Permalink to this headline">¶</a></h3>
<p><strong>HIPTRACE Mode</strong></p>
<p>On an hcc/AMD platform, set the HIP_TRACE_API environment variable to see a textural API trace. Use the following bit mask:</p>
<blockquote>
<div><ul class="simple">
<li>0x1 = trace APIs</li>
<li>0x2 = trace synchronization operations</li>
<li>0x4 = trace memory allocation / deallocation</li>
</ul>
</div></blockquote>
<p><strong>Environment Variables</strong></p>
<p>On hcc/AMD platforms, set the HIP_PRINT_ENV environment variable to 1 and run an application that calls a HIP API to see all HIP-supported
environment variables and their current values:</p>
<blockquote>
<div><ul class="simple">
<li>HIP_PRINT_ENV = 1: print HIP environment variables</li>
<li>HIP_TRACE_API = 1: trace each HIP API call. Print the function name and return code to stderr as the program executes.</li>
<li>HIP_LAUNCH_BLOCKING = 0: make HIP APIs ‘host-synchronous’ so they are blocked until any kernel launches or data-copy commands are complete (an      alias is CUDA_LAUNCH_BLOCKING)</li>
<li>KMDUMPISA = 1 : Will dump the GCN ISA for all kernels into the local directory. (This flag is provided by HCC).</li>
</ul>
</div></blockquote>
<p><strong>Debugging hipcc</strong></p>
<p>To see the detailed commands that hipcc issues, set the environment variable HIPCC_VERBOSE to 1. Doing so will print to stderr the hcc (or nvcc) commands that hipcc generates.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">HIPCC_VERBOSE</span><span class="o">=</span><span class="mi">1</span>
<span class="n">make</span>
<span class="o">...</span>
<span class="n">hipcc</span><span class="o">-</span><span class="n">cmd</span><span class="p">:</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">hcc</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">hcc</span>  <span class="o">-</span><span class="n">hc</span> <span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">hcc</span><span class="o">/</span><span class="n">include</span> <span class="o">-</span><span class="n">stdlib</span><span class="o">=</span><span class="n">libc</span><span class="o">++</span> <span class="o">-</span><span class="n">I</span><span class="o">../../../../</span><span class="n">hc</span><span class="o">/</span><span class="n">include</span> <span class="o">-</span><span class="n">I</span><span class="o">../../../../</span><span class="n">include</span><span class="o">/</span><span class="n">hcc_detail</span><span class="o">/</span><span class="n">cuda</span> <span class="o">-</span>                  <span class="n">I</span><span class="o">../../../../</span>   <span class="n">include</span> <span class="o">-</span><span class="n">x</span> <span class="n">c</span><span class="o">++</span> <span class="o">-</span><span class="n">I</span><span class="o">../../</span><span class="n">common</span> <span class="o">-</span><span class="n">O3</span> <span class="o">-</span><span class="n">c</span> <span class="n">backprop_cuda</span><span class="o">.</span><span class="n">cu</span>
</pre></div>
</div>
<p><strong>What Does This Error Mean?</strong></p>
<p><strong>/usr/include/c++/v1/memory:5172:15: error: call to implicitly deleted default constructor of ‘std::__1::bad_weak_ptr’ throw bad_weak_ptr**();</strong></p>
<p>If you pass a <code class="docutils literal notranslate"><span class="pre">.cu</span></code> file, hcc will attempt to compile it as a Cuda language file. You must tell hcc that it’s in fact a C++ file: use the <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">c++</span></code> option.</p>
</div>
<div class="section" id="hip-environment-variables">
<h3>HIP Environment Variables<a class="headerlink" href="#hip-environment-variables" title="Permalink to this headline">¶</a></h3>
<p>On the HCC path, HIP provides a number of environment variables that control the behavior of HIP. Some of these are useful for application development (for example HIP_VISIBLE_DEVICES, HIP_LAUNCH_BLOCKING), some are useful for performance tuning or experimentation (for example <code class="docutils literal notranslate"><span class="pre">HIP_STAGING*</span></code> ), and some are useful for debugging (HIP_DB). You can see the environment variables supported by HIP as well as their current values and usage with the environment var “HIP_PRINT_ENV” - set this and then run any HIP application.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ HIP_PRINT_ENV=1 ./myhipapp
HIP_PRINT_ENV                  =  1 : Print HIP environment variables.
HIP_LAUNCH_BLOCKING            =  0 : Make HIP APIs &#39;host-synchronous&#39;, so they block until any kernel launches or data copy commands complete.       Alias: CUDA_LAUNCH_BLOCKING.
HIP_DB                         =  0 : Print various debug info.  Bitmask, see hip_hcc.cpp for more information.
HIP_TRACE_API                  =  0 : Trace each HIP API call.  Print function name and return code to stderr as program executes.
HIP_TRACE_API_COLOR            = green : Color to use for HIP_API.  None/Red/Green/Yellow/Blue/Magenta/Cyan/White
HIP_PROFILE_API                 =  0 : Add HIP function begin/end to ATP file generated with CodeXL
HIP_VISIBLE_DEVICES            =  0 : Only devices whose index is present in the secquence are visible to HIP applications and they are               enumerated in the order of secquence
</pre></div>
</div>
<p><strong>Editor Highlighting</strong></p>
<p>See the utils/vim or utils/gedit directories to add handy highlighting to hip files.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Thomas Edvalson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>